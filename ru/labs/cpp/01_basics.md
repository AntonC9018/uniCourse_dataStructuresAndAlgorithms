# 1. Базовый синтаксис: инструкции, переменные, указатели

- [Видео про инструкции](https://www.youtube.com/watch?v=Z8AFpeE7hOo&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=5)
- [Видео про переменные и типы](https://www.youtube.com/watch?v=6ML34OuwZrc&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=6)
- [Видео про указатели](https://www.youtube.com/watch?v=859Y0Q8pyLg&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=8)
- [Видео по основам, более углубленная информация](https://www.youtube.com/watch?v=9AhNOjjyAwU&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=14)

## Концепты

- Переменная как абстракция для ячейки памяти
- Расположение памяти переменных в памяти
- Определение и объявление переменных
- Операции с переменными (считать, вписать)
- Значение
- Адрес памяти, указатель
- Типы данных
- Выражение
- pointer arithmetic


## 1. Инструкции

- Сделайте программу, которая печатает `"Jello"` в консоль.

- *Определите* функцию `A` которая печатает `A`. Вызовите ее в функции `main`.
  <details>
  <summary>Подсказка</summary>

  Определение функции подразумевает следующий синтаксис.

  ```cpp
  void A()
  {
  }
  ```

  Вызов функции выглядит вот так:
  ```cpp
  A();
  ```

  Определение функции должно находится до вызова функции.
  Следующий код не сработает:

  ```cpp
  int main()
  {
      A()
  }
  void A()
  {
  }
  ```

  Правильный код:

  ```cpp
  void A()
  {
      std::cout << "A";
      std::endl << std::endl;
  }
  int main()
  {
      A()
  }
  ```
  </details>

- Определите 3 функции: `A`, `B`, `C`.
  `A` должна вызывать функции `B` и `C`.
  `A`, `B`, `C` все должны печатать сообщение,
  что они вызываются (то есть, для `A`, будет `"called A"`)


## 2. Переменные и типы

Объясните, что произойдет в следующих отрезках кода.
Также, запустите данный код, чтобы убедится в правильности вашей логики.

1. ```cpp
   int a = 5;
   int b = 6;
   a = b;
   b = 7;
   std::cout << a;
   ```
   <details>
   <summary>Правильный ответ:</summary>

   В `a` запишется 6 на 3-ей строчке.
   Запись в `b` 7 на 4-ой строчке не влияет на ячейку памяти переменной `a`.
   
   Важно помнить, что инструкции выполнятся по очереди, сверху вниз.

   Также важно помнить, что ячейку нельзя связать с другой ячейкой по имени.
   `a = b` копирует из ячейки `b` в ячейку `a`.
   Это одноразовое действие, они не будут связаны после выполнения этой строчки.
   Как бы вы не влияли на `b` после этого, это не отразится в `a`.
   </details>

2. ```cpp
   int a = 5;
   int b = a + 6;
   a = 7;
   std::cout << b;
   ```
   <details>
   <summary>Правильный ответ:</summary>
   
   На строчке 2 в `b` записывается *результат выражения* с правой части присваивания (`a + 6`).
   Вычисление результата этого выражения означает его превращение в одно *значение*.
   
   `a + 6` -> `5 + 6` -> `11`
   
   Результатом вычисления выражения является значение 11, которое и будет записано в ячейку `b`.
   
   Дальнейшее изменение `a` не влияет на предыдущую операцию, поскольку ее *результат* уже был сохранен в `b`.
   </details>

3. ```cpp
   int a = "abc";
   ```

   <details>
   <summary>Правильный ответ:</summary>

   Ошибка несовместимости типов при компипляции. 

   Нельзя вписать значение строчного литерала `"abc"` в ячейку, хранящую `int`.
   </details>

3. ```cpp
   int a{5};
   ```

   <details>
   <summary>Правильный ответ:</summary>

   Этот синтаксис эквивалентен следующему:
   ```cpp
   int a = 5;
   ```
   </details>

4. ```cpp
   #include <cstdint>
   #include <iostream>

   int main()
   {
       uint32_t a = 256;
       uint8_t b = a;
       uint32_t c = b;
       std::cout << c;
   }
   ```

   <details>
   <summary>Правильный ответ:</summary>

   По умолчанию, присваивание значения `uint32_t` 
   к переменной типа `uint8_t` обрезает его (truncation),
   оставляя только последний байт (наименьший байт).
   При этом компилятор не дает ошибок, 
   если не переданы флаги предупреждения при компиляцию.

   >> Чтобы подобные ситуации определялись и останавливались компилятором,
   >> необходимо передать флаги предупреждений, компилируя например, вот так:
   >> ```
   >> g++ test.cpp -Wall -Werror -Wconversion
   >> ```

   Ответ будет 0, потому что число 256 имеет запись `1 0000 0000` в двоичной системе,
   а обрезание этого числа до 8 бит оставит лишь `0000 0000`,
   удалив старшую 1.
   </details>

5. (продвинутый уровень)
   ```cpp
   #include <cstdint>
   #include <iostream>

   int main()
   {
       uint8_t a = 0;
       uint8_t b = ~a;
       int32_t c = b;
       std::cout << c;
   }
   ```

   <details>
   <summary>

   Что делает `~`?

   </summary>

   Это побитовый оператор, который переделывает все 0 в 1 в двоичном представлении числа.
   Например, `1010 0011` -> `0101 1100`.
   </details>

   <details>
   <summary>Правильный ответ</summary>

   - 3 сохраняется в переменную на 8 бит.
   - Оператор `~` применится на 8-битный 0: `0000 0000` -> `1111 1111` (255)
   - Результат сохраняется в 8-битную `b`.
   - Результат пересохраняется как есть в 32-битный `c` (для печати).
   
   </details>

6. (продвинутый уровень)
   ```cpp
   #include <cstdint>
   #include <iostream>

   int main()
   {
       uint8_t a = 255;
       int8_t b = static_cast<int8_t>(a);
       int32_t c = b;
       std::cout << c;
   }
   ```

   <details>

   <summary>

   Что делает `static_cast<int8_t>`?

   </summary>

   В данном примере, он воспринимает представление числа сохраненное в `a` как есть, но со знаком.

   Например, если `a` равен 0, в ответе будет 0, потому что `0000 0000` 
   что как целое со знаком, что без знака, является значением 0.

   Если `a` равен 128, то есть `1000 0000`, станет `-128`, потому что `1000 0000` 
   как число со знаком это -128.
   </details>

   <details>

   <summary>

   Что делает присваивание к `int32_t` для меньшего типа со знаком `int8_t`?

   </summary>

   Если значение отрицательное, ответ тоже будет отрицательным (верхние биты заполнятся 1).
   Например, -1 записывается как `1111 1111` в 8 битах,
   станет `1111 1111 1111 1111 1111 1111 1111 1111` в 32 битах,
   что тоже равно -1.

   Если значение положительное, ответ тоже будет положительным (верхние биты заполняются 0).
   Например, 10 записывается как `0000 1010` в 8 битах,
   станет `0000 0000 0000 0000 0000 0000 0000 1010` в 32 битах,
   что тоже равно 10.

   Короче говоря, в `int32_t` будет всегда храниться *то же числовое значение*.
   </details>

   <details>
   <summary>Правильный ответ:</summary>

   - 255 записывается в `a` как `1111 1111`.
   - `1111 1111` конвертируется как есть в `b`, а `1111 1111` как число со знаком — -1
   - значение -1 сохраняется в `c` как значение -1 (см. выше объяснение как).
   </details>

## 3. Указатели

Объясните, что произойдет в следующих отрезках кода.
Также, запустите данный код, чтобы убедится в правильности вашей логики.

1. ```cpp
   int a = 5;
   int* b = &a;
   std::cout << b;
   std::cout << std::endl;
   ```

2. ```cpp
   int a = 5;
   int b = *(&a);
   std::cout << b;
   std::cout << std::endl;
   ```

   <details>
   <summary>Правильный ответ:</summary>

   Вычисление выражения `*(&a)`:
   - `&a` переходит в адрес переменной `a` (скажем, 32).
   - `*32` переходит по адресу, позволяя обращатся к переменной `a`.
   - ссылка на `a` в качестве выражения дает значение переменной `a`, 5.

   `*(&a)` -> `*32` -> `a` -> `5`
   </details>

3. ```cpp
   int a = 5;
   int* b = &a;
   std::cout << (*b) + 7;
   std::cout << std::endl;
   ```

   <details>
   <summary>Правильный ответ:</summary>

   `(*b) + 7` это выражение. Вычисляется по частям:
   - `(*b)` означает переход по адресу из `b` и восприятие этого как переменной `a`.
   - `(*b) + 7` -> `a + 7` - `a` заменяется на значение из `a`, потому что используется в качестве выражения.
   - `5 + 7` -> `12`.
   </details>

4. ```cpp
   uint8_t a = 5;
   int* b = &a;
   ```

   <details>
   <summary>Правильный ответ:</summary>

   Ошибка компиляции (см. видео про указатели)
   </details>

5. ```cpp
   int a = 5;
   uint8_t* b = &a;
   ```

   <details>
   <summary>Правильный ответ:</summary>

   Ошибка компиляции (см. видео про указатели)
   </details>

6. ```cpp
   int a = 5;
   int* ap = &a;

   *ap = 6;
   std::cout << a;
   std::cout << std::endl;

   a = 7;
   std::cout << *ap;
   std::cout << std::endl;
   ```

7. ```cpp
   int a = 5;

   int* p = &a;
   *p = 6;

   int b = 7;

   p = &b;
   *p = 8;

   std::cout << a;
   std::cout << std::endl;

   std::cout << b;
   std::cout << std::endl;
   ```

   <details>
   <summary>Ответ</summary>

   ```cpp
   int a = 5; // скажем, адрес = 32
   int b = 6; // скажем, адрес = 36
   int* p = &a; // адрес p = 40, адрес в p = 32
   int** pp = &p; // адрес в pp = 40
   **pp = 7; // *(*pp) --> *(40) --> *(p) --> *32 --> a
             // то есть a = 7
   *pp = &b; // адрес в p = 36
   **pp = 8; // *(*pp) --> *(40) --> *(p) --> *36 --> b
             // то есть b = 7

   std::cout << a;
   std::cout << std::endl;

   std::cout << b;
   std::cout << std::endl;
   ```
   </details>

8. ```cpp
   int a = 7;
   int* pa = &a;
   void* voidp = p;

   uint8_t c = 9;
   uint8_t* pc = &c;

   std::cout << sizeof(pa);
   std::cout << std::endl;

   std::cout << sizeof(voidp);
   std::cout << std::endl;

   std::cout << sizeof(pc);
   std::cout << std::endl;
   ```

   <details>
   <summary>Ответ</summary>

   Размер указателя любого типа тот же, потому что это лишь адрес памяти.

   На 64-битных системах размер любого указателя 64 бита (скорее всего вы на 64-битной).
   </details>

## 4. pointer arithmetic

1. ```cpp
   int arr[2]{};
   arr[0] = 1;
   arr[1] = 2;

   std::cout << arr[0];
   std::cout << std::endl;

   std::cout << arr[1];
   std::cout << std::endl;
   ```

   <details>

   <summary>

   Что значит `int arr[2]{}`?

   </summary>

   Типа группы из 2 переменных (массив), по умолчанию равным нулю (благодаря {}).
   </details>

   <details>
   <summary>Что такое массив?</summary>

   Массив это как бы несколько переменных в одной. 
   В данном случае, переменных как бы 2: `arr[0]` и `arr[1]`.

   Выражение "как бы" тут нарочно, потому что по факту `arr[0]` и `arr[1]` — это объекты,
   а не переменные, но это в другом уроке.
   </details>

   <details>
   <summary>Ответ</summary>

   `arr[0]` и `arr[1]` как бы эквивалентны именам переменных.
   То есть напечатается 1 и 2.
   </details>

2. ```cpp
   int arr1[2]{ 21, 32 };

   std::cout << arr1[0];
   std::cout << std::endl;

   std::cout << arr1[1];
   std::cout << std::endl;
   ```

   <details>
   <summary>Что значит синтаксис?</summary>

   Здесь элементы массива заданы при создании, в том же порядке (0, 1).
   </details>

3. ```cpp
   int arr1[3]{ 1, 2, 3 };
   int arr2[]{ 1, 2, 3, 4 };

   std::cout << sizeof(arr1);
   std::cout << std::endl;

   std::cout << sizeof(arr2);
   std::cout << std::endl;
   ```

   <details>

   <summary>

   Что такое `sizeof`?

   </summary>

   Это оператор, выполняющийся во время компиляции, который дает размер всего массива в байтах.
   В данном примере, в массиве `arr1` 3 инта, каждый по 4 байта, поэтому общий размер будет 12.
   </details>

   <details>

   <summary>

   Какой размер у `arr2`?

   </summary>

   У `arr2` не задан размер, он определится автоматически из элементов.
   </details>

   <details>

   <summary>

   Что значит `[]`?

   </summary>

   Это заменится во время компиляции на количество элементов справа 
   (то есть 4, в этом примере) в качестве длины.
   </details>

   <details>
   <summary>Ответ</summary>

   3 инта по 4 байта — это 12.

   4 инта по 4 байта — это 16.
   </details>

3. ```cpp
   int arr[3]{ 1, 2, 3 };
   size_t index = 2;
   int it = arr[index];
   std::cout << it;
   std::cout << std::endl;
   ```

   <details>
   <summary>Ответ</summary>

   Можно использовать "номер переменной" из другой переменной или выражения.

   Ответ будет 3.
   </details>


3. ```cpp
   int arr[3]{};
   int* p = arr;
   *arr = 1;

   std::cout << *p;
   std::cout << std::endl;

   std::cout << arr[0];
   std::cout << std::endl;
   ```

   <details>
   <summary>Ответ</summary>

   Когда `arr` используется в качестве выражения в `int* p = arr`,
   он деградирует (decays) в указатель на первый элемент из массива.
   `arr` тут эквивалентно `&arr[0]` или `&(arr[0])`.

   И `*p`, и `*arr`, и `arr[0]` ссылаются на ту же переменную.

   Выведется 1 дважды.
   </details>

4. ```cpp
   int a = 5;
   int* b{&a};
   ```

   <details>
   <summary>Ответ</summary>

   Это как с `int`, эквивалентно `int* b = &a`.
   </details>

4. ```cpp
   int arr[2]{};
   int* p = arr;
   p = p + 1;
   *p = 2;

   std::cout << arr[1];
   std::cout << std::endl;
   ```

   <details>
   <summary>Ответ</summary>

   `p + 1` перемещает указатель на 1 базовый элемент, то есть на 1 `int`, то есть на 4.

   `p` в конце функции равен `&arr[1]`.
   Считывание из `*p` эквивалетно считыванию из `arr[1]`.
   </details>


4. ```cpp
   int arr[2]{};
   int* p = arr;
   *(p + 1) = 6;

   std::cout << arr[1];
   std::cout << std::endl;
   ```

   <details>
   <summary>Ответ</summary>

   С указателем, полученным из выражения, можно работать как и с указателем из обычной переменной.

   6. 
   </details>

4. ```cpp
   int arr[2]{};
   int* pStart = &arr[0];
   int* p = pStart + 1;

   ptrdiff_t x = p - pStart;
   std::cout << x;
   std::cout << std::endl;

   ptrdiff_t x1 = pStart - p;
   std::cout << x1;
   std::cout << std::endl;
   ```

   <details>
   <summary>Ответ</summary>

   Оператор `-` между указателями дает количество базовых элементов между ними.
   Результат может быть и отрицательным.

   Выведется 1, а потом -1.
   </details>
   
4. ```cpp
   #include <cstdint>
   #include <iostream>

   int main()
   {
       int arr[2]{};
       int* a = &arr[0];
       int* b = &arr[1];
       uintptr_t a1 = reinterpret_cast<uintptr_t>(a);
       uintptr_t b1 = reinterpret_cast<uintptr_t>(b);
       ptrdiff_t x = static_cast<ptrdiff_t>(b1 - a1);

       std::cout << x;
       std::cout << std::endl;
   }
   ```

   <details>
   <summary>Ответ</summary>

   `intptr_t` это число, занимающее столько же байтов, сколько и `int*` (вероятно, 8 байтов).

   `b1 - a1` применяется между адресами как числами. 
   Это выражение уже не имеет информацию о том, какого типа указатели были вначале.
   Оно работает на числовых значениях указателя.

   Ответ будет 4 — разница указателей в байтах.
   </details>

4. ```cpp
   int a = 5;
   int b = 6;
   int* pa = &a;
   int* pb = pa + 1;

   std::cout << *pb;
   std::cout << std::endl;
   ```

   <details>
   <summary>Ответ</summary>

   Технически, это считается UB (undefined behavior).
   Но концептуально, выведется 6 из переменной `b`.
   </details>

4. ```cpp
   int a[2]{};
   int b = 6;
   int* p = &a[3];
   *p = 7;

   std::cout << b;
   std::cout << std::endl;
   ```

   <details>
   <summary>Ответ</summary>

   Технически это такая же ситуация, как и выше.
   Запомните, что выходя за пределы массива, 
   вы технически можете добраться до памяти другой переменной.
   Выход за пределы массива не является ошибкой в C
   и никак не ограничивается во время выполнения программы.

   Здесь выведется 7.
   </details>

## 5. Терминология и синтаксис

1. Объявить `i` типа `int`
2. Инициализировать на 69
3. Определить переменную number типа `int`, дать значение 72
4. Перезаписать значение `i` на 69 + 72 (т.е. `i` + number)
5. Определить группу переменных (массив) из 3 элементов (инициализированных на 0)
6. Создать указатель на `i` (`iPointer`)
7. Считать данные по адресу из указателя в переменную number
8. Вписать в `i` через указатель значение 15
9. Сменить адрес в `iPointer` на адрес первого элемента массива
10. Переместиться на третий элемент массива, используя pointer arithmetic
11. Вписать в первый элемент массива напрямую, и в третий через `iPointer`, значения 5 и 6

