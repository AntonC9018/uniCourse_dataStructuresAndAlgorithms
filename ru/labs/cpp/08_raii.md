# Лабораторная работа 8.

**Тема: конструкторы, деструкторы, RAII**

[Видео по ООП, RAII](https://www.youtube.com/watch?v=Lc2VUm09-6s&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=16).
[Видео по видам памяти](https://www.youtube.com/watch?v=jAr_jicQv4Y&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=14).


## Пример

```cpp
// Файл HeapInt.h
#pragma once // 1
#include <cassert>

class HeapInt
{
private:
    int* heapValue; // 2

public:
    // 3
    inline HeapInt(int val) 
        // 4
        : heapValue(new int{ val })
    {
    }

    inline ~HeapInt()
    {
        // Заметка: delete проверяет на nullptr сам.
        delete heapValue; // 5
    }

    inline int& asRef()
    {
        assert(heapValue != nullptr); // 6
        return *heapValue;
    }

    HeapInt(const HeapInt& hello); // 7
    HeapInt(HeapInt&& hello);
    void operator=(const HeapInt& hello);
    void operator=(HeapInt&& hello);
};

// Файл main.cpp
#include "HeapInt.h"

void constructors()
{
    HeapInt a{5}; // 8
    HeapInt b{a}; // 9
    HeapInt c{std::move(a)}; // 10
    HeapInt d = b; // 11
    HeapInt e = std::move(b); // 12
    d = std::move(c); // 13
    d = e; // 14
}

// Файл HeapInt.cpp
#include "HeapInt.h"

// ... 15
```

Дан класс `HeapInt` выше, представляющий собой обертку для динамически выделенного инта.
В отличии от обычного `int*`, этот тип не позволяет `nullptr` как валидное значение.

Класс следует RAII, выделяя память в конструкторе, и удаляя ее в деструкторе.

1. Почему поле `heapValue` (2) приватное?

   <details>
   <summary>Подсказка</summary>

   Инкапсуляция данных.
   </details>

   <details>
   <summary>Ответ</summary>

   Чтобы его нельзя было перезаписать извне.
   Наш объект позволяет перезаписывать только значение.
   </details>

2. Что означает этот синтаксис (4)? Как его расписать в теле конструктора?

   <details>
   <summary>Ответ</summary>

   ```cpp
   inline HeapValue(int value)
   {
       // : heapValue(new int{value})

       // Выделение памяти
       // new int
       int* t = new int;

       // Инициализация объекта в динамической памяти
       // {value}
       *t = value;

       // Присваивание поля
       // : heapValue(...)
       this->heapValue = t;
   }
   ```
   </details>

3. Как скомпилировать это с помощью GCC?

   <details>
   <summary>Ответ</summary>

   > Можно еще добавить флагов `-W`.

   ```
   g++ -c main.cpp -o main.o
   g++ -c HeapValue.cpp -o HeapValue.o
   g++ main.o HeapValue.o -o program
   ```

   Или одной командой:

   ```
   g++ main.cpp HeapValue.cpp -o program
   ```
   </details>

4. Зачем (1)? Какую ситуацию это предотвратит?

   <details>
   <summary>Ответ</summary>

   Для того чтобы хедер включался только 1 раз.

   Если был бы еще один хедер, `demo.h`, который делает `#include "HeapValue.h"`,
   и оба хедера бы включались в `main.cpp`, без `pragma once`, `HeapValue.h` включился бы
   2 раза, что определит тип и функции 2 раза, что не разрешено.
   Поэтому программа не скомпилируется.

   Чтобы предотвратить подобные баги, которые часто неочевидны,
   `#pragma once` иcпользуют всегда в хедерах.
   </details>
   

5. Почему (3) определена как `inline`?

   <details>
   <summary>Ответ</summary>

   Она *определена* в хедере.
   Если не сделать ее `inline`, линкер даст ошибку, если хедер был импортирован
   больше чем в одном `compilation unit`-е (повторное определение функции).
   </details>

6. Как можно обойти ограничение, что конструктор или функция должны быть `inline`?

   <details>
   <summary>Ответ</summary>

   Оставить только прототип.
   Определить/реализовать в cpp файле.
   </details>


7. Зачем на (6) нужна проверка, если `int*` не может быть `nullptr`?

   <details>
   <summary>Подсказка</summary>

   При передачи параметром rvalue reference (`HeapInt&&`),
   из объекта может быть забрана выделенная им память.
   Тот, кто забирает эту память, должен будет также обнулить передаваемый объект.
   </details>

   <details>
   <summary>Деталь</summary>

   Так как каждый объект `HeapInt` имеет ненулевой `heapValue`,
   можно и не забирать память из `HeapInt&&`,
   а просто перекопировать значение.
   Она будет удалена в деструкторе временного объекта.

   Эта проверка остается необходимой, из-за существования move конструктора.
   </details>


8. Объясните, какой из конструкторов или перегруженных операторов вызовется для (8-14).
   Какие из них эквивалентны?

9. Как запретить синтаксис на (11-12)?

   <details>
   <summary>Подсказка</summary>

   `explicit`.
   </details>

10. Определите на (15) конструкторы и операторы на (7).

    <details>
    <summary>Как определить конструктор или перегруженный оператор отдельно?</summary>

    ```cpp
    class Hello
    {
        Hello(AnyParam p);
    }

    Hello::Hello(AnyParam p)
    {
        // ...
    }
    ```

    Для оператора, используется тот же синтаксис, что и для методов (имя метода будет `operator=`).
    </details>


    <details>
    <summary>А что в них делать?</summary>

    Помните, что все эти действия должны соблюдать правила RAII 
    (только один объект владеет конкретной памятью).
    Любой порядок их выполнения должен быть поддерживаем.

    Конструктор копирования должен выделять свежую память и копировать значение числа с переданного объекта
    (можно просто вызвать конструктор с `int` параметром, передав значение из второго объекта).

    Move конструктор должен забрать указатель из переданного временного объекта, выставив у него `nullptr`.
    Выставлять `nullptr` нужно для того, чтобы тот же указатель не удалился второй раз в деструкторе.

    Оператор присваивания должен перекопировать значение по указателю `heapValue` 
    второго объекта в уже имеющийся `heapValue`.

    Оператор присваивания с rvalue reference параметром должен сделать то же самое,
    что обычный оператор присваивания, 
    но у него есть опция и просто забрать указатель из переданного объекта 
    (одно из двух, обе реализации сойдут).
    </details>

11. В какой еще ситуации вызовется rvalue reference перегрузка конструктора или оператора присваивания?

    <details>
    <summary>Перегрузка?</summary>

    *Перегрузка* означает функция с тем же именем, но разными параметрами.
    </details>

    <details>
    <summary>Ответ</summary>

    Со временными объектами. 
    То есть для значений типа ожидаемого объекта, которые не были сохранены в переменную,
    а переданы сразу функции.
    </details>

12. Сколько раз вызовется деструктор для типа `HeapValue` после (14)?

    <details>
    <summary>Ответ</summary>

    Столько раз, сколько переменных этого типа определено.

    Например, `a` был перемещен через `std::move`,
    но его деструктор все равно вызовется.
    </details>

13. Объясните, какая по вашему мнению была мотивация того, что у этого типа не был определен дефолтный конструктор?

    <details>
    <summary>Определение понятия</summary>

    *Контракт класса* означает что-то типа правил, которые всегда выполняются при существовании объекта,
    вне зависимости от того, какие операции выполняются с ним были выполнены.

    Для этого класса, контракт заключается в том, что `heapValue` никогда не может быть равен `nullptr`.

    В более широком смысле слова, 
    контракт означает требования для входных данных (preconditions) 
    и гарантии для выходных данных (postconditions),
    и может упомянаться в интерфейсе функции.
    *Контракт класса* это по сути условия,
    которые должен выполнять *каждый* из методов этого класса,
    общий контракт для каждого метода,
    связанный со скрытым параметром (`this`).
    </details>

    <details>
    <summary>Ответ</summary>

    Для соблюдения контракта класса.

    Был выбор: 
    - сделать дефолтный конструктор, который бы вписывал `nullptr` в `heapValue`, 
      что бы нарушило контракт класса;

    - выделять память в дефолтном конструкторе, 
      что обычно делать не рекомендую (дефолтные конструкторы должны быть дешевыми);

    - не делать конструктор вообще.

    </details>

14. Объясните, почему считывать значение объекта после применения `std::move` это неправильная операция?

    <details>
    <summary>Ответ</summary>

    Объект может перестать быть действительным (вошел в невалидное состояние).

    Например, `heapValue` может стать равен `nullptr`. И только в такой ситуации.
    </details>
    
