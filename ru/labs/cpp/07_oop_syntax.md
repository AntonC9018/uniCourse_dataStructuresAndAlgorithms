# Лабораторная работа 7.

**Тема: Базовый ООП**


## Базовые концепты

1. Что такое метод?

   <details>
   <summary>Ответ</summary>
   Метод это функция, определенная внутри структуры (класса).
   </details>

2. Что такое "функция-член"?

   <details>
   <summary>Ответ</summary>
   Это синоним для слова метод.
   </details>

3. Что такое член класса?

   <details>
   <summary>Ответ</summary>
   Методы, поля. (А также конструкторы и деструкторы, но это позже.)
   </details>

4. Чем отличается instance функция (функция-экземпляр) от статической?

   <details>
   <summary>Линкер</summary>
 
   `static` для методов не связан со `static` для линкера. Не путайте их.
   </details>
   
   <details>
   <summary>Ответ</summary>
 
   Instance функции принимают скрытый параметр `this` - указатель на объект.
   </details>

5. Какой синтаксис вызова методов?

   <details>
   <summary>Ответ</summary>
 
   Instance методы могут быть вызваны только 
   используя member access синтаксис `obj.action(parameter)`,
   что передает `&obj` как скрытый параметр `this` 
   (если `obj` это указатель, допустим синтаксис `obj->action(parameter)`).
 
   Статические методы можно вызвать через `obj.action(parameter)` 
   или как `Object::action(parameter)` (`Object` - это тип переменной obj).
   Скрытый `this` не существует для них, поэтому он не передастся.
   
   </details>

6. Как только объявить метод, а определить его отдельно?

   <details>
   <summary>Ответ</summary>
   
   Объявить метод можно так же как обычную функцию. 
   ```cpp
   class Hello
   {
       static void world();
   }
   ```
 
   Определить можно либо сразу на месте, либо определив ее как `void Hello::world()`
 
   ```cpp
   class Hello
   {
       static void world();
   }
   
   // ...
   
   void Hello::world()
   {
       std::cout << "Hello" << std::endl;
   }
   ```
   
   Такой же синтаксис и с instance методами.
   </details>

7. Возможно ли определить метод внутри класса, который будет статический для линкера 
    (определен только для текущего compilation unit-a)?

   <details>
   <summary>Ответ</summary>
   
   Один конкретный — нельзя. Можно все методы в классе, приписав `static` к определению класса. Некоторым образом это можно обойти, используя вложенный класс. 
   [См. док](../../../en/05a_programming_fundamentals/05_module.md#private-members-in-the-header-file).
   </details>

8. Обязателен ли оператор `new` чтобы создать класс (структуру с методами)?

   <details>
   <summary>Ответ</summary>
   Нет. Классы можно встроить в стек, как и обычные стркутуры без методов.
   </details>

9. Влияет ли количество методов класса на то сколько байт будет занимать объект типа этого класса?

   <details>
   <summary>Ответ</summary>
   Нет. Методы привязаны к самому типу, а не к конкретному объекту.
   Сами инструкции из методов будут занимать память, но отдельную, чем память объекта.
   </details>

10. Занимает ли объект с одним методом больше памяти, чем объект без методов?

    <details>
    <summary>Ответ</summary>
 
    Нет, если методы не виртуальные. 
    Про виртуальные методы будет в теме с полиморфизмом.
 
    Вы можете проверить сколько памяти занимает любой объект, используя `sizeof`.
    </details>

11. В чем функциональное преимущество использование методов вместо обычных функций,
     принимающих параметр, подобный параметру `this`, не скрытно, первым параметром.

    <details>
    <summary>Ответ</summary>
    Функционально, то есть, в плане того что произойдет при выполнении программы, разницы нет.
    Поэтому, правильный ответ - никакого функционального преимущества методы не имеют.
 
    Методы имеют преимущество в плане структурирования кода:
    если все операции с данными какого-то типа определены внутри определения типа,
    их просто проще найти.
 
    Также, ООП дает возможность осуществлять инкапсулирование данных,
    что труднее осуществить в типичном процедуральном программировании.
    </details>


## RAII

```cpp
// Файл HeapInt.h
#pragma once // 1

class HeapInt
{
private:
    int* heapValue; // 2

public:
    // 3
    inline HeapInt(int val) 
        // 4
        : heapValue(new int{ val })
    {
    }

    inline ~HeapInt()
    {
        // Заметка: delete проверяет на nullptr сам.
        delete heapValue; // 5
    }

    inline int& asRef()
    {
        assert(heapValue != nullptr); // 6
        return *heapValue;
    }

    HeapInt(const HeapInt& hello); // 7
    HeapInt(HeapInt&& hello);
    operator=(const HeapInt& hello);
    operator=(HeapInt&& hello);
};

// Файл main.cpp
#include "HeapInt.h"

void constructors()
{
    HeapInt a{5}; // 8
    HeapInt b{a}; // 9
    HeapInt c{std::move(a)}; // 10
    HeapInt d = b; // 11
    HeapInt e = std::move(b); // 12
    d = std::move(c); // 13
    d = e; // 14
}

// Файл HeapInt.cpp
#include "HeapInt.h"

// ... 15
```

Дан класс `HeapInt` выше, представляющий собой обертку для динамически выделенного инта.
В отличии от обычного `int*`, этот тип не позволяет `nullptr` как валидное значение.

Класс следует RAII, выделяя память в конструкторе, и удаляя ее в деструкторе.

1. Почему поле `heapValue` (2) приватное?

   <details>
   <summary>Подсказка</summary>

   Инкапсуляция данных.
   </details>

   <details>
   <summary>Ответ</summary>

   Чтобы его нельзя было перезаписать извне.
   Наш объект позволяет перезаписывать только значение.
   </details>

2. Что означает этот синтаксис (4)? Как его расписать в теле конструктора?

   <details>
   <summary>Ответ</summary>

   ```cpp
   inline HeapValue(int value)
   {
       // : heapValue(new int{value})

       // Выделение памяти
       // new int
       int* t = new int;

       // Инициализация объекта в динамической памяти
       // {value}
       *t = value;

       // Присваивание поля
       // : heapValue(...)
       this->heapValue = t;
   }
   ```
   </details>

3. Как скомпилировать это с помощью GCC?

   <details>
   <summary>Ответ</summary>

   > Можно еще добавить флагов `-W`.

   ```
   g++ -c main.cpp -o main.o
   g++ -c HeapValue.cpp -o HeapValue.o
   g++ main.o HeapValue.o -o program
   ```

   Или одной командой:

   ```
   g++ main.cpp HeapValue.cpp -o program
   ```
   </details>

4. Зачем (1)? Какую ситуацию это предотвратит?

   <details>
   <summary>Ответ</summary>

   Для того чтобы хедер включался только 1 раз.

   Если был бы еще один хедер, `demo.h`, который делает `#include "HeapValue.h"`,
   и оба хедера бы включались в `main.cpp`, без `pragma once`, `HeapValue.h` включился бы
   2 раза, что определит тип и функции 2 раза, что не разрешено.
   Поэтому программа не скомпилируется.

   Чтобы предотвратить подобные баги, которые часто неочевидны,
   `#pragma once` иcпользуют всегда в хедерах.
   </details>
   

5. Почему (3) определена как `inline`?

   <details>
   <summary>Ответ</summary>

   Она *определена* в хедере.
   Если не сделать ее `inline`, линкер даст ошибку, если хедер был импортирован
   больше чем в одном `compilation unit`-е (повторное определение функции).
   </details>

6. Как можно обойти ограничение, что конструктор или функция должны быть `inline`?

   <details>
   <summary>Ответ</summary>

   Оставить только прототип.
   Определить/реализовать в cpp файле.
   </details>


7. Зачем на (6) нужна проверка, если `int*` не может быть `nullptr`?

   <details>
   <summary>Подсказка</summary>

   При передачи параметром rvalue reference (`HeapInt&&`),
   из объекта может быть забрана выделенная им память.
   Тот, кто забирает эту память, должен будет также обнулить передаваемый объект.
   </details>

   <details>
   <summary>Деталь</summary>

   Так как каждый объект `HeapInt` имеет ненулевой `heapValue`,
   можно и не забирать память из `HeapInt&&`,
   а просто перекопировать значение.
   Она будет удалена в деструкторе временного объекта.

   Эта проверка остается необходимой, из-за существования move конструктора.
   </details>


8. Объясните, какой из конструкторов или перегруженных операторов вызовется для (8-14).
   Какие из них эквивалентны?

9. Как запретить синтаксис на (11-12)?

   <details>
   <summary>Подсказка</summary>

   `explicit`.
   </details>

10. Определите на (15) конструкторы и операторы на (7).

    <details>
    <summary>Как определить конструктор или перегруженный оператор отдельно?</summary>

    ```cpp
    class Hello
    {
        Hello(AnyParam p);
    }

    Hello::Hello(AnyParam p)
    {
        // ...
    }
    ```

    Для оператора, используется тот же синтаксис, что и для методов (имя метода будет `operator=`).
    </details>


    <details>
    <summary>А что в них делать?</summary>

    Помните, что все эти действия должны соблюдать правила RAII 
    (только один объект владеет конкретной памятью).
    Любой порядок их выполнения должен быть поддерживаем.

    Конструктор копирования должен выделять свежую память и копировать значение числа с переданного объекта
    (можно просто вызвать конструктор с `int` параметром, передав значение из второго объекта).

    Move конструктор должен забрать указатель из переданного временного объекта, выставив у него `nullptr`.
    Выставлять `nullptr` нужно для того, чтобы тот же указатель не удалился второй раз в деструкторе.

    Оператор присваивания должен перекопировать значение по указателю `heapValue` 
    второго объекта в уже имеющийся `heapValue`.

    Оператор присваивания с rvalue reference параметром должен сделать то же самое,
    что обычный оператор присваивания, 
    но у него есть опция и просто забрать указатель из переданного объекта 
    (одно из двух, обе реализации сойдут).
    </details>

11. В какой еще ситуации вызовется rvalue reference перегрузка конструктора или оператора присваивания?

    <details>
    <summary>Перегрузка?</summary>

    *Перегрузка* означает функция с тем же именем, но разными параметрами.
    </details>

    <details>
    <summary>Ответ</summary>

    Со временными объектами. 
    То есть для значений типа ожидаемого объекта, которые не были сохранены в переменную,
    а переданы сразу функции.
    </details>

12. Сколько раз вызовется деструктор для типа `HeapValue` после (14)?

    <details>
    <summary>Ответ</summary>

    Столько раз, сколько переменных этого типа определено.

    Например, `a` был перемещен через `std::move`,
    но его деструктор все равно вызовется.
    </details>

13. Объясните, какая по вашему мнению была мотивация того, что у этого типа не был определен дефолтный конструктор?

    <details>
    <summary>Определение понятия</summary>

    *Контракт класса* означает что-то типа правил, которые всегда выполняются при существовании объекта,
    вне зависимости от того, какие операции выполняются с ним были выполнены.

    Для этого класса, контракт заключается в том, что `heapValue` никогда не может быть равен `nullptr`.

    В более широком смысле слова, 
    контракт означает требования для входных данных (preconditions) 
    и гарантии для выходных данных (postconditions),
    и может упомянаться в интерфейсе функции.
    *Контракт класса* это по сути условия,
    которые должна выполнять *каждый* из методов этого класса,
    общий контракт для каждого метода,
    связанный со скрытым параметром (`this`).
    </details>

    <details>
    <summary>Ответ</summary>

    Для соблюдения контракта класса.

    Был выбор: 
    - сделать дефолтный конструктор, который бы вписывал `nullptr` в `heapValue`, 
      что бы нарушило контракт класса;

    - выделять память в дефолтном конструкторе, 
      что обычно делать не рекомендую (дефолтные конструкторы должны быть дешевыми);

    - не делать конструктор вообще.

    </details>

14. Объясните, почему считывать значение объекта после применения `std::move` это неправильная операция?

    <details>
    <summary>Ответ</summary>

    Объект может перестать быть действительным (вошел в невалидное состояние).

    Например, `heapValue` может стать равен `nullptr`. И только в такой ситуации.
    </details>
    
