# Лабораторная работа 7.

**Тема: Базовый ООП**


## Базовые концепты

1. Что такое метод?

   <details>
   <summary>Ответ</summary>
   Метод это функция, определенная внутри структуры (класса).
   </details>

2. Что такое "функция-член"?

   <details>
   <summary>Ответ</summary>
   Это синоним для слова метод.
   </details>

3. Что такое член класса?

   <details>
   <summary>Ответ</summary>
   Методы, поля. (А также конструкторы и деструкторы, но это позже.)
   </details>

4. Чем отличается instance функция (функция-экземпляр) от статической?

   <details>
   <summary>Линкер</summary>
 
   `static` для методов не связан со `static` для линкера. Не путайте их.
   </details>
   
   <details>
   <summary>Ответ</summary>
 
   Instance функции принимают скрытый параметр `this` - указатель на объект.
   </details>

5. Какой синтаксис вызова методов?

   <details>
   <summary>Ответ</summary>
 
   Instance методы могут быть вызваны только 
   используя member access синтаксис `obj.action(parameter)`,
   что передает `&obj` как скрытый параметр `this` 
   (если `obj` это указатель, допустим синтаксис `obj->action(parameter)`).
 
   Статические методы можно вызвать через `obj.action(parameter)` 
   или как `Object::action(parameter)` (`Object` - это тип переменной obj).
   Скрытый `this` не существует для них, поэтому он не передастся.
   
   </details>

6. Как только объявить метод, а определить его отдельно?

   <details>
   <summary>Ответ</summary>
   
   Объявить метод можно так же как обычную функцию. 
   ```cpp
   class Hello
   {
       static void world();
   }
   ```
 
   Определить можно либо сразу на месте, либо определив ее как `void Hello::world()`
 
   ```cpp
   class Hello
   {
       static void world();
   }
   
   // ...
   
   void Hello::world()
   {
       std::cout << "Hello" << std::endl;
   }
   ```
   
   Такой же синтаксис и с instance методами.
   </details>

7. Возможно ли определить метод внутри класса, который будет статический для линкера 
    (определен только для текущего compilation unit-a)?

   <details>
   <summary>Ответ</summary>
   
   Один конкретный — нельзя. Можно все методы в классе, приписав `static` к определению класса. Некоторым образом это можно обойти, используя вложенный класс. 
   [См. док](../../../en/05a_programming_fundamentals/05_module.md#private-members-in-the-header-file).
   </details>

8. Обязателен ли оператор `new` чтобы создать класс (структуру с методами)?

   <details>
   <summary>Ответ</summary>
   Нет. Классы можно встроить в стек, как и обычные стркутуры без методов.
   </details>

9. Влияет ли количество методов класса на то сколько байт будет занимать объект типа этого класса?

   <details>
   <summary>Ответ</summary>
   Нет. Методы привязаны к самому типу, а не к конкретному объекту.
   Сами инструкции из методов будут занимать память, но отдельную, чем память объекта.
   </details>

10. Занимает ли объект с одним методом больше памяти, чем объект без методов?

   <details>
   <summary>Ответ</summary>

   Нет, если методы не виртуальные. 
   Про виртуальные методы будет в теме с интерфейсами.

   Вы можете проверить сколько памяти занимает любой объект, используя `sizeof`.
   </details>

11. В чем функциональное преимущество использование методов вместо обычных функций,
     принимающих параметр, подобный параметру `this`, не скрытно, первым параметром.

   <details>
   <summary>Ответ</summary>
   Функционально, то есть, в плане того что произойдет при выполнении программы, разницы нет.
   Поэтому, правильный ответ - никакого функционального преимущества методы не имеют.

   Методы имеют преимущество в плане структурирования кода:
   если все операции с данными какого-то типа определены внутри определения типа,
   их просто проще найти.

   Также, ООП дает возможность осуществлять инкапсулирование данных,
   что труднее осуществить в типичном процедуральном программировании.
   </details>

