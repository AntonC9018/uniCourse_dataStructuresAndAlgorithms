# 2. Структуры и функции

## 2.1 Структуры

- [Видео](https://www.youtube.com/watch?v=9AhNOjjyAwU&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=8&t=2457).

### Задание

Объяните словами что происходит в примере [`memory_example_2`](../../../en/05_programming_fundamentals/memory_example_2).
Можете скопировать файл с кодом и написать комментариями прямо в коде, что происходит.
Используйте excel таблицу из примера, чтобы визуализировать планировку памяти.

Можете в целом комментировать не каждый шаг, а что выведеться на каждом этапе, и почему 
(на что указывает в момент времени тот или иной указатель, что на данный момент записано в памяти, т.п.).
Можете также использовать дебаггер для лучшего понимания. 

### Примеры на понимание по структурам

Проанализируйте, что происходит в примерах:

1. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       a.f1 = 5;
       a.f2 = 6;

       A b;
       b = a;

       std::cout << a.f1 << std::endl;
       std::cout << a.f2 << std::endl;

       std::cout << b.f1 << std::endl;
       std::cout << b.f2 << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   `b = a` копирует значения *всех полей* `a` в `b`.
   </details>

2. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       a.f1 = 5;
       a.f2 = 6;
       A* pa = &a;
       A b = *pa;

       std::cout << b.f1 << std::endl;
       std::cout << b.f2 << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   На строчке `b = *pa`, `*pa` по сути эквивалентно прямому обращению к переменной `a`. Ситуация та же, что выше.
   </details>

3. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       a.f1 = 5;
       A* pa = &a;
       (*pa).f2 = 6;
       pa->f1 = 7;

       std::cout << a.f1 << std::endl;
       std::cout << a.f2 << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   `*pa` по сути эквивалентно обращению к `a` напрямую.

   `(*pa).f2 = 6` -> `a.f2 = 6`.

   `pa->f1` означает "перейди на переменную по адресу из `pa`, потом обратись к полю `f1`".
   Это по-другому можно выразить как `(*pa).f1`.
   И это будет по факту эквивалентно `a.f1`.
   </details>

3. ```cpp
   #include <iostream>

   struct A
   {
       int* f1;
   };

   int main()
   {
       int num = 1;
       A a;
       a.f1 = &num;
       *a.f1 = 2;

       std::cout << a.f1 << std::endl;
       std::cout << num << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   В `*a.f1`, `*` применится *после* `.`, то есть:
   `*a.f1` -> `*(&num)` -> `num`.
   После этого, `num` перезаписывается на `2`.

   Выведется адрес `num`, а затем `2`.
   </details>

3. ```cpp
   #include <iostream>

   struct Node
   {
       int value;
       Node* next;
   };

   int main()
   {
       Node end{};
       end.value = 1;
       end.next = nullptr;

       Node start{};
       start.value = 2;
       start.next = &end;

       Node* current = &start;
       std::cout << current->value << std::endl;

       current = current->next;
       std::cout << current->value << std::endl;

       current = current->next;
       std::cout << current->value << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   Здесь создается так называемый linked list (связный список), что очень часто
   применяется в программировании.

   Суть в том, что структура имеет ссылку на другую такую же.

   Конец списка указывается отсутствием указателя в последнем звене списка (`nullptr`).

   Код выведет 2, 1, а затем крашнется на последней строчке при попытке сяитать по нулевому адресу с отступом (segmentation fault).
   </details>

4. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       std::cout << sizeof(a) << std::endl;
       std::cout << sizeof(A) << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   `sizeof(a)` дает размер переменной в байтах.
   `sizeof(A)` дает размер переменной типа `A` в байтах, если такую создать.
   Обе записи эквивалентны.

   Результат будет 8, потому что в каждой структуре по 2 `int`, каждый из которых занимает 4 байта.
   </details>


4. ```cpp
   #include <iostream>

   struct A
   {
       int f1[4];
       int* f2;
   };

   int main()
   {
       std::cout << sizeof(A) << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   - `int f1[4]` - это 4 `int`, каждый по 4 байта - 16 байт;
   - `int* f2` - 8 байтов на 64-битном процессоре.

   В сумме 24 байта.
   </details>

5. (продвинутый уровень):
   ```cpp
   #include <iostream>

   struct A
   {
       uint8_t f1;
       int f2;
       uint8_t f3;
   };

   int main()
   {
       std::cout << sizeof(A) << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Тут в силу входит alignment.
   alignment делает так, что между полями остаются пустые места.

   Сначала определяется поле с наибольшем размером, обычно до 16 байтов.
   В данном примере, это `int` - 4 байта.

   Теперь, делим память на окошки по 4 байта.
   Если последующее поле не влезает целиком в оставшееся окошко по 4 байта,
   оно попадает в следующее.

   - `uint8_t f1` попадет в первый байт первого окошка;
   - `int f2` не влезает в первое окошко после `f1`, поэтому попадет в следующее.
     Оставшиеся 3 байта первого окошка будут пустовать (padding bytes);
   - `uint8_t f3` попадет в третье окошко;
   - Оставшиеся 3 байта 3-го окошка будут пустовать.

   В сумме получаем 3 окошка по 4 байта.

   Если в структуре есть поле типа другой структуры, окошко будет величиной не меньше, чем окошки этой вложенной структуры.
   </details>

## 2.2 Функции

- [Видео (сырое)](https://www.youtube.com/watch?v=LnxQKSif69s&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=10)

### Задание

В ассортименте есть 3 товара: напиток, первое и второе.
У каждого из них разные цены (например: 10, 20, 30).

У клиента есть возможность заказать какое-либо количество каждого из этих товаров.
Есть 2 клиента, каждый заказывает разные комбинации вещей.

1. Представьте данную ситуацию в программе.
   Выведите на экран стоимость заказа каждого из клиентов.

   <details>
   <summary>Затрудняюсь понять как это представить</summary>

   У вас есть 2 клиента. У каждого из них по 2 заказа. 
   Это 4 переменные.
   Значения переменных задаются в зависимости от заказа.
   Например:
   
   ```csharp
   int client1_drink = 100; // 100г напитка
   int client1_first = 0; // нет первого
   int client1_second = 250; // 250г второго
   
   int client2_drink = 0; // 0 напитка
   int client2_first = 300; // 300г первого
   int client2_second = 0; // 0 второго
   ```
   </details>

   <details>
   <summary>Получение стоимости</summary>

   ```csharp
   int client1_total = client1_drink * 10 + client_first * 20 + client_second * 30;
   ```
   </details>

2. Отделите работу с отдельными клиентами блоками.
   Внутри блоков, используйте переменные с тем же именем.

3. Создайте структуру цен.
   Упоминайте цены товаров не напрямую, а через переменную этого типа.
   Таким образом, все цены будут логически сгруппированы в одной переменной.

4. Создайте структуру выбора клиента.

5. Сделайте функцию выбора клиента, принимающую параметрами цены и выбор клиента.

   <details>
   <summary>Зачем?</summary>
   
   Чтобы убрать повторяющийся код.
   </details>

   <details>
   <summary>Как?</summary>
   
   Найдите от чего зависит код выбора клиента просмотрев его.
   Зависимость идет от цен, цены и будут первым параметром.
   
   Далее, что изменяется в каждом повторении этого кода?
   Изменяется переменная выбора клиента — это и будут следующий параметр.
   
   Далее, какой результат ожидается от этого куска кода?
   Поиск стоимости.
   Поэтому, возвращаемый тип будет `int`.
   
   ```csharp
   int customerTotal(Prices prices, Choices choices)
   {
       // ...
   }
   ```
   </details>

### Вопросы на понимание

В данных примерах, объясните:
- Сколько переменных будет существовать на разных этапах выполнения программы;
- Скомпилируется ли вообще программа и если нет, почему;
- Какие значения будут в каждой из переменных по окончанию программы.


1. ```cpp
   void func()
   {
       int b = 6;
   }
   int main()
   {
       int a = 5;
       func();
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Одна переменная `a` создается в `main`, она имеет значение 5.

   После этого, при вызове функции `F`, функция создает еще одну переменную `b`, со значением `6`.
   Она попадает в следующую свободную ячейку после `a` (если игнорировать другие данные, попадающие
   в стек, необходимые для вызова функций) во временной памяти (стеке).

   При завершении `F`, вторая переменная `b` перестает существовать - 
   то есть к ее памяти невозможно будет сослаться из `main`, однако значение 6
   продолжает существовать в этой ячейке памяти.
   </details>

2. ```cpp
   void func()
   {
       int a = 6;
   }
   int main()
   {
       int a = 5;
       func();
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Ситуация эквивалентна предыдущему примеру.
   Разница в том, что локальная переменная `b` теперь носит тоже имя `a`.
   Память этих переменных так же различна.
   </details>

3. ```cpp
   void func()
   {
       int b = 6;
   }
   int main()
   {
       int a = 5;
       func();
       b = 7;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Данный код иллюстрирует тот факт, что переменная `b` перестает существовать.
   Код не скопмилируется.
   </details>

4. ```cpp
   void func(int b)
   {
       b = 6;
   }
   int main()
   {
       int a = 5;
       func(a);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   При вызове функции, для ее параметров выделится по локальной переменной.
   В эти переменные *перекопируются* значения аргументов, 
   то есть выражений в соответствующих позициях при вызове (`a`).

   `b = 6` изменит локальную переменную, существующую при вызове `func`.
   `b = 6` не повлияет на `a`.

   В `a` будет 5.
   </details>

4. ```cpp
   void func(int a)
   {
       a = 6;
   }
   int main()
   {
       int a = 5;
       func(a);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Ситуация эквивалентна предыдущей.
   `a` как параметр в функции `func` это имя локальной переменной, создаваемой при вызове `func`.
   Этот `a` не привязан к `a` в `main`.

   В `a` будет 5.
   </details>

4. ```cpp
   struct A
   {
       int f1;
       int f2;
   };
   void func(A a)
   {
       a.f1 = 1;
       a.f2 = 2;
   }
   int main()
   {
       A a;
       a.f1 = 3;
       a.f2 = 4;
       func(a);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   `A` здесь работает как тип параметра.
   При передаче значения типа `A` передастся его копия - копия каждого из полей по отдельности.

   Опять же, имена переменных и параметров не имеют значения, они не будут свзянаны друг с другом.

   Код из `func` не повлияет на `a` из `main`.
   </details>

4. ```cpp
   struct A
   {
       int f1;
       int f2;
   };
   void func(A* a)
   {
       a->f1 = 1;
       a->f2 = 2;
   }
   int main()
   {
       A a;
       a.f1 = 3;
       a.f2 = 4;
       func(&a);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Здесь в функцию приходит адрес локальной переменной.

   `a` в `func` это **адрес, а не копия всех полей**.
   Используя его, можно сослаться на память локальной переменной из `main`, и воздествовать на нее.
   </details>

5. ```cpp
   int func(int a, int b)
   {
       return a + b;
   }
   int main()
   {
       int b = 6;
       func(1, b);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Несмотря на то, что `func` возвращает ответ, он никуда не сохраняется.
   В `b` будет ее старое значение.
   </details>

5. ```cpp
   int func(int a, int b)
   {
       return a + b;
   }
   int main()
   {
       int b = 6;
       int s = func(1, b);
       b = s;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   В `b` и в `s` будет 7.
   </details>

5. ```cpp
   int func(int a, int b)
   {
       return a + b;
   }
   int main()
   {
       int b = 6;
       int s = func(func(1, func(2, b)));
   }
   ```

   <details>
   <summary>Ответ:</summary>

   `func(func(1, func(2, b)), b)` - это сложное выражение, оно будет вычисляться наизнанку:
   - `func(2, b)` -> `func(2, 6)` -> `8`;
   - `func(1, 8)` -> `9`;
   - `func(9, b)` -> `func(9, 6)` -> `15`.
   </details>

5. ```cpp
   void func(int a)
   {
       func(a);
   }
   int main()
   {
       func(1);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Здесь будет выделятся бесконечно памяти при каждом вызове `f` самой себя,
   как минимум для переменной `a`, поскольку при вызове каждой последующей
   `f`, будет создаваться `a` локальная ей, инициализированная `a` из `f`,
   что была вызвана до этого (то есть, 1).

   В определенный момент, память в стеке кончится, и программа крашнется (stack overflow).
   </details>
