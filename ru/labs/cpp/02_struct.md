# 2. Структуры и функции

## 2.1 Структуры

- [Видео](https://www.youtube.com/watch?v=9AhNOjjyAwU&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=8&t=2457).

### Задание

Объяните словами что происходит в примере [`memory_example_2`](../../../en/05_programming_fundamentals/memory_example_2).
Можете скопировать файл с кодом и написать комментариями прямо в коде, что происходит.
Используйте excel таблицу из примера, чтобы визуализировать планировку памяти.

Можете в целом комментировать не каждый шаг, а что выведеться на каждом этапе, и почему 
(на что указывает в момент времени тот или иной указатель, что на данный момент записано в памяти, т.п.).
Можете также использовать дебаггер для лучшего понимания. 

### Примеры на понимание по структурам

Проанализируйте, что происходит в примерах:

1. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a { 1, 2 };
       std::cout << a.f1 << std::endl;
       std::cout << a.f2 << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   По умолчанию, можно использовать синтаксис инициализации через фигурные скобки
   для любых структур.
   Это задаст значения полям по очереди, в порядке их объявления.

   Выведется `1` и `2`.
   </details>

1. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       a.f1 = 5;
       int b = a.f1;
       a.f2 = b;

       std::cout << a.f1 << std::endl;
       std::cout << a.f2 << std::endl;
       std::cout << b << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Можно считывать из и вписывать в каждое из полей по отдельности.

   Выведется `5` трижды.
   </details>

1. ```cpp
   #include <iostream>

   struct A
   {
       int f;
   };

   int main()
   {
       A a;
       int* b = &a.f;
       *b = 5;
       std::cout << a.f << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Можно получать адрес на поле изнутри переменных, типа структуры.

   На строчке `int* b = &a.f`, в `&a.f`, точка выполняется первой,
   давай доступ к полю `f` внутри `a`,
   затем получаете ее адрес, используя `&`.

   В `a.f` будет сохранено значение `5`.
   </details>

1. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       int* fp { &A.f1 };
       *fp = 5;
       std::cout << *fp << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Подобное недопустимо, поскольку сама структура `A` не хранит никаких данных.
   Данные можно хранить в *переменной типа `A`*, которую необходимо заранее создать.
   </details>

1. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       a.f1 = 5;
       a.f2 = 6;

       A b;
       b = a;

       std::cout << a.f1 << std::endl;
       std::cout << a.f2 << std::endl;

       std::cout << b.f1 << std::endl;
       std::cout << b.f2 << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   `b = a` копирует значения *всех полей* `a` в `b`.
   </details>

1. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       a.f1 = 5;
       a.f2 = 6;

       A b;
       b.f1 = 7;
       b = a;

       std::cout << a.f1 << std::endl;
       std::cout << a.f2 << std::endl;

       std::cout << b.f1 << std::endl;
       std::cout << b.f2 << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   `b = a` не знает от том, какие поля уже инициализированы.
   Он копирует *все* поля, без разбору.

   По итогу, в `b` будет `f1 = 5`, `f2 = 6`.
   </details>

2. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       a.f1 = 5;
       a.f2 = 6;
       A* pa = &a;
       A b = *pa;

       std::cout << b.f1 << std::endl;
       std::cout << b.f2 << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   На строчке `b = *pa`, `*pa` по сути эквивалентно прямому обращению к переменной `a`. Ситуация та же, что выше.
   </details>

2. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       a.f1 = 5;
       a.f2 = 6;
       A* pa = &a;
       a.f1 = 7;
       A b = *pa;

       std::cout << b.f1 << std::endl;
       std::cout << b.f2 << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   В `b.f1` попадет `7`. 
   Оператор `&` берет не адрес значения `f1 = 5, f2 = 6`,
   а адрес *переменной* `a`.
   Считывая по адресу, всегда получите текущее значение `a`.
   </details>

3. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       a.f1 = 5;
       A* pa = &a;
       (*pa).f2 = 6;
       pa->f1 = 7;

       std::cout << a.f1 << std::endl;
       std::cout << a.f2 << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   `*pa` по сути эквивалентно обращению к `a` напрямую.

   `(*pa).f2 = 6` -> `a.f2 = 6`.

   `pa->f1` означает "перейди на переменную по адресу из `pa`, потом обратись к полю `f1`".
   Это по-другому можно выразить как `(*pa).f1`.
   И это будет по факту эквивалентно `a.f1`.
   </details>

3. ```cpp
   #include <iostream>

   struct A
   {
       int* f1;
   };

   int main()
   {
       int num = 1;
       A a;
       a.f1 = &num;
       *a.f1 = 2;

       std::cout << a.f1 << std::endl;
       std::cout << num << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   В `*a.f1`, `*` применится *после* `.`, то есть:
   `*a.f1` -> `*(&num)` -> `num`.
   После этого, `num` перезаписывается на `2`.

   Выведется адрес `num`, а затем `2`.
   </details>

4. ```cpp
   #include <iostream>

   struct A
   {
       int* f[2];
   };

   int main()
   {
       int var1;
       int var2;
       A a { .f = { &var1, &var2 } };
       *a.f[0] = 1;
       *a.f[1] = 2;
       int** b = a.f;
       int c = **b;

       std::cout << var1 << std::endl;
       std::cout << var2 << std::endl;

       std::cout << a.f[0] << std::endl;
       std::cout << a.f[1] << std::endl;

       std::cout << b << std::endl;
       std::cout << c << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Строчка `A a { .f = { &var1, &var2 } };` инициализирует `a`,
   вписав в поле `a.f[0]` адрес на `var1` и в `a.f[1]` адрес на `var2`. 

   В строчке `*a.f[0] = ...`, происходит переход по адресу, сохраненному в `a.f[0]`:
   `*a.f[0]` -> `*(a.f[0])` -> `*(&var1)` -> `var1`.

   В `int** b = a.f;`, `a.f` эквивалентно `&(a.f[0])`.
   Это дает ссылку на первую ячейку в массиве `f` в `a`.

   Выведется:
   - `1`, `2` как значения `var1` и `var2`;
   - адреса `var1` и `var2` как значения `a.f[0]` и `a.f[1]`;
   - `c` будет равно `1`.

   </details>

4. ```cpp
   #include <iostream>

   struct Nested
   {
       int f;
   };

   struct A
   {
       Nested nested;
       int f;
   };

   int main()
   {
       A a {
           .nested = { .f = 1 },
           .f = 2,
       };

       a.f = 3;
       a.nested = { 5 };
       a.nested.f = 6;

       std::cout << a.f << std::endl;
       std::cout << a.nested.f << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   В структуры можно вкладывать любые другие структуры.
   Это называется nesting.
   Эта техника применяется постоянно при программировании.

   Здесь, по итогу `a.f` будет равно `3`, а `a.nested.f` будет равно `6`.
   </details>

4. Почему данный код не скомпилируется?
   ```cpp
   struct A
   {
       int value;
       A other;
   };
   ```

   <details>
   <summary>Ответ:</summary>

   Нельзя вкладывать структуру в саму себя, потому что тогда она будет занимать
   бесконечно памяти. Возможно вложить указатель на другую такую структуру,
   поскольку его размер не зависит от размера структуры.
   </details>

3. ```cpp
   #include <iostream>

   struct Node
   {
       int value;
       Node* next;
   };

   int main()
   {
       Node end{};
       end.value = 1;
       end.next = nullptr;

       Node start{};
       start.value = 2;
       start.next = &end;

       Node* current = &start;
       std::cout << current->value << std::endl;

       current = current->next;
       std::cout << current->value << std::endl;

       current = current->next;
       std::cout << current->value << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   Здесь создается так называемый linked list (связный список), что очень часто
   применяется в программировании.

   Суть в том, что структура имеет ссылку на другую такую же.

   Конец списка указывается отсутствием указателя в последнем звене списка (`nullptr`).

   Код выведет 2, 1, а затем крашнется на последней строчке при попытке считать по нулевому адресу с отступом (segmentation fault).
   </details>

1. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       a.f1 = 5;
       int b = a.f1;
       a.f2 = b;

       std::cout << a.f1 << std::endl;
       std::cout << a.f2 << std::endl;
       std::cout << b << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Можно считывать из и вписывать в каждое из полей по отдельности.

   Выведется `5` трижды.
   </details>

4. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };

   int main()
   {
       A a;
       std::cout << sizeof(a) << std::endl;
       std::cout << sizeof(A) << std::endl;
   }
   ```
   <details>
   <summary>Ответ:</summary>

   `sizeof(a)` дает размер переменной в байтах.
   `sizeof(A)` дает размер переменной типа `A` в байтах, если такую создать.
   Обе записи эквивалентны.

   Результат будет 8, потому что в каждой структуре по 2 `int`, каждый из которых занимает 4 байта.
   </details>


4. ```cpp
   #include <iostream>

   struct A
   {
       int f1[4];
       int* f2;
   };

   int main()
   {
       std::cout << sizeof(A) << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   - `int f1[4]` - это 4 `int`, каждый по 4 байта - 16 байт;
   - `int* f2` - 8 байтов на 64-битном процессоре.

   В сумме 24 байта.
   </details>

4. ```cpp
   #include <iostream>

   struct A
   {
       int f;
   };

   int main()
   {
       A a { 1 };
       A* pa { &a };
       int* pf { &pa->f };
       *pf = 2;
       std::cout << a.f << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Здесь демонстрируется тот факт, что можно брать адрес поля после применения `->`.
   `&` применяется после `->`, так же, аналогично с `.`.

   `&pa->f` -> `&(pa->f)` -> `&((*pa).f)` -> `&(a.f)`

   Выведется `2`.
   </details>

4. ```cpp
   #include <iostream>

   struct A
   {
       int f;
   };

   int main()
   {
       A a { };
       A* pa { &a };
       int* pf { &pa->f };
       ptrdiff_t diff { reinterpret_cast<uint8_t*>(pf) - reinterpret_cast<uint8_t*>(pa) };
       std::cout << diff << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Выведется `0`. 

   Первое поле структуры и сама структура всегда находятся по тому же адресу в памяти.
   </details>

5. (продвинутый уровень):
   ```cpp
   #include <iostream>

   struct A
   {
       uint8_t f1;
       int f2;
       uint8_t f3;
   };

   int main()
   {
       std::cout << sizeof(A) << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Тут в силу входит alignment.
   alignment делает так, что между полями остаются пустые места.
   Это делается потому, что процессору так быстрее считывать данные из памяти.

   Сначала определяется поле с наибольшем размером, обычно до 16 байтов.
   В данном примере, это `int` - 4 байта.

   Теперь, делим память на окошки по 4 байта.
   Если последующее поле не влезает целиком в оставшееся окошко по 4 байта,
   оно попадает в следующее.

   - `uint8_t f1` попадет в первый байт первого окошка;
   - `int f2` не влезает в первое окошко после `f1`, поэтому попадет в следующее.
     Оставшиеся 3 байта первого окошка будут пустовать (padding bytes);
   - `uint8_t f3` попадет в третье окошко;
   - Оставшиеся 3 байта 3-го окошка будут пустовать.

   В сумме получаем 3 окошка по 4 байта.

   Если в структуре есть поле типа другой структуры, окошко будет величиной не меньше, чем окошки этой вложенной структуры.

   Alignment можно отключить, используя `#pragma pack`.
   </details>

5. (продвинутый уровень):
   ```cpp
   #include <iostream>

   struct A
   {
   };

   int main()
   {
       std::cout << sizeof(A) << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Выведется `1`. 

   Согласно стандарту C++, размер объекта не может быть меньше 1,
   чтобы возможно было различить 2 объекта этого типа между собой.
   Идея в том, что у 2 объектов не может быть тот же адрес памяти.

   Про объекты есть в следующей лабе.
   </details>

5. (продвинутый уровень):
   ```cpp
   #include <iostream>

   struct A
   {
       int a;
       int b;
   };

   int main()
   {
       std::cout << offsetof(A, a) << std::endl;
       std::cout << offsetof(A, b) << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   `offsetof` выполняется при компиляции и дает отступ в байтах заданного поля от начала струкуры. 

   Выведется `0` для `a` и `4` для `b`.
   </details>

## 2.2 Функции

- [Видео (сырое)](https://www.youtube.com/watch?v=LnxQKSif69s&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=10)

### Идеи

- Функция
- Вызов функции
- Определение функции
- Параметр, аргумент
- Возвращаемое значение, `return`
- Как обозначается интерфейс функции

### Задание

В ассортименте есть 3 товара: напиток, первое и второе.
У каждого из них разные цены (например: 10, 20, 30).

У клиента есть возможность заказать какое-либо количество каждого из этих товаров.
Есть 2 клиента, каждый заказывает разные комбинации вещей.

1. Представьте данную ситуацию в программе.
   Выведите на экран стоимость заказа каждого из клиентов.

   <details>
   <summary>Затрудняюсь понять как это представить</summary>

   У вас есть 2 клиента. 
   У каждого из них по количеству для каждого типа вещи. 
   Это 6 переменных.
   Значения переменных задаются в зависимости от заказа.
   Например:
   
   ```csharp
   int client1_drink = 100; // 100г напитка
   int client1_first = 0; // нет первого
   int client1_second = 250; // 250г второго
   
   int client2_drink = 0; // 0 напитка
   int client2_first = 300; // 300г первого
   int client2_second = 0; // 0 второго
   ```
   </details>

   <details>
   <summary>Получение стоимости</summary>

   ```csharp
   int client1_total = client1_drink * 10 + client_first * 20 + client_second * 30;
   ```
   </details>

2. Отделите работу с отдельными клиентами блоками.
   Внутри блоков, используйте переменные с тем же именем.

3. Создайте структуру цен.
   Упоминайте цены товаров не напрямую, а через переменную этого типа.
   Таким образом, все цены будут логически сгруппированы в одной переменной.

4. Создайте структуру выбора клиента.

5. Сделайте функцию выбора клиента, принимающую параметрами цены и выбор клиента.

   <details>
   <summary>Зачем?</summary>
   
   Чтобы убрать повторяющийся код.
   </details>

   <details>
   <summary>Как?</summary>
   
   Найдите от чего зависит код выбора клиента просмотрев его.
   Зависимость идет от цен, цены и будут первым параметром.
   
   Далее, что изменяется в каждом повторении этого кода?
   Изменяется переменная выбора клиента — это и будут следующий параметр.
   
   Далее, какой результат ожидается от этого куска кода?
   Поиск стоимости.
   Поэтому, возвращаемый тип будет `int`.
   
   ```csharp
   int customerTotal(Prices prices, Choices choices)
   {
       // ...
   }
   ```
   </details>

### Вопросы на понимание

В данных примерах, объясните:
- Сколько переменных будет существовать на разных этапах выполнения программы;
- Скомпилируется ли вообще программа и если нет, почему;
- Какие значения будут в каждой из переменных по окончанию программы.


1. ```cpp
   void func()
   {
       int b = 6;
   }
   int main()
   {
       int a = 5;
       func();
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Одна переменная `a` создается в `main`, она имеет значение 5.

   После этого, при вызове функции `func`, функция создает еще одну переменную `b`, со значением `6`.
   Она попадает в следующую свободную ячейку после `a` (если игнорировать другие данные, попадающие
   в стек, необходимые для вызова функций) во временной памяти (стеке).

   При завершении `func`, вторая переменная `b` перестает существовать - 
   то есть к ее памяти невозможно будет сослаться из `main`, однако значение 6
   продолжает существовать в этой ячейке памяти.
   </details>

2. ```cpp
   void func()
   {
       int a = 6;
   }
   int main()
   {
       int a = 5;
       func();
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Ситуация эквивалентна предыдущему примеру.
   Разница в том, что локальная переменная `b` теперь носит тоже имя `a`.
   Память этих переменных так же различна.
   </details>

3. ```cpp
   void func()
   {
       int b = 6;
   }
   int main()
   {
       int a = 5;
       func();
       b = 7;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Данный код иллюстрирует тот факт, что переменная `b` перестает существовать.
   Код не скопмилируется.
   </details>

4. ```cpp
   void func(int b)
   {
       b = 6;
   }
   int main()
   {
       int a = 5;
       func(a);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   При вызове функции, для ее параметров выделится по локальной переменной.
   В эти переменные *перекопируются* значения аргументов, 
   то есть выражений в соответствующих позициях при вызове (`a`).

   `b = 6` изменит локальную переменную, существующую при вызове `func`.
   `b = 6` не повлияет на `a`.

   В `a` будет 5.
   </details>

4. ```cpp
   void func(int a)
   {
       a = 6;
   }
   int main()
   {
       int a = 5;
       func(a);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Ситуация эквивалентна предыдущей.
   `a` как параметр в функции `func` это имя локальной переменной, создаваемой при вызове `func`.
   Этот `a` не привязан к `a` в `main`.

   В `a` будет `5`.
   </details>

4. ```cpp
   struct A
   {
       int f1;
       int f2;
   };
   void func(A a)
   {
       a.f1 = 1;
       a.f2 = 2;
   }
   int main()
   {
       A a;
       a.f1 = 3;
       a.f2 = 4;
       func(a);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   `A` здесь работает как тип параметра.
   При передаче значения типа `A` передастся его копия - копия каждого из полей по отдельности.

   Опять же, имена переменных и параметров не имеют значения, они не будут свзянаны друг с другом.

   Код из `func` не повлияет на `a` из `main`.
   </details>

4. ```cpp
   void func(int* a)
   {
       *a = 1;
   }
   int main()
   {
       int a{2};
       func(&a);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Здесь в функцию приходит адрес локальной переменной.

   `a` в `func` это **адрес, а не копия всех полей**.
   Используя его, можно сослаться на память локальной переменной из `main`, и воздествовать на нее.

   `a` перезапишется функцией на `1`.
   </details>

4. ```cpp
   #include <iostream>

   struct A
   {
       int f1;
       int f2;
   };
   void func(A* a)
   {
       a->f1 = 1;
       a->f2 = 2;
   }
   int main()
   {
       A a;
       a.f1 = 3;
       a.f2 = 4;
       func(&a);

       std::cout << a.f1 << std::endl;
       std::cout << a.f2 << std::endl;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Ситуация аналогична той, что выше.

   Здесь перезапишется значение обоих полей переменной `a` в `main`.
   </details>

5. ```cpp
   int func(int a, int b)
   {
       return a + b;
   }
   int main()
   {
       int b = 6;
       func(1, b);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Несмотря на то, что `func` возвращает ответ, он никуда не сохраняется.
   В `b` будет ее старое значение.
   </details>

5. ```cpp
   int func(int a, int b)
   {
       return a + b;
   }
   int main()
   {
       int b = 6;
       int s = func(1, b);
       b = s;
   }
   ```

   <details>
   <summary>Ответ:</summary>

   В `b` и в `s` будет 7.
   </details>

5. ```cpp
   int func(int a, int b)
   {
       return a + b;
   }
   int main()
   {
       int b = 6;
       int s = func(func(1, func(2, b)), b);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   `func(func(1, func(2, b)), b)` - это сложное выражение, оно будет вычисляться наизнанку:
   - `func(2, b)` -> `func(2, 6)` -> `8`;
   - `func(1, 8)` -> `9`;
   - `func(9, b)` -> `func(9, 6)` -> `15`.
   </details>

5. ```cpp
   void func(int a)
   {
       func(a);
   }
   int main()
   {
       func(1);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Здесь будет выделятся бесконечно памяти при каждом вызове `f` самой себя,
   как минимум для переменной `a`, поскольку при вызове каждой последующей
   `f`, будет создаваться `a` локальная ей, инициализированная `a` из `f`,
   что была вызвана до этого (то есть, 1).

   В определенный момент, память в стеке кончится, и программа крашнется (stack overflow).
   </details>

5. ```cpp
   #include <iostream>

   void func(int sum, int* a)
   {
       std::cout << sum << std::endl;
       *a = 3;
       std::cout << sum << std::endl;
   }
   int main()
   {
       int a { 1 };
       func(a + 2, &a);
   }
   ```

   <details>
   <summary>Ответ:</summary>

   Выведется `3` 2 раза, потому что сначала высчитывается результат выражения `a + 2`,
   после чего этот *результат* передается функции.
   Функция **всегда принимает параметром не выражение, а результат вычисления выражения**.

   Изменение `a` никак не влияет на сумму, поскольку это две никак не связанные ячейки памяти.
   </details>
