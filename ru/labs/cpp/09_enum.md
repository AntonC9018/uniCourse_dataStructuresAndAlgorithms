# Лабораторная работа 9.

Тема: `enum`.

[Видео](https://www.youtube.com/watch?v=Kbc6iaN3M6A&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=17).

## Чему равно значение `Test::b` и почему?

1.  ```cpp
    enum Test
    {
        a = 1,
        b = 2,
    };
    ```

2.  ```cpp
    enum Test
    {
        a = 1,
        b,
    };
    ```

3.  ```cpp
    enum Test
    {
        a,
        b,
    };
    ```

4.  ```cpp
    enum Test
    {
        a = -1,
        b,
    };
    ```

5.  ```cpp
    enum Test
    {
        a = (5 + 10 * 5) / 5,
        b,
    };
    ```

6.  ```cpp
    enum Test
    {
        other = 5,
        a = other + 6,
        b,
    };
    ```

7.  Запишите ответ как целое число и как символ.

    ```cpp
    enum Test
    {
        a = '5',
        b = '7',
    };
    ```

8.  Запишите ответ как целое число и как символ.

    ```cpp
    enum Test
    {
        a = '5',
        b,
    };
    ```

9.  Запишите ответ как целое число и как символ.

    ```cpp
    enum Test
    {
        a = 'b',
        b,
    };
    ```

9.  Запишите ответ как целое число.

    ```cpp
    enum Test
    {
        a = 'a' + '1',
        b,
    };
    ```


## Почему?

Почему `enum class` лучше чем `enum`?
Перечислите.
(Ответы есть в видео).


## Обезвреживание бомбы.

На каждой бомбе 3 провода, все разных цветов: красный, желтый, зеленый.
Нужно написать программу, которая определяет, какой провод нужно перерезать, чтобы отключить таймер бомбы.

По характеристикам бомбы можно определить верный провод.
Характеристики следующие:
- Один из портретов: Ленин, Jeorge Washington, Гитлер;
- Один из цветов лампочки: синий, белый, красный;
- Один из 2 состояний тумблера (включен или выключен);
- Значение на циферблате, от 1 до 100.

Определить нужный провод можно по следующим правилам:
1. Если портрет Ленина, бомба не взорвется, ничего резать не надо;
2. С цветом лампочки связано значение. Синий - 11, белый - 15, красный - 35.
   Если значение на циферблате меньше этого значения, нужно резать красный провод.
3. Если портрет Гитлера, цвета лампочки смещаются на 1 в предыдущем пункте. 
   То есть, синий будет иметь значение белого (15), белый - красного (35), а красный - синего (11).
4. Если числовое значение цвета лампочки равно значению на циферблате, нужно резать зеленый провод.
5. Иначе, нужно резать желтый провод.
5. Если тумблер включен, то, какой провод нужно порезать, смещается обратно на 1.
   Вместо зеленого - желтый, вместо желтого - красный, вместо красного - зеленый.
6. Если значение циферблата делится на 4, 
   нужный провод смещается вперед на это значение.

Сделайте основную логику в виде функции,
принимающей параметрами характеристики бомбы,
и возвращающую нужное действие (какой провод перерезать, и если вовсе нужно перерезать).
В `main` напишите тесты через `assert`.
Можете сделать со вводом данных с клавиатуры, но не обязательно.

Рекомендации:
- Определите `enum class`-ы там, где есть фиксированный список возможных объектов. 
  Например, цвета лампочки, личность на портрете, цвет провода, положение переключателя.
- Если состояния всего 2, можно `enum` не делать, а моделировать ситуацию через `bool`.
- Если с каждым из членов `enum`-а связано какое-то значение, 
  используйте look-up table или `switch` для их связывания.
  Возможно также присвоить самому члену это значение, но делайте это только если
  код не зависит от того, что они на 1 следуют друг за другом по значению.
- Конвертируйте объект типа определенного `enum class` в `int` и обратно через `static_cast`.
- Сдвиг вперед или назад осуществите через модулярную арифметику.
- Используйте early return, когда решение находится ранее.

> Кто сделал, сделайте мне PR с тест-кейсами :)
> 
> Я сам эту программу не делал.


<details>
<summary>Модулярная арифметика?</summary>

Идея возвращаться на начало при переходе за конец, 
и переходить на конец при заходе обратно за начало.
Как если змейка уходит за правый край, она должна появиться в том же ряду, слева.

Для нужно использовать оператор остатка от деления.
Он как бы отсекает факт полного прохода через весь ряд, или достижение конца чего бы то ни было,
как, например, конца массива с числами.

Если в массиве 3 элемента, чтобы пройти вперед на одну позицию,
с возвратом на старт при достижении конца, нужно взять 
остаток от деления на 3 после перехода на следующий индекс.

```
int i = 0;
i = (i + 1) % 3; // i == 1
i = (i + 1) % 3; // i == 2
i = (i + 1) % 3; // i == 0
i = (i + 1) % 3; // i == 1
i = (i + 1) % 3; // i == 2
```

Если смещение больше чем 3, 
все лишние переходы полностью через весь промежуток значений будут поглощены 
применением оператора остатка от деления.

```
int i = 0;
i = (i + 12) % 3; // i == 0
i = (i + 13) % 3; // i == 1
```

С переходом назад есть одна проблема если поступим тем же путем.
Оператор `%` для отрицательных чисел дает отрицательный результат.
```
int i = 1;
i = (i - 1) % 3; // i == 0
i = (i - 1) % 3; // i == -1
i = (i - 1) % 3; // i == -2
i = (i - 1) % 3; // i == 0 
```

Это можно обойти, добавив 3 к сумме перед тем, как отнять 1,
потому что лишняя 3 удалится оператором остатка от деления.
```
int i = 1;
i = (i - 1 + 3) % 3; // i == 0
i = (i - 1 + 3) % 3; // i == 2
i = (i - 1 + 3) % 3; // i == 1
i = (i - 1 + 3) % 3; // i == 0
```

Это сработает только если мы отнимаем число, которое меньше того, на которое делим (3).
Если нужно чтобы работало при отнимании любого отступа, 
можно сначала посчитать остаток, чтобы в случае отрицательного результата сделать его не меньше чем -2,
после чего добавить 3, чтобы сделать его положительным, после чего снова взять остаток, 
чтобы удалить добавленную 3 для того случая, когда на 1-ом этапе уже вышло положительное число.

```
int i = 1;
int offset = -5; // 1 целый массив назад, и еще 2 позиции
i = (((i + offset) % 3) + 3) % 3; // 2

// _0_   offset = -5, i = 1  > -3 = нет эффекта
// 0__   offset = -4         >
// __0   offset = -3         >
// _0_   offset = -2
// 0__   offset = -1
// __0   offset = 0, i = 2
```

Тут есть и другие подходы, смотри [инфу](https://stackoverflow.com/questions/14997165/fastest-way-to-get-a-positive-modulo-in-c-c).

</details>


<details>
<summary>Как обозначить отсутствие значения?</summary>

В случае, если это enum, можете выделить отдельное значение под это.
Обычно, такой член имеет имя `None`.
Можете вписать его как первый член `enum`-а, тогда его значение будет, очевидно, 0.
В этом случае будет логичнее дать `None` другое значение,
чтобы можно было продолжать использовать модулярную арифметику для значений цвета,
вставив `None` вконец `enum`-а, или задав вручную, например, -1.
Но можно и обойти крайние случаи дополнительными проверками, оставив `None` на 0.

Также можно использовать структуру для ответа, добавив в нее отдельное `bool` поле,
указывающее, если провод нужно резать вообще.
```cpp
enum class BombWireColor
{
    Red,
    Yellow,
    Green,
};

struct BombDefusionDecision
{
    bool shouldDefuse;
    BombWireColor wireColor;
};

BombDefusionDecision decideBombDefusion(BombCharacteristics bomb)
{
    if (bomb.portrait == Portrait::Lenin)
    {
        BombDefusionDecision result{};

        // После {} и так false.
        // result.shouldDefuse = false;

        return result;
    }

    // ...

    return {
        .shouldDefuse = true,
        .wireColor = BombWireColor.Green,
    };
};

int main()
{
    BombDefusionDecision decision = decideBombDefusion({ ... });
    if (decision.shouldDefuse)
    {
        std::cout << "Cutting the " << getWireColorString(decision.wireColor) << " wire" << std::endl;
    }
}
```

Это же можно сделать через `std::optional`.
</details>
