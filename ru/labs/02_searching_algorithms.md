# Лаборатоная работа 2

Цели лабы:
- Создать тип (структуру), которую будете использовать в дальнейших работах;
- Написать код сериализации и десериализации в формат CSV;
- Программирование методов поиска в неотсортированных массивах (линейный, бинарное дерево поиска)
- Программирование методов поиска в отсортированных массивах (бинарный, и один другой на выбор)
- Запись времени выполнения алгоритмов в зависимости от размера массива и расположения элементов
  (в сортированном порядке, в порядке обратным этому, в слуайном порядке).

## Процедуральная сериализация

> См. тему [про сериализацию](../07_serialization/).

Цель задания -- расписать код, который сможет *сериализовать* данные в файл CSV, 
а также *десериализовать* данные из файла CSV.

Данные должны быть представлены структурой на любую тематику на выбор с как минимум 3 типами полей:
- строковое,
- `enum class`,
- `int`.

> Можете следовать плану ниже, если вам сложно самим разбить задачу на подзадачи.

1. Распишите код для структуры данных, с которой будете впоследствие работать.
   Эту структуру будете использовать и в дальнейшем.
   Структура должна иметь как минимум 3 поля:

   - Строковое поле (C-string, т.е. `char` массив с максимальной фиксированной длиной,
     и нулевым символом на конце; можете использовать `std::array`). 
     ([см.](../05a_programming_fundamentals/08_strings.md))

     Ещё как вариант, можете использовать `std::string`,
     но в этом случае вы должны иметь уверенные знания OOP (всех видов кострукторов, RAII, move),
     и осознавать все скрытые операции, которые происходят в вашей программе.

     Ещё как вариант, можете хранить строку в динамической памяти,
     а в структуре хранить указатель на эту память.
     Но не забудьте очищать эту память тогда, после использования.

   - Целочисленное поле (`int`),

   - `enum class` поле (например, `Gender` с возможными значениями `Male` и `Female`)
     ([см.](../05a_programming_fundamentals/04_enum.md)).

2. Распишите по функции для каждого поля, которая принимает параметром `std::ostream&` 
   и вписывает в него сериализованное значение поля:

   - Строковое значение вписывается как есть, до нулевого байта.
     Можете предположить ASCII кодировку.

   - Целочисленное значение вписывайте строкой, в десятичной системе счисления.

   - `enum` вписывайте либо как целое число,
     либо как сокращение его имени (например, `Male` -> `M`),
     либо строкой с названием, либо один из этих вариантов по выбору, параметром.
     Решайте сами.

3. Распишите функцию, которая принимает параметром `std::ostream&` 
   и ссылку на ваш объект, и сериализует *весь объект*.

   Сериализуйте каждое поле, используя функции, расписанные ранее.

   Разделите значения полей запятыми.

   > Этот формат называется CSV -- comma separated values

4. Распишите по функции, которая *парсит* каждое поле структуры, из заданного `std::istream&`:

   - Для функции считывающую строку, пускай принимает параметром `std::span` буфера,
     копирует туда строку, и вписывает нулевой байт после.
     Можете сделать чтобы фукнция возвращала `std::array` со строкой вместо игр с указателем.

   - Для функции считывающую целое число, напишите свою функцию конвертирования,
     или импортируйте [`boost::try_lexical_cast`](https://www.boost.org/doc/libs/1_61_0/doc/html/boost_lexical_cast/synopsis.html#boost_lexical_cast.synopsis.try_lexical_convert),
     или используйте `std::stoi`, используя exception handling.
     [Смотри некоторые объяснения](https://stackoverflow.com/a/11599810).

   - Для функции считывающую `enum`, логика будет зависеть от того, какое представление
     вы выбрали для сериализации `enum` в предыдущем задании:

     * Если храните числом, используйте `std::stoi`, проверьте если входит в диапазон значений,
       и переконвертируйте в нужный тип (через `static_cast` или просто C каст).

     * Если сериализуете как строку, можете считать в локальный буфер
       и использовать `std::strcmp` чтобы сравнить с каждым возможным значением.

     * Если храните как символ, считайте как `char`, и сделайте `switch` чтобы выбрать
       нужное значение `enum`. 

5. Распишите функцию, которая принимает параметром `std::istream&`,
   и десериализует *весь объект*, возвращая его, и `true`, если десериализация прошла успешно. 

   Для этого можете определить структуру `DeserializationResult`, или использовать `std::optional`.

   Десериализуйте каждое поле, используя функции, расписанные ранее.

   Ожидайте что значение полей в строке разделены запятыми.

   Если есть лишние запятые, или находите предварительный переход на новую строку
   (то есть до того как успели считать все значения полей),
   возвращайте `false` в результате.

    ```cpp
    struct DeserializationResult
    {
        bool success;
        Person value;
    };

    DeserializationResult deserialize(std::istream& stream)
    {
        Person result;
        // ...
        if (serializationFailed)
        {
            return { false, {} };
        }
        else
        {
            return { true, person };
        }
    }
    ```

    Еще одним вариантом будет передача ссылки на объект, куда должен вписаться результат.

6. Распишите функцию, которая сериализует `std::span` из объектов вашей структуры,
   который приходит параметром, в `std::ostream&`, который тоже передавайте параметром.

   Сериализуйте каждый объект, используя функцию сериализации, расписанную ранее.

   Разделите объекты переходом на новую строку.

7. Сделайте подобную функцию, которая считывает из заданного параметром `std::istream&`,
   и десериализует каждую строку в `std::vector`,
   или в переменную типа вашего динамического массива из лабы 4,
   из объектов вашей структуры.

8. Создайте файл, в котором вручную пропишите несколько сериализованных объектов,
   или создайте программу, которая создает такой файл, генерируя данные случайным образом,
   и запустите ее.

9. Создайте программу, которая десериализует данные из этого файла,
   изменяет каким-то образом поля одного из элементов,
   добавляет новый элемент в конец,
   и сериализует все данные обратно в тот же файл,
   перезаписывая все содержимое файла.

   Разрешается чтобы вывод происходил в другой файл, отличный от входного.

   Используйте [fstream](https://cplusplus.com/reference/fstream/fstream/open/) для этого.
   (Можете передавать `fstream` как `ostream&` и `istream&` в ваши функции сериализации и десериализации).

10. Еще одна мелочь: так как значени полей будут разделены запятыми, убедитесь, что строчные поля не включают запятые, чтобы ничего не слетало из-за этого.
    Для этого добавьте проверок строк до сериализации. Можете сигнализировать ошибку возвратом `false` функцией сериализации, или определите `enum class` с возможными ошибками сериализации, и возвращайте значения из этого `enum`-а.

## Система подсчета времени выполнения алгоритмов

Поскольку в дальнейшем нужно будет практически анализировать скорость алгоритмов
в разных ситуациях, нужно создать систему, которая позволит вам совершить эти проверки.

Подходов может быть много, самый примитивный (без использования полиморфизма) наверное будет
заключаться в использовании нескольких вложенных циклов и switch.
Примерный outline:

```cpp
std::array<std::vector<Record>> allData;
allData.resize(DATA_COUNT);

std::array<std::string_view, DATA_COUNT> fileNames =
{
    { "small.csv" },
    { "medium.csv" },
    { "large.csv" },
};

bool hasErrors = false;
for (int di; di < DATA_COUNT; di++)
{
    std::string_view fileName = fileNames[di];
    ifstream file{fileName};
    bool success = parseRecordsFromCsv(file, allData[di]);
    if (!success)
    {
        // You might return more context here,
        // depends on the implementation of the csv parser.
        std::cout << "Could not parse file " << fileName;
        hasErrors = true;
    }
}

if (hasErrors)
{
    return 1;
}

std::vector<Record> items;
for (int ai = 0; ai < ALGORITHM_COUNT; ai++)
{
    for (int di; di < DATA_COUNT; di++)
    {
        const std::vector<Record>& sortedData = allData[di];
        items.resize(sortedData.size());

        for (int si = 0; si < SHUFFLE_COUNT; si++)
        {
            time_t totalTime = 0;
            for (int ei = 0; ei < EXPERIMENT_COUNT; ei++)
            {
                switch (si)
                {
                    // Sorted array
                    case 0:
                    {
                        // Copy from sortedData into items
                        break;
                    }

                    // Unsorted array
                    case 1:
                    {
                        // Copy from sortedData in some random order
                        break;
                    }

                    // Unsorted
                    case 2:
                    {
                        // Copy in reverse order
                        break;
                    }
                }

                time_t experimentStartTime = ...;

                switch (ai)
                {
                    // Linear search
                    case 0:
                    {
                        // ...
                        break;
                    }

                    // Binary search tree
                    case 1:
                    {
                        // ...
                        break;
                    }
                }

                time_t experimentEndTime = ...;
                totalTime += experimentEndTime - experimentStartTime;
            }

            // Store the time for this type of shuffle
            // ...
        }

        // Store the times for each shuffle for this data size
    }

    {
        // Print the total times for this algorithm
        std::array<std::string_view, ALGORITHM_COUNT> algorithmNames =
        {
            { "Linear" },
            { "Binary Search Tree" },
        };
        std::string_view algorithmName = algorithmNames[ai];

        std::cout << "Average time for the algorithm " << algorithmName << ": ";
        // ...
    }
}
```

Однако наверняка заметите при программировании,
что вытащить общий код записи времени сложно.
Это лучше решить через полиморфизм (передавать функцию алгоритма параметром).
Про полиморфизм почитайте [здесь](../05a_programming_fundamentals/11_polymorphism.md),
но надо знать и про [темплейты](../05a_programming_fundamentals/07_template.md),
и про указатели на функции (не особо глубоко, просто понимать базовый синтаксис).


## Программирования алгоритмов

Напишите код для следующих алгоритмов:
- Линейный поиск
- Бинарное дерево посика
- Бинарный поиск
- Один алгоритм поиска в отсортированных массивах на выбор

Протестируйте алгоритмы на разных размерностях массива (там где применимо), и разном расположении элементов:
- Отсортированный массив (меньший к большему)
- Обратно отсортированный массив (больший к меньшему)
- Случайный порядок элементов

Проводите тестирование несколько раз (5+), и усредняйте результаты.

Можете проводить все тесты в одной программе, или каждый тест в своей,
а можете использовать аргументы командной строки для выбора теста
(найдите как с этим работать, если решите пойти этим путем).

Для работы со временем используйте библиотеки `std::chrono` или `ctime`.
Вместо всего этого можете также использовать консольные команды
`Measure-Command` в PowerShell (Windows), или `time` в bash (Linux/Mac/WSL).

Проанализируйте полученные результаты:
- Сравните как затраченное время зависит от количества
  и расположения элементов для каждого из алгоритмов.
- Сравните практическую сложность каждого из алгоритмов
  (затраченное время в зависимости от количества элементов) с теоретической.
- Объясните в каких ситуациях стоит применить тот или иной алгоритм,
  и объясните почему он оптимальней других для этих задач.

