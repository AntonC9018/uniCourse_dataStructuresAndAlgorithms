# Лаборатоная работа 5

Тема: **Что такое функции, вызов функций, stack**.

[Сопровождающее видео 1](https://www.youtube.com/watch?v=jTRJM_gmhU4&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=5)

[Сопровождающее видео 2](https://www.youtube.com/watch?v=jTRJM_gmhU4&list=PL4sUOB8DjVlWUcSaCu0xPcK7rYeRwGpl7&index=7)

## Концепты

- Выполнимый файл (executable)
- Функция
- Адрес инструкции, Instruction Pointer
- Stack, Stack Pointer
- Адрес возврата
- Выход из функции
- Возврат значения из функции
- Локальная переменная

## Анализ 1

**Возможно ли (технически) перезаписать локальную переменную из другой функции?**

Объясните код ниже (код начинает выполняться с функции `main`). 
Этот код не скомпилируется как есть, проанализируйте его на концептуальном уровне.
`sp` означает stack pointer.
Предположите, что локальные переменные хранятся на стеке, и что адрес возврата занимает 4 байта.
Чему будет равен `x` и почему?

```c
void f()
{
    *(sp - 8) = 1;
    return;
}

void main()
{
    int x;
    x = 0;
    f();
    return; // x = ?
}
```

<details>
<summary>Ответ</summary>
Стек будет выглядеть следующим образом.

1. До строки с вызовом `f();`

| sp - 4 | sp |
| -----  | -- |
| x (0)  | ?? |

2. На первой строке `f`:

| sp - 8 | sp - 4                            | sp |
| -----  | ------                            | -- |
| x (0)  | адрес возврата к `return;` из `g` | ?? |

3. На `return;` из `f`

| sp - 8 | sp - 4                            | sp |
| -----  | ------                            | -- |
| x (1)  | адрес возврата к `return;` из `g` | ?? |

4. На `return;` из `g`

| sp - 4 | sp |
| -----  | ------                            |
| x (1)  | адрес возврата к `return;` из `g` |

`sp - 8` при выполнении `f` ссылается на адрес локальной переменной `x` из `g`.
</details>

Если предположить, что при попытке возврата на адрес инструкции 0, программа крашится (завершается с ошибкой),
как заставить программу выше крашнуться, сменив 1 символ в коде?

<details>
<summary>Ответ</summary>
`sp - 8  -->  sp - 4`, что равно адресу адреса возврата.
Таким образом, сможете перезаписать адрес возврата на 0.
При попытке возврата по этому адресу, программа крашнется.
</details>


> Подобное явление - это частая ошибка в C, особенно при работе с массивами.
> Оно также носит имя *stack corruption*.
> Компилятор иногда вставляет в стек защиту от этого в режиме debugging, 
> что помогает найти подобные ошибки (погуглите если интересно).


## Анализ 2

**Бесконечная рекурсия**

> Код начинает выполняться с функции `main`.

Объясните что сделает программа ниже:

```
void f()
{
    f();
    return;
}
int main()
{
    f();
    return 0;
}
```

> При попытке сдвига `sp` за пределы стека (за пределы максимального адреса, выделенного под стек),
> случается stack overflow. И программа обычно крашится.
