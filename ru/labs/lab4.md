# Лаборатоная работа 4

## 1. Процедуральный динамический массив

Распишите код для структуры данных динамического массива:

```cpp
struct DynamicArray
{
    // ...
}
```

1. Создайте factory-функцию, которая возвращает массив изначальной максимальной длины,
   заданной параметром `capacity`.
   Создайте еще одну, которая выставляет какой-нибудь дефолтный `capacity` (например 4).

```cpp
void test1()
{
    DynamicArray arr = createDynamicArrayWithCapacity(10);
    assert(arr.capacity == 10);
}
```

2. Он должен давать доступ к размерности буфера (`capacity`),
   хранить текущее количество элементов (`length` / `count`).

```cpp
void test2()
{
    DynamicArray arr = createDynamicArray();
    assert(arr.length == 0);
    addElementToArray(arr, 5);
    assert(arr.length == 1);
}
```

3. При добавлении элементов в массив, удваивайте длину, если массив полный.
   Имеется в виду, аллоцируйте буфер двойной длины, и перекопируйте все элементы.
   Добавляйте элемент в текущий конец массива.

```cpp
void test3()
{
    DynamicArray arr = createDynamicArrayWithCapacity(1);
    addElementToArray(arr, 5);
    assert(arr.capacity == 1);
    addElementToArray(arr, 10);
    assert(arr.capacity == 2);
    addElementToArray(arr, 20);
    assert(arr.capacity == 4);
}
```

4. Создайте функцию для доступа к элементам массива по индексу.
   Выполняйте проверку длины в этой функции, используя `assert`.

```cpp
void test4()
{
    DynamicArray arr = createDynamicArray();
    addElementToArray(arr, 5);
    int el = getElementAtIndex(arr, 0);
    assert(el == 5);
}
```

5. Создайте функцию, которая возвращает текущий кусок массива как `std::span`.
   Пусть добавление элементов в массив инвалидирует этот взятый кусок 
   (то есть можете не париться и просто стирать эту память без лишних проверок, если надо).

```cpp
void test5()
{
    DynamicArray arr{};
    addElementToArray(arr, 5);
    addElementToArray(arr, 6);
    addElementToArray(arr, 7);

    std::span<int> span = getCurrentSpan(arr);

    assert(span.size() == 3);
    assert(span[0] == 5);
    assert(span[1] == 6);
    assert(span[2] == 7);
}
```

6. Создайте функцию, которая очищает динамическую память, выделенную функциями массива.
   Вызывайте эту функцию когда память массива больше не нужна (`free` / `destroy`).

7. Создайте функцию main в которой выполняются проверки всех этих фич 
   (в отдельных фнукциях, или в отдельных скоупах).
   Сделайте функции статическими, чтобы их невозможно было притянуть в другом коде.
   По необходимости допишите своих тестов (как минимум 1).

8. Отделите код связанный со структурой в отдельный файл.
   - Объявления функций для взаимодейтсвия со структурой и саму структуру положите в файл `dynamicArray.h`.
   - В `main.cpp` включайте файл `dynamicArray.h`.
   - В файл `dynamicArray.cpp` положите имплементации функций.
     > Можете положить очень короткие функции в `dynamicArray.h` как `static inline`.
   - Если есть вспомогательные функции, который используете в коде массива, но не в `main`,
     сделайте их `static` и не добавляйте их в `dynamicArray.h`.
   - Пропишите команду которой компилируйте в `.bat` (или `.sh`) скрипт в папке с лабой.

  
## 2. То же самое, но RAII

**Это задание только для второкурсников!**

Проделайте то же самое, но:

1. Вместо factory функций, используйте дефолтный конструктор, и конструктор с параметром `capacity`.
2. Вместо `free` / `destroy`, определите деструктор.
3. Переопределите конструктор копирования.
4. Переопределите оператор присваивания.
5. Определите move конструктор.
6. Переопределите индексатор под доступ к элементу.
7. `addElementToArray` сделайте методом и назовите `add`.
8. Поля сделайте `private`, сменив `struct` на `class`.
9. Предоставьте возможность считывать значения полей, 
   определив методы `size` и `capacity` (read-only properties).
10. Используйте `template <typename T>`, чтобы не ограничивать возможные типы интом.
11. В функции `main`, протестируйте все фичи, и покажите примеры использования.

> Интерфейс здесь должен выйти примерно как у `std::vector`.

- Какие ошибки позволяет совершить процедуральная версия по сравнению с OOP версией? 
  (подсказка: публичные поля, создание копий).
- Какую версию проще понять / использовать? В каких ситуациях? Почему?

Итераторы (дополнительно):

1. Сделайте возможной итерацию `foreach`. 
   Для этого можете либо создать свой итератор, либо использовать метод, который возвращал `std::span`.

## 3. Encapsulation

- Объясните кратко, что и каким образом энкапсулируется в вашем коде (операции? данные?).
- Объясните кратко, какую связь имеет понятие интерфейса и энкапсуляция.