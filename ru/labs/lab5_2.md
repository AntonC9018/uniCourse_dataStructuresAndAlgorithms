# Лаборатоная работа 5 для ВТОРОГО КУРСА!

> См. тему [про сериализацию](../07_serialization/).

## Процедуральная сериализация

Цель задания -- расписать код, который сможет *сериализовать* данные в файл CSV, 
а также *десериализовать* данные из файла CSV.

1. Распишите код для структуры данных, с которой будете впоследствие работать.
   Структура должна иметь как минимум 3 поля:

   - Строковое поле (C-string, т.е. `char` массив с максимальной фиксированной длиной,
     и нулевым символом на конце; можете использовать `std::array`).

     Ещё как вариант, можете использовать `std::string`, но тогда удалите деструктор, и сделайте функцию удаления, которая вызывает деструктор `std::string` для этого поля, и удаляйте объекты вручную когда надо.

     Ещё как вариант, можете хранить строку в динамической памяти, а в структуре хранить указатель на эту память. Но не забудьте очищать эту память тогда, после использования.

   - Целочисленное поле (`int`),

   - `enum class` поле (например, `Gender` с возможными значениями `Male` и `Female`).

2. Распишите по функции для каждого поля, которая принимает параметром `std::ostream&` 
   и вписывает в него сериализованное значение поля:

   - Строковое значение вписывается как есть, до нулевого байта.
     Можете предположить ASCII кодировку.

   - Целочисленное значение вписывайте строкой, в десятичной системе счисления.

   - `enum` вписывайте либо как целое число,
     либо как сокращение его имени (например, `Male` -> `M`),
     либо строкой с названием, либо один из этих вариантов по выбору, параметром.
     Решайте сами.

3. Распишите функцию, которая принимает параметром `std::ostream&` 
   и ссылку на ваш объект, и сериализует *весь объект*.

   Сериализуйте каждое поле, используя функции, расписанные ранее.

   Разделите значения полей запятыми.

   > Этот формат называется CSV -- comma separated values

4. Распишите по функции, которая *парсит* каждое поле структуры:

   - Для функции считывающую строку, пускай принимает параметром `std::span` буфера,
     копирует туда строку, и вписывает нулевой байт после.
     Можете сделать чтобы фукнция возвращала `std::array` со строкой вместо игр с указателем.

   - Для функции считывающую целое число, напишите свою функцию конвертирования,
     или импортируйте [`boost::try_lexical_cast`](https://www.boost.org/doc/libs/1_61_0/doc/html/boost_lexical_cast/synopsis.html#boost_lexical_cast.synopsis.try_lexical_convert),
     или используйте `std::stoi`, используя exception handling.
     [Смотри некоторые объяснения](https://stackoverflow.com/a/11599810).

   - Для функции считывающую `enum`, логика будет зависеть от того, какое представление
     вы выбрали для сериализации `enum` в предыдущем задании:

     * Если храните числом, используйте `std::stoi`, проверьте если входит в диапазон значений,
       и переконвертируйте в нужный тип (через `static_cast` или просто C каст).

     * Если сериализуете как строку, можете считать в локальный буфер
       и использовать `std::strcmp` чтобы сравнить с каждым возможным значением.

     * Если храните как символ, считайте как `char`, и сделайте `switch` чтобы выбрать
       нужное значение `enum`. 

5. Распишите функцию, которая принимает параметром `std::istream&`,
   и десериализует *весь объект*, возвращая его, и `true`, если десериализация прошла успешно. 

   Для этого можете определить структуру `DeserializationResult`, или использовать `std::optional`.

   Десериализуйте каждое поле, используя функции, расписанные ранее.

   Ожидайте что значение полей в строке разделены запятыми.

   Если есть лишние запятые, или находите предварительный переход на новую строку
   (то есть до того как успели считать все значения полей),
   возвращайте `false` в результате.

    ```cpp
    struct DeserializationResult
    {
        bool success;
        Person value;
    };

    DeserializationResult deserialize(std::istream& stream)
    {
        Person result;
        // ...
        if (serializationFailed)
        {
            return { false, {} };
        }
        else
        {
            return { true, person };
        }
    }
    ```
   
6. Распишите функцию, которая сериализует `std::span` из объектов вашей структуры,
   который приходит параметром, в `std::ostream&`, который тоже передавайте параметром.

   Сериализуйте каждый объект, используя функцию сериализации, расписанную ранее.

   Разделите объекты переходом на новую строку.

7. Сделайте подобную функцию, которая считывает из заданного параметром `std::iostream&`,
   и десериализует каждую строку в `std::vector`,
   или в переменную типа вашего динамического массива из лабы 4,
   из объектов вашей структуры.

8. Создайте файл, в котором вручную пропишите несколько сериализованных объектов,
   или создайте программу, которая создает такой файл, генерируя данные случайным образом,
   и запустите ее.

9. Создайте программу, которая десериализует данные из этого файла,
   изменяет каким-то образом поля одного из элементов,
   добавляет новый элемент в конец,
   и сериализует все данные обратно в тот же файл,
   перезаписывая все содержимое файла.

   Разрешается чтобы вывод происходил в другой файл, отличный от входного.

   Используйте [fstream](https://cplusplus.com/reference/fstream/fstream/open/) для этого.
   (Можете передавать `fstream` как `ostream&` и `istream&` в ваши функции сериализации и десериализации).

10. Еще одна мелочь: так как значени полей будут разделены запятыми, убедитесь, что строчные поля не включают запятые, чтобы ничего не слетало из-за этого.
    Для этого добавьте проверок строк до сериализации. Можете сигнализировать ошибку возвратом `false` функцией сериализации, или определите `enum class` с возможными ошибками сериализации, и возвращайте значения из этого `enum`-а.

## То же самое, но OOP

Проделайте то же самое, но:

- Определите конструкторы копирования, дефолтный, конструктор перемещения, и оператор присваивания
  для вашего типа.
  Деструктор по идее сойдет и дефолтный.

- Вместо вложенного буфера для строчного типа, используйте `std::string`.

- Переопределите `friend` операторы `<<` и `>>` для вашего типа, 
  чтобы они выполняли операции сериализации и десериализации.

- Используйте `std::vector` как динамический массив.

- Избегайте копирования объектов, передавая их ссылками, где применимо и необходимо.

- Используйте `const` по возможности.
