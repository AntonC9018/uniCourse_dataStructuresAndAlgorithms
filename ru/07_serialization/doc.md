## Domain data models

*Domain data model* - это структура, представляющая какой-то объект из реального мира.
В следующем простом примере структура `Car` представляет объект автомобиля.

```cpp
struct Car
{
    std::string companyName;
    std::string modelName;
    std::string numberplateText;
    int producedYear;
    int numberOfDoors;
};
```

Одна из ключевых идей заключается в том, что у вас может быть несколько переменных этого типа,
чтобы представить данные о разных автомобилях.

```cpp
int main()
{
    Car myCar{
        "Audi", // companyName
        "A4", // modelName
        "MD1515", // numberplateText
        2000, // producedYear
        4, // numberOfDoors
    };

    Car neighborsCar{
        "Toyota",
        "Camry",
        "JK1516",
        2002,
        6,
    };

    return 0;
}
```

## Валидация

Часто нужно будет проверить, являются ли данные в вашем объекте валидными.
Например, мы можем хотеть удостовериться, что `companyName` был указан,
число дверей не отрицательно, и год производства не превышает текущий год.

### Bool

Существует несколько способов в C++, которыми можно представить ошибки.
Очень простой, но тем не менее полезный способ - возвращение `true`, если все в порядке,
и `false` в противном случае.

Проблема этого подхода заключается в том, что он не предоставляет достаточно информации
для диагностики проблемы при ее возникновении.

> [`time_t`](https://en.cppreference.com/w/cpp/chrono/c/time_t)

> [Пример](../../en/07_serialization/validation/bool_example.cpp)

### Сообщение ошибки

Этот недостаток можно покрыть, возвращая строку с сообщением ошибки, или
выводя сообщение в консоль.
Это допустимое решение, если вам не надо, чтобы код использовался в других местах
для нахождения и обработки ошибок программно:
вы сможете помочь пользователю, использующему программу, диагностировать проблему,
посмотрев на вывод программы, но ваши другие функции не смогут
с легкостью определить, что пошло не так,
потому что им придется анализировать сообщение ошибки.

> [Пример](../../en/07_serialization/validation/string_example.cpp)

Этот подход также позволяет записывать несколько ошибок, выводя каждую,
разделенную символом, например, новой строки.

> [Пример](../../en/07_serialization/validation/string_multiline_example.cpp)


### `enum`

Это может быть полезно, когда вы хотите сохранить только тип одной ошибки.
Идея заключается в том, чтобы дать каждой ошибке уникальный номер и возвращать этот номер.

> [Пример](../../en/07_serialization/validation/enum_example.cpp)

### Флаги

`enum` также можно использовать для возврата нескольких ошибок.
Идея заключается в том, что вы будете использовать биты для представления наличия каждого вида ошибок.
Например, мы могли бы сказать, что первый бит представляет отсутствие названия компании,
второй бит представляет отрицательное количество дверей и так далее.
Таким образом, мы можем всунуть несколько ошибок в одно число.
Эти отдельные биты, представляющие наличие чего-то, называются *флагами*.

Пример:
```
000 -- нет ошибки
001 -- отсутствует название компании 
010 -- отрицательное количество дверей
100 -- год производства в будущем
101 -- отсутствует название компании и год производства в будущем
111 -- все ошибки 3 ошибки
```

Основным оператором, который поможет вам определить эти флаги, является `<<`, который можно использовать для сдвига бита в правильное положение.
Например, `1 << 2` даст вам `100` в двоичной системе, то есть число, в котором второй бит установлен.
В общем случае `1 << n` даст вам число, в котором установлен бит `n` (справа).

Далее мы можем использовать оператор `|` (побитовое или), чтобы объединить эти флаги.
Результат `a | b` будет иметь `1` на всех позициях, где они есть в `a` или `b`.

Некоторые примеры:
```
000 | 000 = 000
001 | 000 = 001
001 | 001 = 001
100 | 001 = 101
111 | 000 = 111
```

Имея такое число, чтобы проверить если определенные позиции битов единицы,
может использовать оператор `&` (побитовый и).

`a & b` сразу выставит `0` в результате в каждой позиции, где они `0` в `b`.
Для всех остальных позиций, значение бита скопируется из `a`.

Например, `1010 & 0110`. Сначала, стираем все биты в `a` которые не выставлены (`0`) в `b`.
То есть мы сходу знаем, что результат будет выглядеть как `0__0`,
потому что в `b` эти позиции также `0`.
Теперь, копируем все остальные биты из `a`: `_01_`.
В итоге получаем `0__0` и `_01_`, которые объединяем, получая `0010`.

> Множество флагов, то есть число, где несколько битов, соответствующих
> отдельным флагам выставлены, которое обычно используется для
> проверки, если они выставлены в другом числе, с помощью оператора `&`
> называется *маской*.
> *Применение маски* означает применение оператора `&`,
> выставляя определенные биты на `0`.

```
111 & 100 = 100  -- high bit копирован, остальные скопированы
000 & 100 = 000  -- то же самое
101 & 001 = 001  -- lowest bit скопирован, остальные выставлены на нули
110 & 111 = 110  -- все биты скопированы
```

Учитывайте, что если ни один из установленных битов в `b` не установлен в `a`,
результат будет полностью состоять из нулей.
Следовательно, если хотя бы один из битов из `b` также установлен в `a`,
результат не будет полностью состоять из нулей.
Это означает, что *для проверки наличия некоторых флагов можно использовать `&` и сравнение с нулем*.

Все это объединено в [примере](../../en/07_serialization/validation/enum_flags_example.cpp).


### Tagged union

Это очень распространенная идея, особенно в C.
Идея заключается в том, чтобы возвращать значение `enum` ошибок с дополнительными данными.
Мы можем сохранить некоторые вычисленные данные в ошибке, например,
номера строки и столбца, если ошибка произошла при чтении файла,
или мы можем сохранить фактическое значение, вызвавшее ошибку, и ожидаемое значение.

Поскольку в любой момент времени возможен только один вид ошибки,
мы можем сохранить дополнительный payload для всевозможных типов ошибок в одной и той же памяти.
Мы можем сделать это, используя `union`.

При использовании `union`, однако, нужно быть очень осторожным, чтобы не читать из неверного поля.
Чтение из поля неверного типа считается неопределенным поведением!

> [Пример](../../en/07_serialization/validation/tagged_union_example.cpp)

Вы можете изменить функцию валидации так, чтобы она принимала `std::vector` ошибок,
добавляла все записанные ошибки туда, а затем проходила по ним
на приемной стороне, чтобы обработать все ошибки.
Такой подход также обобщается на несколько ошибок.

Также обратите внимание, что `union` нельзя использовать 
с нетривиальными типами, такими как `std::string`.

Помеченные объединения очень гибкие,
но, применяя их в сыром виде, очень просто совершить ошибку.
Вы можете легко крашнуть программу, обратившись к неверному полю.
Обычно рекомендуется обернуть объединение в класс,
получать доступ к полезной нагрузке для правильного вида ошибки через метод получения,
где вы будете использовать `assert`, чтобы убедиться, что тип ошибки тот, что вы ожидаете.
Это для того, чтобы обнаружить чтение из неверного поля немедленно,
а не позже в программе, когда уже не очевидно,
в чем была причина неожиданного поведения.

Упрощенный пример выглядит так:

```cpp
enum class ResultKind
{
    Valid,
    ErrorA,
    ErrorB,
};

struct PayloadErrorB
{
    size_t b1;
    size_t b2;
};

class Result
{
    ResultKind _kind;
    union {
        int _payloadErrorA;
        PayloadErrorB _payloadErrorB;
    };

public:
    static Result createValid() 
    { 
        return { ResultKind::Valid }; 
    }

    static Result createErrorA(int payload) 
    { 
        Result result;
        result._kind = ResultKind::ErrorA;
        result._payloadErrorA = payload;
        return result;
    }

    static Result createErrorB(PayloadErrorB payload) 
    { 
        Result result;
        result._kind = ResultKind::ErrorB;
        result._payloadErrorB = payload;
        return result;
    }

    ResultKind kind() const 
    { 
        return _kind; 
    }

    int& payloadErrorA()
    { 
        assert(_kind == ResultKind::ErrorA);
        return _payloadErrorA; 
    }

    PayloadErrorB& payloadErrorB()
    { 
        assert(_kind == ResultKind::ErrorB);
        return _payloadErrorB; 
    }
};
```

Существуют также библиотеки, предлагающие более общие реализации помеченных объединений,
которые могут работать с любыми типами полезной нагрузки, см. например
[`boost::variant`](https://www.boost.org/doc/libs/1_78_0/doc/html/variant.html) или
[`std::variant`](https://en.cppreference.com/w/cpp/utility/variant).

### Исключения (exceptions)

Это очень сложная система, изначально разработанная для возможности обработки ошибок,
возникающих в конструкторах, где вы не можете использовать другие подходы,
потому что конструкторы - это void-функции.
Я не буду углубляться в то, как они работают, я упомяну только о том, как использовать API,
которые сигнализирует об ошибках через исключения.

> Смотрите [очень длинное и подробное видео](https://www.youtube.com/watch?v=HXJmrMnnDYQ) о случаях использования исключений.

Вы можете рассматривать функцию, использующую исключения для возврата ошибок,
как принуждающую вас обработать ошибку, иначе ваша программа выйдет крашнется.
В предыдущих подходях, ошибка рассматривается как обычное возвращаемое значение,
и может быть полностью проигнорирована без последствий
(хотя не проверка ее вероятно является логической ошибкой),
но это ограничение языка.

Например, рассмотрим функцию `std::stoi`, которая преобразует строку в целое число.
Она *генерирует* исключение `std::invalid_argument`, если строка не является числом,
и `std::out_of_range`, если число не влезает в 32 битах `int`.
Смотрите пример кода [здесь](../../en/07_serialization/validation/exception_example.cpp).

Вы можете попробовать удалить один из блоков `catch` и вызвать это исключение