## Domain data models

*Domain data model* - это структура, представляющая какой-то объект из реального мира.
В следующем простом примере структура `Car` представляет объект автомобиля.

```cpp
struct Car
{
    std::string companyName;
    std::string modelName;
    std::string numberplateText;
    int producedYear;
    int numberOfDoors;
};
```

Одна из ключевых идей заключается в том, что у вас может быть несколько переменных этого типа,
чтобы представить данные о разных автомобилях.

```cpp
int main()
{
    Car myCar{
        "Audi", // companyName
        "A4", // modelName
        "MD1515", // numberplateText
        2000, // producedYear
        4, // numberOfDoors
    };

    Car neighborsCar{
        "Toyota",
        "Camry",
        "JK1516",
        2002,
        6,
    };

    return 0;
}
```

## Валидация

Часто нужно будет проверить, являются ли данные в вашем объекте валидными.
Например, мы можем хотеть удостовериться, что `companyName` был указан,
число дверей не отрицательно, и год производства не превышает текущий год.

### Bool

Существует несколько способов в C++, которыми можно представить ошибки.
Очень простой, но тем не менее полезный способ - возвращение `true`, если все в порядке,
и `false` в противном случае.

Проблема этого подхода заключается в том, что он не предоставляет достаточно информации
для диагностики проблемы при ее возникновении.

> [`time_t`](https://en.cppreference.com/w/cpp/chrono/c/time_t)

> [Пример](../../en/07_serialization/validation/01_bool_example.cpp)

### Сообщение ошибки

Этот недостаток можно покрыть, возвращая строку с сообщением ошибки, или
выводя сообщение в консоль.
Это допустимое решение, если вам не надо, чтобы код использовался в других местах
для нахождения и обработки ошибок программно:
вы сможете помочь пользователю, использующему программу, диагностировать проблему,
посмотрев на вывод программы, но ваши другие функции не смогут
с легкостью определить, что пошло не так,
потому что им придется анализировать сообщение ошибки.

> [Пример](../../en/07_serialization/validation/02_string_example.cpp)

Этот подход также позволяет записывать несколько ошибок, выводя каждую,
разделенную символом, например, новой строки.

> [Пример](../../en/07_serialization/validation/03_string_multiline_example.cpp)


### `enum`

Это может быть полезно, когда вы хотите сохранить только тип одной ошибки.
Идея заключается в том, чтобы дать каждой ошибке уникальный номер и возвращать этот номер.

> [Пример](../../en/07_serialization/validation/04_enum_example.cpp)

### Флаги

`enum` также можно использовать для возврата нескольких ошибок.
Идея заключается в том, что вы будете использовать биты для представления наличия каждого вида ошибок.
Например, мы могли бы сказать, что первый бит представляет отсутствие названия компании,
второй бит представляет отрицательное количество дверей и так далее.
Таким образом, мы можем всунуть несколько ошибок в одно число.
Эти отдельные биты, представляющие наличие чего-то, называются *флагами*.

Пример:
```
000 -- нет ошибки
001 -- отсутствует название компании 
010 -- отрицательное количество дверей
100 -- год производства в будущем
101 -- отсутствует название компании и год производства в будущем
111 -- все ошибки 3 ошибки
```

Основным оператором, который поможет вам определить эти флаги, является `<<`, который можно использовать для сдвига бита в правильное положение.
Например, `1 << 2` даст вам `100` в двоичной системе, то есть число, в котором второй бит установлен.
В общем случае `1 << n` даст вам число, в котором установлен бит `n` (справа).

Далее мы можем использовать оператор `|` (побитовое или), чтобы объединить эти флаги.
Результат `a | b` будет иметь `1` на всех позициях, где они есть в `a` или `b`.

Некоторые примеры:
```
000 | 000 = 000
001 | 000 = 001
001 | 001 = 001
100 | 001 = 101
111 | 000 = 111
```

Имея такое число, чтобы проверить если определенные позиции битов единицы,
может использовать оператор `&` (побитовый и).

`a & b` сразу выставит `0` в результате в каждой позиции, где они `0` в `b`.
Для всех остальных позиций, значение бита скопируется из `a`.

Например, `1010 & 0110`. Сначала, стираем все биты в `a` которые не выставлены (`0`) в `b`.
То есть мы сходу знаем, что результат будет выглядеть как `0__0`,
потому что в `b` эти позиции также `0`.
Теперь, копируем все остальные биты из `a`: `_01_`.
В итоге получаем `0__0` и `_01_`, которые объединяем, получая `0010`.

> Множество флагов, то есть число, где несколько битов, соответствующих
> отдельным флагам выставлены, которое обычно используется для
> проверки, если они выставлены в другом числе, с помощью оператора `&`
> называется *маской*.
> *Применение маски* означает применение оператора `&`,
> выставляя определенные биты на `0`.

```
111 & 100 = 100  -- high bit копирован, остальные скопированы
000 & 100 = 000  -- то же самое
101 & 001 = 001  -- lowest bit скопирован, остальные выставлены на нули
110 & 111 = 110  -- все биты скопированы
```

Учитывайте, что если ни один из установленных битов в `b` не установлен в `a`,
результат будет полностью состоять из нулей.
Следовательно, если хотя бы один из битов из `b` также установлен в `a`,
результат не будет полностью состоять из нулей.
Это означает, что *для проверки наличия некоторых флагов можно использовать `&` и сравнение с нулем*.

Все это объединено в [примере](../../en/07_serialization/validation/05_enum_flags_example.cpp).


### Tagged union

Это очень распространенная идея, особенно в C.
Идея заключается в том, чтобы возвращать значение `enum` ошибок с дополнительными данными.
Мы можем сохранить некоторые вычисленные данные в ошибке, например,
номера строки и столбца, если ошибка произошла при чтении файла,
или мы можем сохранить фактическое значение, вызвавшее ошибку, и ожидаемое значение.

Поскольку в любой момент времени возможен только один вид ошибки,
мы можем сохранить дополнительный payload для всевозможных типов ошибок в одной и той же памяти.
Мы можем сделать это, используя `union`.

При использовании `union`, однако, нужно быть очень осторожным, чтобы не читать из неверного поля.
Чтение из поля неверного типа считается неопределенным поведением!

> [Пример](../../en/07_serialization/validation/06_tagged_union_example.cpp)

Вы можете изменить функцию валидации так, чтобы она принимала `std::vector` ошибок,
добавляла все записанные ошибки туда, а затем проходила по ним
на приемной стороне, чтобы обработать все ошибки.
Такой подход также обобщается на несколько ошибок.

Также обратите внимание, что `union` нельзя использовать 
с нетривиальными типами, такими как `std::string`.

Помеченные объединения очень гибкие,
но, применяя их в сыром виде, очень просто совершить ошибку.
Вы можете легко крашнуть программу, обратившись к неверному полю.
Обычно рекомендуется обернуть объединение в класс,
получать доступ к полезной нагрузке для правильного вида ошибки через метод получения,
где вы будете использовать `assert`, чтобы убедиться, что тип ошибки тот, что вы ожидаете.
Это для того, чтобы обнаружить чтение из неверного поля немедленно,
а не позже в программе, когда уже не очевидно,
в чем была причина неожиданного поведения.

Упрощенный пример выглядит так:

```cpp
enum class ResultKind
{
    Valid,
    ErrorA,
    ErrorB,
};

struct PayloadErrorB
{
    size_t b1;
    size_t b2;
};

class Result
{
    ResultKind _kind;
    union {
        int _payloadErrorA;
        PayloadErrorB _payloadErrorB;
    };

public:
    static Result createValid() 
    { 
        return { ResultKind::Valid }; 
    }

    static Result createErrorA(int payload) 
    { 
        Result result;
        result._kind = ResultKind::ErrorA;
        result._payloadErrorA = payload;
        return result;
    }

    static Result createErrorB(PayloadErrorB payload) 
    { 
        Result result;
        result._kind = ResultKind::ErrorB;
        result._payloadErrorB = payload;
        return result;
    }

    ResultKind kind() const 
    { 
        return _kind; 
    }

    int& payloadErrorA()
    { 
        assert(_kind == ResultKind::ErrorA);
        return _payloadErrorA; 
    }

    PayloadErrorB& payloadErrorB()
    { 
        assert(_kind == ResultKind::ErrorB);
        return _payloadErrorB; 
    }
};
```

Существуют также библиотеки, предлагающие более общие реализации помеченных объединений,
которые могут работать с любыми типами полезной нагрузки, см. например
[`boost::variant`](https://www.boost.org/doc/libs/1_78_0/doc/html/variant.html) или
[`std::variant`](https://en.cppreference.com/w/cpp/utility/variant).

### Исключения (exceptions)

Это очень сложная система, изначально разработанная для возможности обработки ошибок,
возникающих в конструкторах, где вы не можете использовать другие подходы,
потому что конструкторы - это void-функции.
Я не буду углубляться в то, как они работают, я упомяну только о том, как использовать API,
которые сигнализирует об ошибках через исключения.

> Смотрите [очень длинное и подробное видео](https://www.youtube.com/watch?v=HXJmrMnnDYQ) о случаях использования исключений.

Вы можете рассматривать функцию, использующую исключения для возврата ошибок,
как принуждающую вас обработать ошибку, иначе ваша программа выйдет крашнется.
В предыдущих подходях, ошибка рассматривается как обычное возвращаемое значение,
и может быть полностью проигнорирована без последствий
(хотя не проверка ее вероятно является логической ошибкой),
но это ограничение языка.

Например, рассмотрим функцию `std::stoi`, которая преобразует строку в целое число.
Она *генерирует* исключение `std::invalid_argument`, если строка не является числом,
и `std::out_of_range`, если число не влезает в 32 битах `int`.
Смотрите пример кода [здесь](../../en/07_serialization/validation/07_exception_usage_example.cpp).

Вы можете попробовать удалить один из блоков `catch` и вызвать это исключение.

### Мои рекомендации

Как правило, стоит избегать использования исключений в своем собственном коде,
если вы не находитесь в роли их приемника,
то есть можно их обрабатывать, но не бросайте их в своем коде.
Решите проблему, используя один из подходящих альтернативных методов.

Не заморачивайтесь с tagged unions, если вам действительно не нужна дополнительная информация.
Если она вам нужна, tagged unions - это мой первый выбор.

### В итоге:

- `bool` -- Мне не важно, какова фактическая ошибка, просто скажите мне, есть ли ошибка;

- Строка -- Я хочу показать ошибку юзеру, но мне не важна ошибка программно;

- `enum` -- Я хочу знать, какого рода ошибка, но мне не нужны дополнительные данные; 

- Флаги -- Я хочу иметь возможность закодировать несколько ошибок сразу;

- Tagged union -- Я хочу знать вид ошибки и также сохранить некоторую полезную нагрузку;

- Исключения -- Я ленив и мне все равно **ИЛИ** 
  Я тщательно изучил и понял, как это реализовано 
  (не только синтаксис, но и фактическая механика),
  посмотрел видео, объясняющее случаи использования,
  и я намеренно хочу использовать исключения, потому что это соответствует моей задаче.


## Работа со стримами (stream)

Честно говоря, стримы - это очень удобная абстракция.

### Что такое стрим?

*Входной стрим* (input stream) - это объект, из которого можно считывать данные.
*Выходной стрим* (output stream) - это объект, в который можно записывать данные.

Например, `std::cout` - это выходной стрим.
Когда вы записываете данные в него, они копируются в стандартный вывод (консоль).

```cpp
// Помещаем данные в выходной стрим
std::cout << "Hello";
```

Аналогично, `std::cin` - это входной стрим.

```cpp
std::string x;
std::cin >> x;
```

`std::cout` и `std::cin` - это глобальные переменные, доступные в каждой программе.
Тип этих переменных - `std::ostream` и `std::istream` соответственно (o -- output, i -- input).

### Файловые стримы

Вы также можете создавать стримы для чтения из файлов и записи в файлы.
Это можно сделать с использованием `std::fstream` (файловый стрим, как для ввода, так и для вывода),
`std::istream` (стрим для ввода, только для чтения) или `std::ostream` (стрим для вывода, только для записи).
Они используют RAII для закрытия дескриптора в конце области видимости переменной.

```cpp
#include <fstream>

int main()
{
    std::ifstream inputFile;
    std::ofstream outputFile;
    inputFile.open("input.txt");
    outputFile.open("output.txt");

    // Копируем содержимое файла.
    // `rdbuf` создает буферизованный читатель.
    outputFile << inputFile.rdbuf();

    // И еще немного.
    outputFile << std::endl;
    outputFile << "Привет";

    return 0;
}
```

Есть еще методы для перемещения к определенной позиции (`seekg`),
чтения одного байта за раз (`get` / `peek`), копирования в локальный буфер (`read`), и так далее.
Есть аналогичные методы и для записи.

Я не буду описывать их все, попробуйте поэкспериментировать с ними и искать в Google то, что вам нужно.

### Проверка в потоках

Найдите ошибку в следующем коде.

```cpp
int a;
std::cin >> a;
```

Ошибкой является то, что он не проверяет, удалась ли конвертация или нет.
Потоки используют подход с булевым значением для этого, но вместо возврата `true` или `false`,
они устанавливают флаг на объекте. 
Вы можете проверить эти флаги, вызвав один из
[соответствующих методов](https://cplusplus.com/reference/ios/ios/good/).

```cpp
int a;
std::cin >> a;

// Это набор флагов, но вы можете использовать
// вспомогательные методы для проверки конкретных флагов.
// std::ios_base::iostate state = std::cin.rdstate();

// Проверяет флаг goodbit в rdstate().
if (std::cin.good())
{
    // Конвертация прошла успешно.
}
else
{
    // Конвертация не удалась.
}

```

Флаги также содержат информацию о том, достигнут ли конец файла.

```cpp
// Проверяет флаг eofbit (End Of File).
if (std::cin.eof())
{
    // Достигнут конец файла.
}
```

## Сериализация

*Сериализация* означает преобразование объекта в памяти в представление, 
которое можно сохранить в текстовом файле или в двоичном файле.
*Десериализация* означает преобразование из этого файла обратно в объект в памяти.

Например, если у нас есть объект, подобный следующему:

```cpp
struct Car
{
    std::string companyName;
    std::string modelName;
    std::string numberplateText;
    int producedYear;
    int numberOfDoors;
};

// ...

Car myCar{
    "Audi", // companyName
    "A4", // modelName
    "MD1515", // numberplateText
    2000, // producedYear
    4, // numberOfDoors
};
```

Мы могли бы представить его в текстовом файле так:

```
Audi
A4
MD1515
2000
4
```

Или так:

```
companyName: Audi
modelName: A4
numberplateText: MD1515
producedYear: 2000
numberOfDoors: 4
```

Или так:

```
Audi|A4|MD1515|2000|4
```

Идея в том, что *вы* выбираете, как вы будете его представлять в файле.
Правила того, как вы сохраняете это в текстовом файле, называются *формат сериализации*.
Самые популярные для плоских данных - это CSV, 
а для структурированных данных (вложенные объекты) JSON и XML.

В фазе десериализации вы читаете эту строку и преобразуете ее в ваш объект.
Таким образом, в функцию входит строка (или поток), а выходит объект.

```cpp
#include <iostream>
#include <string>

// std::optional<Car> по сути { Car value; bool isValid; }
std::optional<Car> deserializeCar(std::istream& stream)
{
    Car car;

    // Считываем первую строку в car.companyName
    std::getline(stream, car.companyName);
    if (!stream.good())
        return std::nullopt;
    
    // ...

    return car;
}
```