## Ссылки (\&)

Ссылка - это по сути указатель, адрес которого
не может быть изменен, и имеет упрощенный синтаксис.

Вы также можете считать его псевдонимом для переменной (адреса в памяти).

```cpp
int main()
{
    int a = 5;
    
    int* pointer = &a;
    int& reference = a;
    
    *pointer = 10; // a = 10
    reference = 15; // a = 15
    
    int b = 20;
    // Нельзя перенаправить `reference` на `b`.
    // Следующий код запишет значение `b` (20) в `a`.
    reference = b; // a = 20
    reference = 10; // a = 10
    
    return 0;
}
```

Ссылки можно передавать в функции.
Они скрытно передадутся как указатели.

```cpp
void foo(int& a)
{
    a = 10;
    a = a + 5;
}

int main()
{
    int a = 5;
    foo(a); // a = 15
    return 0;
}
```

Та же программа, но с использованием указателя:

```cpp
void foo(int* a)
{
    *a = 10;
    *a = *a + 5;
}

int main()
{
    int a = 5;
    foo(&a); // a = 15
    return 0;
}
```

Вы можете применить `&` к ссылке, чтобы получить указатель на переменную.

Ссылка - это более ограниченная версия указателя, отлично подходящая для аргументов функций.
Считается хорошей практикой использовать ссылки вместо указателей при передаче аргументов в функции.


## Методы

Рассмотрим функцию, которая принимает переменную структуры.

> Не беспокойтесь о том, как работает `std::string` пока,
> просто концептуально думайте о ней как о строке.

```cpp
#include <iostream>

struct Person
{
    int age;
    std::string name;
};

void printAge(Person* person)
{
    std::cout << person->age;
}

int main()
{
    Person person;
    person.age = 20;
    person.name = "Джон";
    
    printAge(&person);
    
    return 0;
}
```

### `static` методы

Мы можем преобразовать эту функцию в метод объекта, также называемый методом.
Давайте сначала сделаем его статическим методом, чтобы увидеть, как работает концепция *пространств имен* (namespace).

> Обратите внимание, что методы существуют только в C++ и не в C.

> *Член* означает что-то, объявленное в `struct` или `class`.
> Это может быть как метод, так и поле.

```cpp
#include <iostream>

struct Person
{
    int age;
    std::string name;
    
    // Ключевое слово `static` на самом деле не делает его статическим,
    // оно просто требует вызывать эту функцию с использованием оператора разрешения области видимости (::).
    static void printAge(Person* person)
    {
        std::cout << person->age;
    }
};

int main()
{
    Person person;
    person.age = 20;
    person.name = "Джон";
    
    // Вот как вызывать статический метод объекта.
    // `Person` здесь пространство имен, а `printAge` - метод.
    // Идея заключается в том, что мы способны ассоциировать операции,
    // выполняемые с объектом `Person`, с пространством имен `Person` этой структуры.
    Person::printAge(&person);
    
    return 0;
}
```

Вы можете разделить объявление от определения, так же, как и с обычными функциями.
Обратите внимание, что нет другого синтаксиса для этого, 
вам придется указать имя структуры в определении.

```cpp
struct Person
{
    int age;
    std::string name;
    
    static void printAge(Person* person);
};

// Можете считать `Person::printAge` именем этой функции.
static void Person::printAge(Person* person)
{
    std::cout << person->age;
}
```

### Экземпляры и объекты

*Экземпляр* (instance) означает память переменной какого-то типа.
Так что в следующем коде:

```cpp
Person person;
```

мы можем сказать, что `person` - это экземпляр типа `Person`.


*Объект* (object) означает значение экземпляра (копия того что содержится в памяти) какого-то типа.
Так что мы можем сказать, что `person` содержит объект типа `Person`.


### Не статические (instance) методы

Теперь давайте сделаем его методом объекта, который не является статическим.
Метод объекта без статического характера имеет более простой синтаксис вызова,
и автоматически передает указатель на экземпляр как первый скрытый параметр с именем `this`.

```cpp
struct Person
{
    int age;
    std::string name;
    
    // Метод объекта.
    void printAge()
    {
        // `this` - это указатель на экземпляр (`Person*`).
        std::cout << this->age;
    }
};

int main()
{
    Person person;
    person.age = 20;
    person.name = "John";
    
    // Вот как вызывать метод объекта.
    // Компилятор автоматически передает указатель на экземпляр как первый параметр.
    person.printAge();
    
    return 0;
}
```

Это позволяет нам объединить функциональность с типом данных
и получить семантику "объект.глагол".


> `this->` можно не указывать.

```cpp
struct Person
{
    // ...
    void printAge()
    {
        // `age` ссылается на `this->age`.
        std::cout << age;
    }
};
```
Вы можете разделить определение от объявления так же, как с методами объекта.


## Доступность (accessibility) и `class`

По умолчанию, все члены структуры являются `public`.
Это означает, что они могут быть доступны в экземпляре структуры.
Вы можете сделать их явно `private`, чтобы запретить доступ.

Сначала это может показаться абсолютно бесполезным. 
В чем смысл запрета доступа к некоторой памяти?
Одна из идей заключается в том, чтобы ограничить способы доступа
и изменения данных, чтобы стало очевидным, какой из них является правильным, используя методы.

Это не что-то уникальное для ООП, вы можете делать это на уровне модуля, объявляя некоторые функции `static`
(видимые только внутри компиляционной единицы, в которой они были определены).
Однако *модификаторы доступности* являются исключительно ООП фичей.

```cpp
struct Person
{
private:
    int age;
    std::string name;

public:
    void setAge(int age)
    {
        this->age = age;
    }

    void printAge()
    {
        std::cout << this->age;
    }

    void printName()
    {
        std::cout << this->name;
    }
};

int main()
{
    Person person;
    person.age = 15; // ошибка компиляции: невозможно получить доступ к закрытому полю.
    person.name = "John"; // та же ошибка

    person.setAge(15); // компилируется
    person.printAge(); // компилируется
    person.printName(); // компилируется

    return 0;
}
```

Вы можете сделать некоторые поля `private`, а другие - `public`.

```cpp
struct Person
{
private:
    int age;

public:
    std::string name;
}

int main()
{
    Person person;
    person.age = 10; // ошибка компиляции: невозможно получить доступ к закрытому полю.
    person.name = "John"; // работает
    return 0;
}
```


### `class`

`class` эквивалентен `struct`, единственное различие
заключается в том, что у него есть неявное `private:` в начале.
Таким образом, все члены по умолчанию являются публичными в `struct`, но приватными в `class`.

> `class` - это ключевое слово, которое обычно используется в контексте ООП.
> Считается хорошим тоном использовать `class` вместо `struct`, если вы объявляете методы,
> которые инкапсулируют (предоставляют конкретные способы доступа) данные (поля).

```cpp
struct Person
{
private:
    int age;
    std::string name;
}

// эквивалентно

class Person
{
    int age;
    std::string name;
}

// и наоборот ...

class Person
{
public:
    int age;
    std::string name;
}

// эквивалентно

struct Person
{
    int age;
    std::string name;
}
```

## Области видимости (scope)

В C++ области видимости выполняют две функции:
- Они служат для того, чтобы переменные не были видны за их пределами;
- Они используются для очистки памяти ("ресурсов") объектов.
  Это можно сделать с помощью деструкторов.

Можно сказать, что области видимости позволяют вам контролировать время жизни объектов.

### Области видимости для ограничения видимости

Области видимости создаются с использованием `{ ... }`.

```cpp
int main()
{
    int a = 1;

    {
        int b = 2;
        a = 5; // разрешено, `a` видна во внешней области видимости
        b = 10; // разрешено, `b` видна в текущей области видимости
    }

    b = 10; // не разрешено, `b` не видна, потому что ее область видимости завершилась 
            // (фигурная скобка была закрыта).

    a = 15; // все еще разрешено, потому что она видна в текущей области видимости

    return 0;
}
```

Функции должны определять область видимости для своего тела.


Вы можете переопределять переменные с тем же именем, если они находятся в разных областях видимости.
Не гарантируется, что они окажутся указывать на одну и ту же память.

```cpp
int main()
{
    int a = 5;

    // Повторное объявление переменной в той же области видимости не разрешено.
    // int a;

    {
        // Повторное объявление здесь также не разрешено.
        // int a;

        int b = 10;
    }

    {
        // Это разрешено, потому что области видимости не взаимодействуют.
        int b = 20;

        {
            // Это было бы запрещено.
            // int b = 30;
        }
    }

    return 0;
}
```

Область видимости внутри другой области видимости называется *вложенной областью видимости*.
Вы можете *вкладывать* области видимости неограниченное количество раз.

> В целом, помещение одних вещей внутри других вещей того же вида называется *вложением* (nesting).

Существует также концепция глобальной области видимости,
которая представляет собой область видимости, находящуюся вне любой функции.


### Области видимости для очистки ресурсов

Концептуально переменная, объявленная в области видимости, уничтожается в конце области видимости.
Для простых типов, таких как `int`, это в буквальном смысле ничего не означает.
Для сложного типа, такого как `std::string`, это означает
возвращение памяти, выделенной для массива символов, C++ рантайму.


### Деструктор (destructor)

Вы можете определить свою собственную логику, которая будет вызываться при уничтожении вашего объекта с помощью *деструктора*.
Деструктор - это специальная `void` функция, которая автоматически вызывается в этом контексте.
Вы также можете вызывать его вручную.

Давайте просто покажем, как это работает.

```cpp
#include <iostream>

struct Demo
{
    int i;

    // Это деструктор
    ~Demo()
    {
        std::cout << "Destroying demo " << this->i << std::endl;
    }
};

int main()
{
    Demo demo1{1};
    Demo demo2{2};
    std::cout << "Demos created" << std::endl;

    return 0;

    // Компилятор неявно добавляет следующее:
    // `demo2.~Demo();`
    // `demo1.~Demo();`
}
```

Что выводит:

```
Demos created
Destroying demo 2
Destroying demo 1
```

> Вы можете разделять объявление деструктора и его определение
> так же, как и с обычными методами.

Обратите внимание, что деструктор будет вызван только в этом контексте.
Если вы перезначите переменную, он не будет вызван для объекта, уже находящегося в этой памяти.

```cpp
int main()
{
    Demo demo1{1};
    Demo demo2{2};
    demo2 = demo1; // Это копирует байты объекта, но не вызывает деструктор `demo2`.

    return 0;

    // `demo2.~Demo()` выполняется, выводя "Уничтожение демо 1"
    // `demo1.~Demo()` выполняется, выводя "Уничтожение демо 1"
}
```

> Чтобы убедиться, что один и тот же объект не удаляется более одного раза
> в этой ситуации, нам придется перегрузить оператор присваивания.


### Неявные деструкторы (implicit destructors)

Предположим, у вас есть структура с полем, тип которого имеет деструктор.

```cpp
#include <iostream>

struct Test
{
    ~Test()
    {
        std::cout << "Test destroyed" << std::endl;
    }
};

struct Person
{
    Test test;
};

int main()
{
    Person person;
    person.test = {};
    return 0;

    // Компилятор автоматически вызывает деструктор для каждого поля.
    // `person.test.~Test();`

    // Он также удалит временный объект, используемый для присваивания,
    // но это объясняется более подробно позже.
}
```

## Конструкторы (Constructors)

Конструкторы - это специальные `void` функции, используемые для инициализации объектов.
Конструкторы не могут быть вызваны в каком бы то ни было другом контексте.

Конструкторы были созданы для инициализации приватных данных (полей) в ООП.
Конструкторы могут быть более сложными, но, как правило, не рекомендуется делать их сложными.

### Конструкторы, используемые для инициализации новых объектов

> Если они начинают выходить из-под контроля в плане сложности,
> вы можете перейти к использованию фабричных функций.

Например, давайте определим конструктор без параметров (конструктор по умолчанию),
который выводит информацию на консоль.

```cpp
#include <iostream>

class Demo
{
    int memory;

public:
    Demo()
    {
        // memory будет не инициализирована на этом этапе (содержать мусор).
        std::cout << "Создан " << this->memory << std::endl;
        this->memory = 5;
    }

    ~Demo()
    {
        // memory равна 5 на этом этапе.
        std::cout << "Destroyed " << this->memory << std::endl;
    }
};

int main()
{
    {
        // Это фактически вызывает конструктор без параметров.
        // Дизайнеры C++ решили, что объекты никогда не должны оставаться неинициализированными.
        Demo demo;

        // Компилятор неявно добавил:
        // demo.~Demo();
    }

    {
        // Явно вызывает конструктор без параметров.
        Demo demo{};

        // Эквивалентный синтаксис:
        // Demo demo = Demo();

        // Компилятор неявно добавил:
        // demo.~Demo();
    }

    return 0;
}
```

Практическим использованием может быть, например, выделение памяти и очистка ее в деструкторе.
Мы можем сделать это, используя операторы `new` и `delete`.

```cpp
#include <iostream>
#include <assert.h>

class Buffer
{
// private:
    size_t length;
    int* firstElement;

public:
    Buffer(size_t elementCount) 
        // Вписывает `elementCount` в `length` напрямую, до того, как наш код будет запущен.
        // Это называется инициализатором членов.
        : length(elementCount) //, anotherField(8)
    {
        // `firstElement` содержит мусор здесь.

        // Нам нужно выделить память, которая не будет читаемой в инициализаторе.
        // Поэтому я решил написать это в теле конструктора.
        this->firstElement = new int[elementCount];

        // Элементы изначально не инициализированы.
    }

    ~Buffer()
    {
        delete[] firstElement;
    }

    int& elementAt(size_t index)
    {
        assert(index < this->length);
        return firstElement[index];
    }
};

int main()
{
    Buffer buffer{5};

    // Печатает мусор.
    std::cout << buffer.elementAt(0) << std::endl;

    // Do some stuff with the buffer.
    // Выполняем некоторые действия с буфером.
    int& secondElement = buffer.elementAt(1);
    secondElement = 10;

    return 0;

    // Компилятор неявно добавил следующее:
    // buffer.~Buffer();
}
```

### Как легко сломать код выше

Все равно очень легко сломать код выше и получить утечку памяти или повторные удаления памяти:

```cpp
int main()
{
    Buffer buffer1{10};
    Buffer buffer2{20};
    // Это делает копирование по полям.
    buffer2 = buffer1;
    return 0;

    // buffer длиной 20 никогда не освобождается
    // buffer длиной 10 удаляется дважды (ошибка во время выполнения)
}
```

### Конструкторы копирования (copy constructor)

Вы можете определить конструктор, который принимает ссылку на объект,
который будет вызван при копировании.
Это включает в себя обычные определения с использованием `{ }` или определения с немедленным присваиванием.

```cpp
#include <iostream>

class Demo
{
    int id;

public:
    // Необходим конструктор с параметрами, чтобы вообще создать объект.
    Demo(int idParameter) : id(idParameter) { }

    // Demo(const Demo& other)
    Demo(Demo& other) : id(other.id)
    {
        std::cout << "Copying " << other.id << std::endl;
    }
};

int main()
{
    Demo a{1};

    // Вызывает конструктор копирования.
    Demo b{a};

    // Также вызывает конструктор копирования.
    Demo c = a;

    // Это НЕ вызывает конструктор копирования.
    // Он просто копирует поля.
    b = c; 
}
```

### Перемещение объекта (move semantics)

Перемещение объекта в другой объект позволяет одному объекту украсть ресурсы другого.
Это часто используется при создании объектов
или записи значений в поля, чтобы избежать вызова конструктора копирования.

Рассмотрим следующий пример, который создает 2 копии `std::string`:

```cpp
struct Person
{
    std::string name;
};

int main()
{
    // Вызывает конструктор `std::string`, который копирует символы в динамически выделенный буфер.
    std::string name = "John Brown";

    Person person;

    // Выделяет копию `name`, выделяя другой буфер и копируя символы.
    // Затем он записывает эту копию в `person.name`.
    person.name = name;

    return 0;

    // The compiler implicitly adds the following:
    // Компилятор неявно добавляет следующее:
    // `person.name~string();` (из неявного деструктора Person, который удаляет все поля)
    // `name.~string();`
}
```

Итак, мы перемещаем `name` в `person.name`, а не копируем его.
В данном случае это означает, по сути, копирование объекта строки в `person.name`,
а затем его очистку из переменной `name`, чтобы она больше не ссылается на буфер.
Таким образом, она становится непригодной к использованию после этого вызова.

```cpp
#include <iostream>

struct Person
{
    std::string name;
};

int main()
{
    std::string name = "John Brown";
    Person person;

    std::cout << name << std::endl; // John Brown
    std::cout << person.name << std::endl; // 

    person.name = std::move(name);

    std::cout << name << std::endl; // 
    std::cout << person.name << std::endl; // John Brown

    return 0;
}
```

### Конструкторы перемещения (move constructors)

В общем случае вы можете определить конструкторы, принимающие *rvalue-ссылки* (\&\&, rvalue-reference).
Это означает ссылка, из которой нужно красть ресурсы.

> Не зацикливайтесь на деталях, я объясню, что такое rvalue-ссылки позже.

> Вы можете использовать rvalue-ссылки как обычные параметры тоже.

```cpp
#include <iostream>

class Demo
{
    int* memoryPointer;

    int getValue()
    {
        if (memoryPointer == nullptr)
            return 0;
        return *memoryPointer;
    }

public:
    Demo(int value)
    {
        // Выделяет int на куче (просто для демонстрации, я знаю, что это бессмысленно),
        // и сохраняет указатель на него в `memoryPointer`.
        this->memoryPointer = new int{value};
    }

    ~Demo()
    {
        std::cout << "Destructor called for " << this->getValue() << std::endl;
        // Освобождает память (удаление nullptr разрешено).
        delete this->memoryPointer;
    }

    // Конструктор перемещения
    Demo(Demo&& other)
    {
        std::cout 
            << "Move constructor called for "
            << other.getValue()
            << std::endl;

        // Крадем указатель из другого объекта.
        this->memoryPointer = other.memoryPointer;

        // Очищаем указатель из другого объекта.
        // `nullptr` то же самое, что и `0`, он просто обнуляет его.
        other.memoryPointer = nullptr;
    }
};

int main()
{
    Demo demo1{1};
    Demo demo2{2};

    // Это вызывает конструктор перемещения.
    Demo demo3 = std::move(demo1);

    return 0;

    // Компилятор неявно добавляет следующее:
    // demo3.~Demo(); (очищает память с 1)
    // demo2.~Demo(); (очищает память с 2)
    // demo1.~Demo(); (ничего не делает)
}
```

### Оптимизация возврата значения (RVO, Return Value Optimization)

Если вы возвращаете объект из функции, его деструктор не будет вызван.
Фактически, конструктор перемещения тоже не будет вызван.
Он просто напрямую записывает результат в память переменной, объявленной для результата.
