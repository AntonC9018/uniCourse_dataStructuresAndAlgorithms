## Ссылки (\&)

Ссылка - это по сути указатель, адрес которого
не может быть изменен, и имеет упрощенный синтаксис.

Вы также можете считать его псевдонимом для переменной (адреса в памяти).

```cpp
int main()
{
    int a = 5;
    
    int* pointer = &a;
    int& reference = a;
    
    *pointer = 10; // a = 10
    reference = 15; // a = 15
    
    int b = 20;
    // Нельзя перенаправить `reference` на `b`.
    // Следующий код запишет значение `b` (20) в `a`.
    reference = b; // a = 20
    reference = 10; // a = 10
    
    return 0;
}
```

Ссылки можно передавать в функции.
Они скрытно передадутся как указатели.

```cpp
void foo(int& a)
{
    a = 10;
    a = a + 5;
}

int main()
{
    int a = 5;
    foo(a); // a = 15
    return 0;
}
```

Та же программа, но с использованием указателя:

```cpp
void foo(int* a)
{
    *a = 10;
    *a = *a + 5;
}

int main()
{
    int a = 5;
    foo(&a); // a = 15
    return 0;
}
```

Вы можете применить `&` к ссылке, чтобы получить указатель на переменную.

Ссылка - это более ограниченная версия указателя, отлично подходящая для аргументов функций.
Считается хорошей практикой использовать ссылки вместо указателей при передаче аргументов в функции.


## Методы

Рассмотрим функцию, которая принимает переменную структуры.

> Не беспокойтесь о том, как работает `std::string` пока,
> просто концептуально думайте о ней как о строке.

```cpp
#include <iostream>

struct Person
{
    int age;
    std::string name;
};

void printAge(Person* person)
{
    std::cout << person->age;
}

int main()
{
    Person person;
    person.age = 20;
    person.name = "Джон";
    
    printAge(&person);
    
    return 0;
}
```

### `static` методы

Мы можем преобразовать эту функцию в метод объекта, также называемый методом.
Давайте сначала сделаем его статическим методом, чтобы увидеть, как работает концепция *пространств имен* (namespace).

> Обратите внимание, что методы существуют только в C++ и не в C.

> *Член* означает что-то, объявленное в `struct` или `class`.
> Это может быть как метод, так и поле.

```cpp
#include <iostream>

struct Person
{
    int age;
    std::string name;
    
    // Ключевое слово `static` на самом деле не делает его статическим,
    // оно просто требует вызывать эту функцию с использованием оператора разрешения области видимости (::).
    static void printAge(Person* person)
    {
        std::cout << person->age;
    }
};

int main()
{
    Person person;
    person.age = 20;
    person.name = "Джон";
    
    // Вот как вызывать статический метод объекта.
    // `Person` здесь пространство имен, а `printAge` - метод.
    // Идея заключается в том, что мы способны ассоциировать операции,
    // выполняемые с объектом `Person`, с пространством имен `Person` этой структуры.
    Person::printAge(&person);
    
    return 0;
}
```

Вы можете разделить объявление от определения, так же, как и с обычными функциями.
Обратите внимание, что нет другого синтаксиса для этого, 
вам придется указать имя структуры в определении.

```cpp
struct Person
{
    int age;
    std::string name;
    
    static void printAge(Person* person);
};

// Можете считать `Person::printAge` именем этой функции.
static void Person::printAge(Person* person)
{
    std::cout << person->age;
}
```

### Экземпляры и объекты

*Экземпляр* (instance) означает память переменной какого-то типа.
Так что в следующем коде:

```cpp
Person person;
```

мы можем сказать, что `person` - это экземпляр типа `Person`.


*Объект* (object) означает значение экземпляра (копия того что содержится в памяти) какого-то типа.
Так что мы можем сказать, что `person` содержит объект типа `Person`.


### Не статические (instance) методы

Теперь давайте сделаем его методом объекта, который не является статическим.
Метод объекта без статического характера имеет более простой синтаксис вызова,
и автоматически передает указатель на экземпляр как первый скрытый параметр с именем `this`.

```cpp
struct Person
{
    int age;
    std::string name;
    
    // Метод объекта.
    void printAge()
    {
        // `this` - это указатель на экземпляр (`Person*`).
        std::cout << this->age;
    }
};

int main()
{
    Person person;
    person.age = 20;
    person.name = "John";
    
    // Вот как вызывать метод объекта.
    // Компилятор автоматически передает указатель на экземпляр как первый параметр.
    person.printAge();
    
    return 0;
}
```

Это позволяет нам объединить функциональность с типом данных
и получить семантику "объект.глагол".


> `this->` можно не указывать.

```cpp
struct Person
{
    // ...
    void printAge()
    {
        // `age` ссылается на `this->age`.
        std::cout << age;
    }
};
```
Вы можете разделить определение от объявления так же, как с методами объекта.


## Доступность (accessibility) и `class`

По умолчанию, все члены структуры являются `public`.
Это означает, что они могут быть доступны в экземпляре структуры.
Вы можете сделать их явно `private`, чтобы запретить доступ.

Сначала это может показаться абсолютно бесполезным. 
В чем смысл запрета доступа к некоторой памяти?
Одна из идей заключается в том, чтобы ограничить способы доступа
и изменения данных, чтобы стало очевидным, какой из них является правильным, используя методы.

Это не что-то уникальное для ООП, вы можете делать это на уровне модуля, объявляя некоторые функции `static`
(видимые только внутри компиляционной единицы, в которой они были определены).
Однако *модификаторы доступности* являются исключительно ООП фичей.

```cpp
struct Person
{
private:
    int age;
    std::string name;

public:
    void setAge(int age)
    {
        this->age = age;
    }

    void printAge()
    {
        std::cout << this->age;
    }

    void printName()
    {
        std::cout << this->name;
    }
};

int main()
{
    Person person;
    person.age = 15; // ошибка компиляции: невозможно получить доступ к закрытому полю.
    person.name = "John"; // та же ошибка

    person.setAge(15); // компилируется
    person.printAge(); // компилируется
    person.printName(); // компилируется

    return 0;
}
```

Вы можете сделать некоторые поля `private`, а другие - `public`.

```cpp
struct Person
{
private:
    int age;

public:
    std::string name;
}

int main()
{
    Person person;
    person.age = 10; // ошибка компиляции: невозможно получить доступ к закрытому полю.
    person.name = "John"; // работает
    return 0;
}
```


### `class`

`class` эквивалентен `struct`, единственное различие
заключается в том, что у него есть неявное `private:` в начале.
Таким образом, все члены по умолчанию являются публичными в `struct`, но приватными в `class`.

> `class` - это ключевое слово, которое обычно используется в контексте ООП.
> Считается хорошим тоном использовать `class` вместо `struct`, если вы объявляете методы,
> которые инкапсулируют (предоставляют конкретные способы доступа) данные (поля).

```cpp
struct Person
{
private:
    int age;
    std::string name;
}

// эквивалентно

class Person
{
    int age;
    std::string name;
}

// и наоборот ...

class Person
{
public:
    int age;
    std::string name;
}

// эквивалентно

struct Person
{
    int age;
    std::string name;
}
```

## Области видимости (scope)

В C++ области видимости выполняют две функции:
- Они служат для того, чтобы переменные не были видны за их пределами;
- Они используются для очистки памяти ("ресурсов") объектов.
  Это можно сделать с помощью деструкторов.

Можно сказать, что области видимости позволяют вам контролировать время жизни объектов.

### Области видимости для ограничения видимости

Области видимости создаются с использованием `{ ... }`.

```cpp
int main()
{
    int a = 1;

    {
        int b = 2;
        a = 5; // разрешено, `a` видна во внешней области видимости
        b = 10; // разрешено, `b` видна в текущей области видимости
    }

    b = 10; // не разрешено, `b` не видна, потому что ее область видимости завершилась 
            // (фигурная скобка была закрыта).

    a = 15; // все еще разрешено, потому что она видна в текущей области видимости

    return 0;
}
```

Функции должны определять область видимости для своего тела.


Вы можете переопределять переменные с тем же именем, если они находятся в разных областях видимости.
Не гарантируется, что они окажутся указывать на одну и ту же память.

```cpp
int main()
{
    int a = 5;

    // Повторное объявление переменной в той же области видимости не разрешено.
    // int a;

    {
        // Повторное объявление здесь также не разрешено.
        // int a;

        int b = 10;
    }

    {
        // Это разрешено, потому что области видимости не взаимодействуют.
        int b = 20;

        {
            // Это было бы запрещено.
            // int b = 30;
        }
    }

    return 0;
}
```

Область видимости внутри другой области видимости называется *вложенной областью видимости*.
Вы можете *вкладывать* области видимости неограниченное количество раз.

> В целом, помещение одних вещей внутри других вещей того же вида называется *вложением* (nesting).

Существует также концепция глобальной области видимости,
которая представляет собой область видимости, находящуюся вне любой функции.


### Области видимости для очистки ресурсов

Концептуально переменная, объявленная в области видимости, уничтожается в конце области видимости.
Для простых типов, таких как `int`, это в буквальном смысле ничего не означает.
Для сложного типа, такого как `std::string`, это означает
возвращение памяти, выделенной для массива символов, C++ рантайму.


### Деструктор (destructor)

Вы можете определить свою собственную логику, которая будет вызываться при уничтожении вашего объекта с помощью *деструктора*.
Деструктор - это специальная `void` функция, которая автоматически вызывается в этом контексте.
Вы также можете вызывать его вручную.

Давайте просто покажем, как это работает.

```cpp
#include <iostream>

struct Demo
{
    int i;

    // Это деструктор
    ~Demo()
    {
        std::cout << "Destroying demo " << this->i << std::endl;
    }
};

int main()
{
    Demo demo1{1};
    Demo demo2{2};
    std::cout << "Demos created" << std::endl;

    return 0;

    // Компилятор неявно добавляет следующее:
    // `demo2.~Demo();`
    // `demo1.~Demo();`
}
```

Что выводит:

```
Demos created
Destroying demo 2
Destroying demo 1
```

> Вы можете разделять объявление деструктора и его определение
> так же, как и с обычными методами.

Обратите внимание, что деструктор будет вызван только в этом контексте.
Если вы перезначите переменную, он не будет вызван для объекта, уже находящегося в этой памяти.

```cpp
int main()
{
    Demo demo1{1};
    Demo demo2{2};
    demo2 = demo1; // Это копирует байты объекта, но не вызывает деструктор `demo2`.

    return 0;

    // `demo2.~Demo()` выполняется, выводя "Уничтожение демо 1"
    // `demo1.~Demo()` выполняется, выводя "Уничтожение демо 1"
}
```

> Чтобы убедиться, что один и тот же объект не удаляется более одного раза
> в этой ситуации, нам придется перегрузить оператор присваивания.


### Неявные деструкторы (implicit destructors)

Предположим, у вас есть структура с полем, тип которого имеет деструктор.

```cpp
#include <iostream>

struct Test
{
    ~Test()
    {
        std::cout << "Test destroyed" << std::endl;
    }
};

struct Person
{
    Test test;
};

int main()
{
    Person person;
    person.test = {};
    return 0;

    // Компилятор автоматически вызывает деструктор для каждого поля.
    // `person.test.~Test();`

    // Он также удалит временный объект, используемый для присваивания,
    // но это объясняется более подробно позже.
}
```

## Конструкторы (Constructors)

Конструкторы - это специальные `void` функции, используемые для инициализации объектов.
Конструкторы не могут быть вызваны в каком бы то ни было другом контексте.

Конструкторы были созданы для инициализации приватных данных (полей) в ООП.
Конструкторы могут быть более сложными, но, как правило, не рекомендуется делать их сложными.

### Конструкторы, используемые для инициализации новых объектов

> Если они начинают выходить из-под контроля в плане сложности,
> вы можете перейти к использованию фабричных функций.

Например, давайте определим конструктор без параметров (конструктор по умолчанию),
который выводит информацию на консоль.

```cpp
#include <iostream>

class Demo
{
    int memory;

public:
    Demo()
    {
        // memory будет не инициализирована на этом этапе (содержать мусор).
        std::cout << "Создан " << this->memory << std::endl;
        this->memory = 5;
    }

    ~Demo()
    {
        // memory равна 5 на этом этапе.
        std::cout << "Destroyed " << this->memory << std::endl;
    }
};

int main()
{
    {
        // Это фактически вызывает конструктор без параметров.
        // Дизайнеры C++ решили, что объекты никогда не должны оставаться неинициализированными.
        Demo demo;

        // Компилятор неявно добавил:
        // demo.~Demo();
    }

    {
        // Явно вызывает конструктор без параметров.
        Demo demo{};

        // Эквивалентный синтаксис:
        // Demo demo = Demo();

        // Компилятор неявно добавил:
        // demo.~Demo();
    }

    return 0;
}
```

Практическим использованием может быть, например, выделение памяти и очистка ее в деструкторе.
Мы можем сделать это, используя операторы `new` и `delete`.

```cpp
#include <iostream>
#include <assert.h>

class Buffer
{
// private:
    size_t length;
    int* firstElement;

public:
    Buffer(size_t elementCount) 
        // Вписывает `elementCount` в `length` напрямую, до того, как наш код будет запущен.
        // Это называется инициализатором членов.
        : length(elementCount) //, anotherField(8)
    {
        // `firstElement` содержит мусор здесь.

        // Нам нужно выделить память, которая не будет читаемой в инициализаторе.
        // Поэтому я решил написать это в теле конструктора.
        this->firstElement = new int[elementCount];

        // Элементы изначально не инициализированы.
    }

    ~Buffer()
    {
        delete[] firstElement;
    }

    int& elementAt(size_t index)
    {
        assert(index < this->length);
        return firstElement[index];
    }
};

int main()
{
    Buffer buffer{5};

    // Печатает мусор.
    std::cout << buffer.elementAt(0) << std::endl;

    // Do some stuff with the buffer.
    // Выполняем некоторые действия с буфером.
    int& secondElement = buffer.elementAt(1);
    secondElement = 10;

    return 0;

    // Компилятор неявно добавил следующее:
    // buffer.~Buffer();
}
```

### Как легко сломать код выше

Все равно очень легко сломать код выше и получить утечку памяти или повторные удаления памяти:

```cpp
int main()
{
    Buffer buffer1{10};
    Buffer buffer2{20};
    // Это делает копирование по полям.
    buffer2 = buffer1;
    return 0;

    // buffer длиной 20 никогда не освобождается
    // buffer длиной 10 удаляется дважды (ошибка во время выполнения)
}
```

### Конструкторы копирования (copy constructor)

Вы можете определить конструктор, который принимает ссылку на объект,
который будет вызван при копировании.
Это включает в себя обычные определения с использованием `{ }` или определения с немедленным присваиванием.

```cpp
#include <iostream>

class Demo
{
    int id;

public:
    // Необходим конструктор с параметрами, чтобы вообще создать объект.
    Demo(int idParameter) : id(idParameter) { }

    // Demo(const Demo& other)
    Demo(Demo& other) : id(other.id)
    {
        std::cout << "Copying " << other.id << std::endl;
    }
};

int main()
{
    Demo a{1};

    // Вызывает конструктор копирования.
    Demo b{a};

    // Также вызывает конструктор копирования.
    Demo c = a;

    // Это НЕ вызывает конструктор копирования.
    // Он просто копирует поля.
    b = c; 
}
```

### Перемещение объекта (move semantics)

Перемещение объекта в другой объект позволяет одному объекту украсть ресурсы другого.
Это часто используется при создании объектов
или записи значений в поля, чтобы избежать вызова конструктора копирования.

Рассмотрим следующий пример, который создает 2 копии `std::string`:

```cpp
struct Person
{
    std::string name;
};

int main()
{
    // Вызывает конструктор `std::string`, который копирует символы в динамически выделенный буфер.
    std::string name = "John Brown";

    Person person;

    // Выделяет копию `name`, выделяя другой буфер и копируя символы.
    // Затем он записывает эту копию в `person.name`.
    person.name = name;

    return 0;

    // The compiler implicitly adds the following:
    // Компилятор неявно добавляет следующее:
    // `person.name~string();` (из неявного деструктора Person, который удаляет все поля)
    // `name.~string();`
}
```

Итак, мы перемещаем `name` в `person.name`, а не копируем его.
В данном случае это означает, по сути, копирование объекта строки в `person.name`,
а затем его очистку из переменной `name`, чтобы она больше не ссылается на буфер.
Таким образом, она становится непригодной к использованию после этого вызова.

```cpp
#include <iostream>

struct Person
{
    std::string name;
};

int main()
{
    std::string name = "John Brown";
    Person person;

    std::cout << name << std::endl; // John Brown
    std::cout << person.name << std::endl; // 

    person.name = std::move(name);

    std::cout << name << std::endl; // 
    std::cout << person.name << std::endl; // John Brown

    return 0;
}
```

### Конструкторы перемещения (move constructors)

В общем случае вы можете определить конструкторы, принимающие *rvalue-ссылки* (\&\&, rvalue-reference).
Это означает ссылка, из которой нужно красть ресурсы.

> Не зацикливайтесь на деталях, я объясню, что такое rvalue-ссылки позже.

> Вы можете использовать rvalue-ссылки как обычные параметры тоже.

```cpp
#include <iostream>

class Demo
{
    int* memoryPointer;

    int getValue()
    {
        if (memoryPointer == nullptr)
            return 0;
        return *memoryPointer;
    }

public:
    Demo(int value)
    {
        // Выделяет int на куче (просто для демонстрации, я знаю, что это бессмысленно),
        // и сохраняет указатель на него в `memoryPointer`.
        this->memoryPointer = new int{value};
    }

    ~Demo()
    {
        std::cout << "Destructor called for " << this->getValue() << std::endl;
        // Освобождает память (удаление nullptr разрешено).
        delete this->memoryPointer;
    }

    // Конструктор перемещения
    Demo(Demo&& other)
    {
        std::cout 
            << "Move constructor called for "
            << other.getValue()
            << std::endl;

        // Крадем указатель из другого объекта.
        this->memoryPointer = other.memoryPointer;

        // Очищаем указатель из другого объекта.
        // `nullptr` то же самое, что и `0`, он просто обнуляет его.
        other.memoryPointer = nullptr;
    }
};

int main()
{
    Demo demo1{1};
    Demo demo2{2};

    // Это вызывает конструктор перемещения.
    Demo demo3 = std::move(demo1);

    return 0;

    // Компилятор неявно добавляет следующее:
    // demo3.~Demo(); (очищает память с 1)
    // demo2.~Demo(); (очищает память с 2)
    // demo1.~Demo(); (ничего не делает)
}
```

### Оптимизация возврата значения (RVO, Return Value Optimization)

Если вы возвращаете объект из функции, его деструктор не будет вызван.
Фактически, конструктор перемещения тоже не будет вызван.
Он просто напрямую записывает результат в память переменной, объявленной для результата.

### Оптимизация возвращаемого значения (Return Value Optimization, RVO)

Если вы возвращаете объект из функции, его деструктор не будет вызван.
Фактически, конструктор перемещения (move constructor) также не будет вызван.
Результат будет напрямую записан в память переменной, объявленной для результата.

> Я не описал, как фактически работает возвращение объектов из функций,
> но это потому, что сам не знаю точных механизмов.
>
> Он может быть возвращен в одном или нескольких регистрах, а затем скопирован в переменную на стеке,
> или функция может использовать скрытый "выходной" адрес, куда будет записан результат.
> Я не знаю, в какой ситуации компилятор использует ту или иную реализацию,
> и есть ли более умные способы сделать это.
>
> Если вы знаете или хотите узнать больше, я был бы признателен, если бы вы сделали запрос на изменение (Pull Request) с кратким объяснением,
> или предоставили ссылки на ресурсы.

```cpp
Demo test()
{
    Demo demo1{1};
    Demo demo2{2};
    return demo1;

    // `demo2.~Demo();` вставлен компилятором, как обычно.
    // Вызов деструктора для `demo1` НЕ вставляется здесь.
}

int main()
{
    // Компилятор может реализовать это, передавая `test` скрытый указатель на локальную переменную `demo`,
    // и предоставив эту память локальной переменной `demo1` внутри `test`,
    // таким образом, память `demo1` фактически не хранится в стековом кадре `test`.
    // Вы можете представлять себе, что `demo1` является ссылкой на `demo`.
    // Обратите внимание, что это не обязательно то, что будет делать компилятор,
    // это только один из способов реализации этого поведения.
    Demo demo = test();
    return 0;

    // `demo.~Demo();` вставлен компилятором, как обычно.
}
```

RVO - это то почему *не следует перемещать объекты из функций*.

```cpp
Demo test()
{
    Demo demo{1};
    // НЕ Делайте это, это приведет к дополнительному копированию.
    // Это вызовет конструктор перемещения в выходной памяти,
    // а также вызовет деструктор локальной переменной `demo` в конце функции.
    return std::move(demo);
}
```

## Перегрузка операторов (operator overloading)

### Перегрузка оператора присваивания

У нас всё ещё есть большая сложность, которая проявляется опасным образом при копировании в существующую переменную. Смотрите пример [здесь](#Как-легко-сломать-код-выше).

Мы можем исправить эту проблему, переопределив операцию, которую оператор присваивания совершает для нашего типа. Это называется *перегрузкой оператора присваивания*, "оператор присваивания" означает `=` в операции присваивания, а "перегрузка" означает определение функции, которая будет заменять поведение по умолчанию для нашего типа.

```cpp
class Example
{
    int* memory;

public:
    Example(int value)
    {
        this->memory = new int{value};
    }

    ~Example()
    {
        delete this->memory;
    }

    void operator=(const Example& other)
    {
        // Это поведение по умолчанию.
        // Как показано в предыдущем примере,
        // поведение по умолчанию легко может вызвать утечку памяти и повторные free.
        // this->memory = other.memory;

        // Вот то, что нам нужно.
        *this->memory = *other.memory;
    }
};

int main()
{
    Example example1{1};
    Example example2{2};

    // Этот вызов оператора присваивания.
    example2 = example1;

    // `operator=` - это просто имя этого метода,
    // вы также можете вызывать его как обычный метод:
    example2.operator=(example1);

    return 0;
}
```

### Другое решение: запрет на копирование

Вы можете сделать оператор, который определен и доступен к использованию по умолчанию, недоступным, *удалив* метод, отвечающий за этот оператор. Вы делаете это, присвоив ключевое слово `delete` этому методу, вместо предоставления его тела.

```cpp
class Example
{
    // ...

    // Это делает оператор = недоступным.
    void operator=(const Example& other) = delete;
}

int main()
{
    Example example1{1};
    Example example2{2};

    example1 = example2; // ошибка времени компиляции
    return 0;
}
```

Также есть способ явно указать, что мы хотим использовать "поведение по умолчанию" для некоторой функции. Это может быть полезно, если вы хотите вернуть параметрless конструктор, например, не писать тело метода, которое делает то же самое. Вы также можете использовать его для конструктора копирования.

Для этого вы должны назначить ключевое слово `default` этому методу.

> Пример вызовет ошибку во время выполнения и предоставлен для демонстрационных целей.

```cpp
class Example
{
    // ...

    // Разрешить поведение по умолчанию для конструктора без параметров.
    Example() = default;

    // Разрешить поведение по умолчанию для конструктора копирования.
    Example(const Example& other) = default;

    // Чтобы было, давайте явно укажем, что мы хотим,
    // чтобы присваивание имело свое поведение по умолчанию.
    // Тип возвращаемого значения должен быть `Example&` для этого, и объясню почему немного позже.
    Example& operator=(const Example& other) = default;
}

int main()
{
    // Наш пользовательский конструктор.
    Example example1{1};

    // Конструктор без параметров
    Example example2{};

    // Конструктор копирования
    Example example3{example1};

    // Оператор присваивания
    example2 = example1;

    return 0;
}
```

### Перегрузка математических операторов: пример использования `Vector`

Я реализовал структуру Vector с операциями сложения, вычитания и масштабирования.

Одна реализация - процедурная, а другая - с перегрузкой операторов. Смотрите примеры кода [здесь](../../en/05a_programming_fundamentals/vector/procedural.cpp) и [здесь](../../en/05a_programming_fundamentals/vector/operator.cpp).

### Возвращение значений или ссылок из мутирующих операторов

> Под "мутирующими операторами" я имею в виду операторы `=`, `+=`, `-=` и т.д.

Мы можем пойти еще дальше и реализовать операторы `+=` и `-=`. Вы можете выбрать любой тип возвращаемого значения, который вам кажется логичным, но обычно это `void`, `Vector` или `Vector&`. Смотрите [пример](../../en/05a_programming_fundamentals/vector/mutation.cpp).
Мы возвращаем ссылку, чтобы такое было разрешено (хотя это не обязательно):

```cpp
int main()
{
    Vector a{6, 9};
    Vector b{2, 3};
    Vector c{5, 6};

    // Мы можем сделать это в несколько шагов
    a = a + b;
    Vector result = a;
    result = result + c;

    // Или в один шаг
    Vector result = (a += b) + c;
    // Идея в том, что `a += b` возвращает либо значение `a`,
    // либо ссылку на `a`, которая будет результатом `a + b`,
    // то есть новым значением `a` после сложения.

    return 0;
}
```

### Еще один пример: вывод в консоль

Вы, возможно, помните, что C++ использует оператор `<<` (битовый сдвиг влево) для взаимодействия с выходным потоком. Это достигается с использованием `friend` функций, что позволяет им получать доступ к закрытым полям `Vector`.

> `friend` функции являются неявно статическими, то есть у них нет скрытого параметра `this`.

```cpp
#include <iostream>

struct Vector
{
    int x;
    int y;

    // Второй параметр может быть `Vector`, `Vector&` или `const Vector&`.
    // (Фактически вы можете сделать его чем угодно, но это бессмысленно).
    friend std::ostream& operator<<(std::ostream& outputStream, Vector vector)
    {
        outputStream << "(" << vector.x << ", " << vector.y << ")" << std::endl;
        return outputStream;
    }
};

int main()
{
    Vector v{1, 2};
    std::cout << v; // (1, 2)
    return 0;
}
```

Обратите внимание, как перегруженный оператор возвращает ссылку на объект выходного потока. Это позволяет вам использовать оператор `<<` снова сразу после первого. Это называется *fluent interface*; вы можете изучить это самостоятельно.

Например, такой код работает без проблем из-за того, что мы возвращаем ссылку на объект потока:

```cpp
int main()
{
    Vector v1{1, 2};
    Vector v2{5, 6};

    // Это:
    (std::cout << v1) << v2;

    // Эквивалентно этому (вычисляется слева направо):
    std::cout << v1 << v2;

    // Делает то же самое, на самом деле.
    std::cout << v1;
    std::cout << v2;

    return 0;
}
```

`friend` функции немного странны, когда речь идет о разделении объявления от определения:

```cpp
struct Vector
{
    // ...
    // Объявление
    friend std::ostream& operator<<(std::ostream& outputStream, Vector vector);
};

// Определение.
// Вам не нужен оператор разрешения области `::`.
// Фактически, его использование здесь недопустимо.
std::ostream& operator<<(std::ostream& outputStream, Vector vector)
{
    // ...
}
```

`friend` функции позволяют вам разместить логику, связанную с печатью вашего объекта, в вашем классе, а не в классе `std::ostream`. Это полезно, когда вы не можете или есть причина не изменять тип, используемый в качестве первого параметра, то есть вы не можете или не хотите добавить этот оператор как обычный оператор в исходный код класса первого параметра.

В данном случае, конечно, так как `std::ostream` является частью стандартной библиотеки, вы не можете изменить его исходный код. Но даже если бы это было возможно, вы могли бы хотеть, чтобы он имел общую функциональность для вывода текста, не обременяя его конкретной логикой печати вашего конкретного типа. Это позволяет вашему другому типу определить логику печати, основанную на основных операциях, предоставленных `std::ostream`, таких как вывод строк или `int`.

Эта идея тесно связана с инкапсуляцией и обычно называется *separation of concerns*. Следует отметить, что `std::ostream` перегружает оператор `<<` для некоторых основных типов, таких как `const char[N]`, `int`, `float` и т. д., поэтому вы можете использовать `<<` для вывода. И вы можете использовать его fluent образом, потому что он возвращает ссылку на тот же объект потока.

## Абстракция и Инкапсуляция

### Файлы реализации (cpp)

Давайте уточним некоторые моменты, связанные с файлами реализации (файлами `cpp`).
Файлы `cpp` обычно содержат *определения функций и/или глобальных переменных*.
Они могут предоставлять эти функции для использования в других единицах компиляции (в других `cpp` файлах),
но также могут определять `static` функции и глобальные переменные,
которые могут использоваться в качестве вспомогательных внутри предоставленных функций, то есть для реализации логики предоставленных функций.

Что, по вашему мнению, произойдет, если `cpp` файл будет включен в компиляцию дважды?
Предположим, что мы скомпилировали два файла `main.cpp` и `f.cpp` с командой `zig c++ main.cpp f.cpp`, где файлы имеют следующее содержание:

`main.cpp`:

```cpp
#include "f.cpp"

int main()
{
    f(1);
    return 0;
}
```

`f.cpp`:

```cpp
void f(int a)
{
}
```

Это вызовет ошибку связывания (linker error),
потому что функция `f` была определена дважды:
один раз в `main.cpp` (из-за включения содержимого `f.cpp`),
и второй раз в `f.cpp` (потому что мы также компилируем этот файл).

Это по факту означает, что *каждый файл реализации можно компилировать не более одного раза*.

### Общие объявления

Что делать, если мы хотим использовать одну и ту же функцию `f` в нескольких разных файлах?
Просто объявите ее во всех этих файлах, а затем свяжите их с реализацией.
> См. [пример 1](../../en/05a_programming_fundamentals/headers/example_1)

Проблема заключается в том, что теперь, если мы захотим изменить, например, тип параметра `f`
с `int` на `float`, нам придется:
- Изменить файл реализации,
- Изменить объявление `f` в `main.cpp`,
- Изменить объявление `f` в `other_file.cpp`.

И если у нас было бы больше файлов, нам пришлось бы делать это во всех них.

Чтобы избежать необходимости изменять объявление в каждом файле, 
люди обычно выносят объявление в отдельный файл и подключают его в файлах, где оно нужно с помощью директивы `#include`.
Файлы, содержащие такие объявления, называются заголовочными файлами (header files).
Конечно, определение по-прежнему должно быть изменено отдельно.
> См. [пример 2](../../en/05a_programming_fundamentals/headers/example_2)

Если определение функции очевидно и небольшое, как, например, возврат какой-то константы, 
обычно это *определение* размещается непосредственно в заголовочном файле.
Теперь, если бы мы сделали это, у нас возникла бы та же проблема, что и в [предыдущем абзаце](#Файлы-реализации-(cpp)).
Вспомните модификатор `inline`, который делает так, что функция не участвует в связывании и не появляется в конечном исполняемом файле.
Для этой цели идеально подходит `inline`.
Фактически, если все функции можно сделать встроенными (inline), 
нам даже не потребуется файл реализации.
> См. [пример 3](../../en/05a_programming_fundamentals/headers/example_3)

Другой способ избежать ошибок связывания заключается в том, чтобы сделать все функции `статическими`.
Это обычно не рекомендуется, потому что исполняемый файл будет включать их определения столько раз, сколько будет импортирован заголовочный файл.

### Интерфейс

*Модуль* может быть определен как пара файлов: заголовочного и реализации.
Здесь видно, что заголовочный файл, содержащий объявления, эффективно задает *публичный интерфейс модуля*, 
в то время как файл реализации задает *реализацию* интерфейса.

*Абстракция* означает, что вы взаимодействуете с модулем только через его публичный интерфейс.
*Инкапсуляция* означает, что вы можете взаимодействовать с модулем как с целым, 
не имея необходимости понимать, как он реализован и какие данные он использует под капотом.

Вопреки общему мнению, ООП не изобрело ни одного из этих принципов.
Вы можете использовать эти принципы без использования классов.
ООП просто добавляет более детализированную инкапсуляцию на уровне *класса*, 
в виде системы доступности (публичные - приватные члены), и более 
детализированную абстракцию на уровне класса через виртуальные методы (описанные позже?).

Итак, ООП позволяет использовать эти два концепта как на уровне *модуля, так и на уровне класса*,
в то время как обычное процедурное программирование позволяет это *только на уровне модуля*.

### Избегание дублирования объявлений

> TODO: этот пример как бы немного "кривой", потому что предполагается, что несколько объявлений не допускаются.

Предположим, у нас есть код, похожий на следующий:

```cpp
void f(int a);
void f(int a);
void f(int a)
{
    std::cout << a;
}
```

Может быть нежелательно иметь несколько объявлений одной и той же функции.
Теперь предположим ситуацию, когда `main.cpp` включает в себя `a.h` и `b.h`,
а `b.h` также включает `a.h`.
Это означает, что `a.h` был включен дважды.
Если `a.h` объявлял какие-либо функции, наша программа будет включать эти объявления несколько раз.

Это можно избежать с помощью директивы `#pragma once`, которая указывает препроцессору
включать файл только один раз.
Если добавить эту директиву в `a.h`, он будет включен только в `main.cpp`,
а `b.h` пропустит его импорт.
Теперь `b.h` все равно увидит объявления из `a.h`,
потому что он расположен после того, как `a.h` уже был включен в `main.cpp`.

У нас есть очень похожая ситуация в [примере с `inline`](../../en/05a_programming_fundamentals/headers/example_3).
Если вы удалите `#pragma once` из `f.h`, то код не скомпилируется.

### Круговые включения (circular includes)

Их не допускают, потому что файлы всегда включаются последовательно.

### Приватные поля

Как я уже упоминал ранее, типичное процедурное программирование не позволяет
инкапсуляцию на уровне класса (структуры), а только на уровне модуля.
Это означает, что *данные в структурах, которые интерфейс ожидает, что пользователи передадут, могут быть изменены пользователем*.

Пример: предположим, у нас есть тип, представляющий динамически выделяемый буфер фиксированного размера.
Код может выглядеть примерно так:

```cpp
struct DynamicBuffer
{
    int* firstItemPointer;
    size_t length;
}

DynamicBuffer createBuffer(size_t length)
{
    int* pointer = new int[length];
    return {pointer, length};
}

void setItem(DynamicBuffer* buffer, size_t index, int value)
{
    assert(index < buffer->length);
    buffer->firstItemPointer[index] = value;
}

void destroyBuffer(DynamicBuffer* buffer)
{
    delete[] buffer->firstItemPointer;
};
```

Поскольку нет инкапсуляции данных на уровне класса (структуры),
следующий код скомпилируется, но вызовет ошибку во время выполнения.

```cpp
int main()
{
    DynamicBuffer buffer = createBuffer(10);
    buffer.firstItemPointer = 0; // ничто не мешает нам сделать это.
    setItem(&buffer, 0, 5); // ошибка выполнения: access violation
    return 0;
}
```

Конечно, здесь явно видно, что так делать неправильно,
потому что это нарушает внутреннее состояние буфера,
но компилятор все равно разрешит это без проблем.
Идея с доступностью данных заключается в возможности явно запретить это.

```cpp
class DynamicBuffer
{
    // Приватные данные
    int* _firstElementPointer;
    size_t _length;

public:
    // Мы все равно хотим *читать* эти данные,
    // но не *перезаписывать* их напрямую.
    // Поэтому мы можем определить *свойства* для этого.
    // Свойства - это методы, возвращающие или устанавливающие значения полей.
    // Обратите внимание, что я назвал поля с символом подчеркивания, чтобы избежать
    // столкновений имен со свойствами.
    int* firstElementPointer()
    {
        return this->_firstElementPointer;
    }

    size_t length()
    {
        return this->_length;
    }

    DynamicBuffer(size_t length) : _length(length)
    {
        this->_firstElementPointer = new int[length];
    }

    ~DynamicBuffer()
    {
        delete[] this->_firstElementPointer;
    }

    void setItem(size_t index, int value)
    {
        assert(index < this->_length);
        this->_firstElementPointer[index] = value;
    }
};
```

```cpp
int main()
{
    DynamicBuffer buffer{10};
    buffer._firstElementPointer = 0; // не компилируется
    int* firstElement = buffer.firstElementPointer(); // все равно можно *читать* значение
    return 0;
}
```

Но это также не позволяет определять дополнительные операции,
которых нет в классе `DynamicBuffer` и которые должны работать с его закрытым состоянием.
Поэтому следующий код в версии ООП не будет работать:

```cpp
int resize(DynamicBuffer& buffer, size_t newSize)
{
    if (buffer.length() < newSize)
    {
        buffer._length = newSize;
    }
    else
    {
        int* newBufferPointer = new int[newSize];
        for (size_t i = 0; i < buffer.length(); i++)
            newBufferPointer[i] = buffer.firstElementPointer()[i];
        delete[] buffer.firstElementPointer();
        buffer._firstElementPointer = newBufferPointer;
    }
}
```

Но эквивалентная процедурная версия будет работать без проблем.

> Возможно это можно обойти с помощью функций `friend`, но обычно такое решение не ожидается.

### Приватные члены в заголовочном файле

Должно быть довольно очевидно, почему поля должны находиться в заголовочном файле.
Это потому, что для определения размера класса требуется знание этих полей,
и вы должны знать размер класса, потому что вы
*управляете памятью, где будет храниться объект*.

Однако приватные *методы* помещаются в заголовочный файл только для того, чтобы можно было обойти
проблему инкапсуляции: нельзя определить статические функции в файле реализации, имея при этом доступ к приватным полям класса, поэтому вы вынуждены делать
их известными пользователю в объявлении (в заголовочном файле).

`buffer.h` содержит объявление класса (конструкторы и прочее опущено):

```cpp
class DynamicArray
{
    int* pointer;
    size_t count;
    size_t capacity;

public:
    void addItem(int item);

private:
    void ensureCapacity(size_t newMinimumSize);
};
```

`buffer.cpp` содержит определения:

```cpp
void DynamicArray::addItem(int item)
{
    this->ensureCapacity(this->count + 1);
    this->pointer[this->count] = item;
    this->count++;
}

void DynamicArray::ensureCapacity(size_t newMinimumSize)
{
    if (this->capacity >= newMinimumSize)
        return;

    int* oldMemory = this->pointer;
    size_t newSize = std::max(newMinimumSize, this->capacity * 2);
    int* newMemory = new int[newSize];
    for (size_t i = 0; i < this->count; i++)
        newMemory[i] = oldMemory[i];
    this->pointer = newMemory;
    delete[] oldMemory;
}
```

Однако это противоречит идее того, что заголовочный файл
*должен содержать только публичный интерфейс, обеспечивая инкапсуляцию на уровне модуля*.
Идеально было бы, чтобы приватная функция *не существовала в заголовочном файле*,
поскольку она используется только внутри модуля и является деталью реализации.
Нет никакой причины, почему она должна оставаться в заголовке.

Если бы мы попытались просто сделать ее `static` и использовать ее в файле реализации, то:

`buffer.h`:

```cpp
class DynamicArray
{
    int* pointer;
    size_t count;
    size_t capacity;

public:
    void addItem(int item);

    // Нет приватных методов...
};
```

`buffer.cpp`:

```cpp
void DynamicArray::addItem(int item)
{
    ensureCapacity(this, this->count + 1);
}

// статическая функция, поэтому видна и используется только внутри данной едице компиляции.
static void ensureCapacity(DynamicArray* self, size_t newMinimumSize)
{
    // Не удается получить доступ к self->capacity, потому что это приватное поле.
    if (self->capacity >= newMinimumSize)
        return;

    // ...
}
```

Это, конечно, не будет работать из-за правил доступности.

Вы можете обойти это, используя факт, что
*типы, для которых вы не выделяете память или не определяете размер, не обязаны объявлять свои поля*,
в сочетании с тем, что *типы можно использовать как пространства имен* 
и *имеют доступ к приватным членам содержащего типа*.
Подробное объяснение можно найти [здесь](https://stackoverflow.com/questions/28334485/do-c-private-functions-really-need-to-be-in-the-header-file).

Итак, вы можете достичь желаемого поведения статической функции следующим образом:

```cpp
class DynamicArray
{
    // ... поля
public:
    void addItem(int item);

private:
    // Это называется *forward declaration*.
    struct Impl;
};
```

```cpp
// Делаем структуру статической, и все методы становятся статическими (internal linkage).
static struct DynamicArray::Impl
{
    // Не требуется экземпляр.
    // `static` здесь не означает внутреннюю связь,
    // это означает отсутствие неявного параметра `this`.
    static void ensureCapacity(DynamicArray* self, size_t newMaximumSize)
    {
        // Теперь это работает, потому что фактически находимся внутри DynamicArray.
        if (self->capacity >= newMaximumSize)
            return;
        
        // ...
    }
}

void DynamicArray::addItem(int item)
{
    DynamicArray::Impl::ensureCapacity(this, this->count + 1);
    // или так
    // Impl::ensureCapacity(this, this->count + 1);
    // потому что технически уже находимся в области видимости DynamicArray.

    this->pointer[this->count] = item;
    this->count++;
}
```

## `template`

`template` - это базовый примитив языка C++, который, вместе с механизмом перегрузки функций, позволяет реализовывать *статическую полиморфность*.

### Основное использование `template`

`template` на базовом уровне позволяет автоматизировать создание перегрузок функций.

> См. [простой пример](../../en/05a_programming_fundamentals/headers/template/example_1).

Рассмотрим следующий пример:

```cpp
int sum(std::span<int> arr)
{
    int result = 0;
    for (size_t i = 0; i < arr.size(); i++)
        result += arr[i];
    return result;
}

// Перегружаем функцию, что означает определение другой функции с
// различными типами параметров (или их количеством).
float sum(std::span<float> arr)
{
    float result = 0;
    for (size_t i = 0; i < arr.size(); i++)
        result += arr[i];
    return result;
}

int main()
{
    std::array<int, 3> arrInt = { 1, 2, 3 };
    // Вызывает `sum` с параметром `std::span<int>`.
    // Неявное преобразование в `std::span<int>`
    int resultInt = sum(arrInt);

    std::array<float, 3> arrFloat = { 1.0f, 2.0f, 3.0f };
    // Вызывает `sum` с параметром `std::span<float>`.
    float resultFloat = sum(arrFloat);

    return 0;
}
```

`template` позволяет записать функцию всего один раз, для любого типа.
Следующая шаблонная функция будет работать не только для `float` и `int`,
но и для любого другого типа, имеющего конструктор по умолчанию и перегрузку оператора `+=`.

```cpp
template<typename T>
T sum(std::span<T> arr)
{
    T result{};
    for (size_t i = 0; i < arr.size(); i++)
        result += arr[i];
    return result;
}

int main()
{
    std::array<int, 3> arrInt = { 1, 2, 3 };
    // Мы должны вручную преобразовать в `std::span<int>`.
    std::span<int> spanInt = arrInt;
    int resultInt = sum(spanInt);
    // Понимается, что `T` должен быть `int` из типа переменной,
    // передаваемой в функцию. Это эквивалентно:
    // resultInt = sum<int>(spanInt);

    std::array<float, 3> arrFloat = { 1.0f, 2.0f, 3.0f };
    std::span<float> spanFloat = arrFloat;
    float resultFloat = sum(spanFloat);
    // эквивалентно
    // resultFloat = sum<float>(spanFloat);

    return 0;
}
```

Определения шаблонных функций немного магические, когда они находятся в заголовочном файле.
Даже если они используются из нескольких компиляционных единиц, линкер достаточно умён,
чтобы автоматически удалять дублирующиеся определения, созданные из этих функций.
Если бы, например, вы вызвали `sum<int>` из двух разных компиляционных единиц,
будет (обычно) только одно определение `sum` для типа `int`, несмотря на то, что обе компиляционные единицы создали свои собственные копии.
Таким образом, шаблонные функции обычно работают как статические функции, и дубликаты автоматически удаляются.

> Технически гарантии об этом отсутствуют.

> См. [пример этого](../../en/05a_programming_fundamentals/headers/template/example_2).




### `template` для типов 

Точно так же вы можете использовать `template` для типов (структур/классов).
Если у вас есть только поля в типе, это не вызывает дополнительных проблем.

> См. [пример 3](../../en/05a_programming_fundamentals/headers/template/example_3).

Это работает, даже если методы определены на месте в вашем типе.

> См. [пример 4](../../en/05a_programming_fundamentals/headers/template/example_4).


### Явное инстанцирование шаблона

Проблемы с шаблонами возникают, когда вы хотите только
*объявить* метод / функцию в заголовочном файле, а определить её в отдельном файле реализации.
В этом случае определение никогда не создается.
Вы должны убедиться, что создано явное определение.
Это можно сделать в файле, который определяет шаблон, *явно инстанциируя шаблон*.

Вы также можете импортировать файл с определением шаблона (`f.cpp`),
и явно инстанциировать его в другом файле.

> См. [пример 5](../../en/05a_programming_fundamentals/headers/template/example_5).

Для типов это работает аналогичным образом.
Методы, только объявленные, но не определенные, в определении шаблона требуют
явного инстанцирования шаблона для определения.

> См. [пример 6](../../en/05a_programming_fundamentals/headers/template/example_6)


### Шаблонные методы в шаблонных классах

В этой ситуации вам просто нужно применить механизм шаблона несколько раз.
В остальном это работает так же, как и в предыдущих примерах.


### Передача в шаблонные параметры не только типов

Вы можете передавать, например, числа в качестве параметров шаблона.
Вы уже использовали это ранее с `std::array<Type, Size>`.
Вот пример:

```cpp
template<size_t N> // вы указываете тип вместо `typename`
std::array<int, N> createArray()
{
    return {};
}

int main()
{
    std:array result = createArray<10>();
    return 0;
}
```

Это может быть подразумевается автоматически:

```cpp
template<size_t N>
void doStuff(std::array<int, N>& arr)
{
    // ...
}

int main()
{
    std::array arr = { 1, 2, 3 };
    doStuff(arr); // вызывает `doStuff<3>`
}
```

