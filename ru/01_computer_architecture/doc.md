# Общее представление об архитектуре компьютера

## Обзор

На концептуальном уровне компьютер состоит из процессора, который способен выполнять набор инструкций, 
и памяти, которая используется для хранения данных.

Память можно представить как линейную ленту конечной длины, где каждый слот имеет номер, называемый также адресом.
Каждый слот памяти обычно представлен байтом, о котором будет рассказано чуть позже.
Пока же просто считайте, что слот памяти - это небольшой контейнер для данных,
например, цифр или букв (их еще называют символами).
Несколько первых адресов зарезервированы операционной системой, 
поэтому первый адрес, который может быть легально использован программой, смещен на некоторое число, скажем, 100.
Вот пример, концептуально представляющий некоторую память.

| Адрес | Данные |
| ------- | ---- |
| 100 | A |
| 101 | B |
| 102 | 15 |
| 103 | 69 |
| 104 | 0 |

Процессор может читать память с любого адреса и записывать данные по любому адресу.
Он может выполнять операции с данными, которые считывает из памяти, и записывать результат в память.


## Инструкции и пример компьютерной программы

Например, можно прочитать данные по адресу 102 (что дает 15), 
прибавить к ним данные по адресу 103 (который равен 69)
и записать результат (84) обратно по адресу 102 (или любой другой адрес).

Каждая из этих операций называется инструкцией. 
Так, чтение из памяти по какому-либо адресу является инструкцией, 
добавление к нему данных с другого адреса - инструкция,
запись результата обратно в память - это инструкция.

> Уточнение: 
> Процессор имеет свои собственные небольшие участки памяти, с которыми он может работать напрямую, 
> не загружая их из основной памяти.
> Эта специальная память процессора обычно довольно мала и работает практически так же, как и основная память.
> Она разделена на несколько *регистров*, которые представляют собой просто участки памяти по некоторым конкретным адресам.
> Например, в процессоре может быть регистр по адресу 0, который называется *аккумулятор*.
> Когда процессор считывает данные из основной памяти, он должен записать значение в один из своих регистров.
> Это не совсем то, что происходит в процессоре, это упрощение, но оно хорошо подходит в качестве концептуальной модели.

Таким образом, приведенный выше пример с тремя операциями можно перефразировать в три инструкции:
1. Считать данные по адресу 102 из основной памяти и сохранить их в первом слоте памяти процессора (регистре).
2. Считать данные по адресу 103 в основной памяти и добавить их к данным в первом слоте памяти процессора.
3. Записать данные из первого слота памяти процессора по адресу 102 в основной памяти.

Идем дальше - каждая из этих инструкций имеет *идентификатор*. 
Идентификатор - это просто уникальное число, которое может быть использовано для однозначной идентификации инструкции.
Другими словами, если вы знаете этот идентификатор, то вы сможете безошибно сопоставить
к какой инструкции он относится, будь то чтение или запись.

Для простоты предположим, что идентификатор чтения из основной памяти равен 16,
сложения числа в основной памяти с числом в памяти процессора - 22, а записи в основную память - 39.

Таким образом, три приведенные выше инструкции могут быть уплотнены следующим образом:
1. Использовать инструкцию с идентификатором 16, где первый аргумент (адрес основной памяти) равен 102, а второй аргумент (адрес процессорной памяти) - 0 (адрес первого регистра). 
2. Использовать инструкцию с идентификатором 22, где первый аргумент (адрес процессорной памяти) равен 0, а второй аргумент (адрес основной памяти) равен 103.
3. Использовать инструкцию с идентификатором 39, в которой первый аргумент (адрес процессорной памяти) равен 0, а второй аргумент (адрес основной памяти) равен 102.

Таким образом, каждая из этих инструкций принимает два аргумента,
которыми в нашем случае являются адреса в основной памяти и адреса в памяти процессора.

Для ясности, может существовать еще одна инструкция, например 23, которая также принимает два аргумента, 
но на этот раз интерпретирует их как два адреса в памяти процессора, 
складывает их значения и сохраняет результат по первому адресу.
Она совершает слегка другие действия, поэтому мы и присвоили ей отдельный уникальный идентификатор (номер).

Другой пример: скажем, инструкция 12 ожидает, что оба аргумента будут адресами в памяти процессора,
и она будет копировать данные со второго адреса в первый.
Она также связана с копированием, но поскольку мы дали ей отдельный идентификатор,
то можем отличить ее от другой инструкции копирования 16.

Итак, теперь мы можем переписать три приведенные выше инструкции в виде кода.
Да, именно так выглядит код, который может быть выполнен процессором
(концептуально: я утверждаю, что вам не обязательно знать конкретику):

```
16 102 0
22 0 103
39 0 102
```

Что процессор воспримет как последовательность чисел:

```
16 102 0 22 0 103 39 0 102
```
Вот как процессор выполнит этот код: он прочитает первое число как идентификатор инструкции (16).
Теперь он смотрит на этот идентификатор и понимает, что ему нужно интерпретировать следующий аргумент 
как адрес основной памяти (102), а следующий за ним - как регистр (0).
Поэтому он считывает 102, считывает 0, а затем выполняет инструкцию с идентификатором 16,
которая выполнит предопределенную функцию в процессоре, которая выполнит копирование на уровне железа.
Сделав это, процессор продолжит чтение программного кода, прочитает инструкцию 22,
поймет, что ему нужно интерпретировать следующие два числа как регистр (0) и адрес памяти (103), 
и затем выполнит предопределенную встроенную операцию сложения этих двух чисел, сохранив результат в регистре 0.

В принципе, именно так на высоком уровне (другими словами, концептуально) компьютеры способны выполнять код.


## Что такое слоты (байты) в памяти?

Каждый байт - это просто блок из 8 битов. Каждый бит может находиться в двух различных состояниях,
которые обычно называются 0 и 1.
Но как получается, что в байте могут храниться числа, буквы или любые другие данные? Как это работает?

Чтобы понять это, необходимо разобраться в системах счисления.

### Системы счисления

Система счисления может быть использована для представления любого числа.
Число в данном контексте имеет значение абстрактного представления количества,
а не обычного числа, которое вы могли бы записать на бумаге.
Этот скачок абстракции очень важен для понимания того, как работают системы счисления.

Каждая система счисления имеет основание, т.е. количество символов, используемых для представления чисел.
В обычной системе счисления с основанием 10 мы используем 10 символов: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
Теперь скажем, что в системе счисления с основанием 3 использовались бы символы 0, 1, 2.
Но мы можем быть более абстрактными и использовать любые символы для определения собственной системы счисления, 
при условии, что она будет соответствовать таковой структуре (которая постепенно описана в продолжении). 
Например, вместо символов 0, 1 и 2 мы можем использовать x, y и z.
Это абсолютно допустимо, если свойства у чисел в этой системе те же.

> Мне нужно, чтобы вы поняли, что символы 0-9 - это не единственные символы,
> которые можно использовать для представления чисел.

Следовательно, основание - это также количество чисел, которые можно представить одной цифрой.
В системе с основанием 10 мы можем представить одной цифрой 10 чисел: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
В основании 3 -- три числа 0, 1, 2.
В нашей привычной системе счисления по основанию 3 с символами x, y, z -- три числа,
записанные как x, y и z, представляющие числа (абстрактные величины) 0, 1 и 2.

Интереснее становится, когда мы вводим понятие нескольких цифр, используемых для составления одного числа.
Допустим, нам разрешено использовать 2 отдельные цифры для представления числа. 
Естественный выбор, которому подчиняются типичные системы счисления, состоит в том, что мы используем последнюю цифру для представления количества единиц,
а первая цифра представляет количество оснований.
Объясняется это тем, что числа "зацикливаются" и "переносятся", когда это происходит.
Итак, вот некоторые двузначные числа, записанные по основанию 3, и их значение (абстрактное количество), записанное по основанию 10.
Обратите внимание, что мы инкрементируем (увеличиваем на 1) число в каждой строке, в обоих столбцах.

| Основание 3 | Основание 10 |
|-------------|--------------|
| 00          | 0            |
| 01          | 1            |
| 02          | 2            |
| 10          | 3            |
| 11          | 4            |
| 12          | 5            |
| 20          | 6            |
| 21          | 7            |
| 22          | 8            |

Таким образом, когда вторая цифра достигает максимально допустимого числа в данном основании, которое в данном случае равно 2,
оно "переносит 1" на первую цифру, а вторая цифра обнуляется.
Таким образом, при каждом цикле мы отсчитываем 3, что означает, что первая цифра увеличивается на 1 за каждые отсчитанные 3.
Если вдуматься, то это означает, что первая цифра представляет собой количество троек в числе.

В общем случае для любого основания N, максимальное число, после которого происходит "циклирование", равно N-1,
а цифра слева отсчитывает количество N.

Приведем еще один пример, в нашем пользовательской системе с буквами x, y и z для значений 0, 1 и 2.

| Основание xyz | Основание 10 |
|---------------|--------------|
| xx            | 0            |
| xy            | 1            |
| xz            | 2            |
| yx            | 3            |
| yy            | 4            |
| yz            | 5            |
| zx            | 6            |
| zy            | 7            |
| zz            | 8            |


Просто подумайте об этом немного, пока не кликнет.

То же самое происходит и в привычном нам основании 10:
- Каждая цифра может принимать 10 различных значений, от 0 до 9.
- Первая цифра представляет собой количество десяток в числе.
- Вторая цифра представляет собой количество единиц в числе.


А как же трехзначные числа? Ну, опять же, просто подумайте: вторая цифра справа будет испытывать то же самое
"цикливание", которое происходит с последней цифрой, и в этом случае мы переносим 1 на следующую цифру слева.
Таким образом, в случае основания 3, первая цифра теперь будет отсчитывать количество раз,
сколько раз зациклилась цифра справа от нее, а поскольку она зацикливается раз в три тройки,
которые мы считаем, то она будет считать количество девяток в числе.
Составим еще одну таблицу:

| Основание 3 | Основание 10 |
| ------ | ------- |
| 000 | 0 |
| 001 | 1 |
| 002 | 2 |
| 010 | 3 |
| 011 | 4 |
| 012 | 5 |
| 020 | 6 |
| 021 | 7 |
| 022 | 8 |
| 100 | 9 |
| 101 | 10 |
| 102 | 11 |
| 110 | 12 |
| 111 | 13 |
| 112 | 14 |
| 120 | 15 |
| 121 | 16 |
| 122 | 17 |
| 200 | 18 |
| 201 | 19 |
| 202 | 20 |
| 210 | 21 |
| 211 | 22 |
| 212 | 23 |
| 220 | 24 |
| 221 | 25 |
| 222 | 26 |

Видно, что последнее число меняется каждый раз, 
второе меняется каждые 3 раза при инкрементации (увеличении на 1) числа, а первая - каждые 9 раз.

Таким образом, в общем случае для системы счисления с основанием N,
N-я позиция справа представляет собой количество $` N^{M-1} `$ в числе, где M - позиция цифры справа.
Например, число 1234 в системе счисления с основанием 10 имеет вид:

- $` 4 * 10^0 = 4 `$ единицы,
- $` 3 * 10^1 = 3 `$ десятки,
- $` 2 * 10^2 = 2 `$ сотни,
- $` 1 * 10^3 = 1 `$ тысяча.

А чтобы получить окончательное число, нужно просто сложить эти величины.

Число 3321 по основанию 4 будет иметь вид:

- $` 1 * 4^0 = 1 `$ единиц,
- $` 2 * 4^1 = 2 `$ четверки,
- $` 3 * 4^2 = 3 `$ шестерки,
- $` 3 * 4^3 = 3 `$ шестьдесят четыре.

Опять же, здесь я написал числа по основанию 10, но подумайте, что было бы, если бы я написал их по основанию 4?

- $` 1 * 10^0 = 1 `$ ones,
- $` 2 * 10^1 = 2 `$ "one zeros",
- $` 3 * 10^2 = 3 `$ "one zero zeros",
- $` 3 * 10^3 = 3 `$ "one zero zero zeros".

Если вы озадачены тем, почему число 4 вдруг стало 10, то дело в том,
что количество символов в любой системе счисления N, записанных в этой системе N,
будет выглядеть как 10. В данном случае мы записали 4 в системе счисления 4,
что делает его 10 (читается как "один ноль" или "один о", а не как "десять").
Перечитайте примеры выше, если вы запутались.

Иногда вы увидите числа в разных системах счисления,
записанные с индексом системы, записанным в обычной десятичной системе.
Например, 3321<sub>4</sub> означает, что 3321 представляет собой число в системе счисления 4.

Для преобразования числа из системы счисления N в систему счисления M... Просто записывайте степени каждой цифры в системе M, а затем просто складывайте их в этой системе. Это должно стать вполне понятным, если вы об этом подумаете.

Давайте преобразуем из 3321<sub>4</sub> в десятичную систему: $1 * 4^0 + 2 * 4^1 + 3 * 4^2 + 3 * 4^3 = 1 + 8 + 48 + 192 = 249$

И теперь еще один пример 2101<sub>3</sub> из троичной системы в пятеричную.
(Вы складываете и умножаете так же, как и в основании 10, только при переходе к основанию нужно переносить):
- $1 * 3^0 = 1 * 1_{10}$
- $0 * 3^1 = 0 * 3_{10}$
- $1 * 3^2 = 1 * 9_{10}$
- $2 * 3^3 = 2 * 27_{10}$

Теперь мы можем записать 1, 3, 9 и 27 в основании 5. 
- $1_{10} = 1_{5}$
- $3_{10} = 3_{5}$
- $9_{10} = 1 * 5^1 + 4 * 5^0 = 14_{5}$
- $27_{10} = 1 * 5^2 + 0 * 5^1 + 2 * 5^0 = 102_{5}$

Теперь мы можем заменить коэффициенты в основании 10, записанные вначале, на коэффициенты в основании 5:
- $1 * 1_{10} = 1 * 1_{5} = 1_{5}$
- $0 * 3_{10} = 0 * 3_{5} = 0_{5}$
- $1 * 9_{10} = 1 * 14_{5} = 14_{5}$
- $2 * 27_{10} = 2 * 102_{5} = 204_{5}$
 
Теперь мы просто складываем их, чтобы получить результат по основанию 5: $1_5 + 0_5 + 14_5 + 204_5 = ...$
Здесь мы можем выполнить сложение как обычно, используя таблицу 
(только переносить нужно не 10, а 5):
```
204 +
 14 +
  0 +
  1 =
----
224
```

Let's do another one: 1234<sub>10</sub> from base 10 to base 2: 

### How does this relate to bytes?

Now the base 2 (binary) is special for computers, because it uses two symbols for each digit: 0 and 1.
Now remember, we can use any symbol we want to represent these, so we will use the states of bits in memory for this.
Recall that each bit in memory can be in one of two distinct states.
To make memory analogous to binary numbers, we will call these states 0 and 1.
This is done in order to simplify the abstraction, to make it easier to find similarities between memory and binary numbers.

Now, it becomes obvious that we can store numbers in memory. 
> To understand how we store e.g. letters, you need to understand the concept of encoding, which will be discussed later.

What's the largest number we can store in a byte? 
Well, a byte is 8 bit (binary digit). 
And what's the largest number you can store in 8 digits?
Well, the one where all of the digits are equal to the largest symbol in the number system, N - 1, where N is the base.
In base 2 this means a number with all 1 for each of the 8 digits, which is 11111111<sub>2</sub>.
If we convert it to base 10, via the idea described above, we get 255<sub>10</sub>.

So each byte can store numbers in range 0-255<sub>10</sub>, inclusive.


### Additional resources

Processor architecture, simplified, but way more in depth than I have described here: [A (Very) Simplified CPU Diagram](https://www.youtube.com/watch?v=8VakkEFOiJc)
