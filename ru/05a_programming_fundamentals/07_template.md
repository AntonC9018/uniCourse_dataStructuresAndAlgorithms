# `template`

`template` - это базовый примитив языка C++, который, вместе с механизмом перегрузки функций, позволяет реализовывать *статическую полиморфность*.

## Основное использование `template`

`template` на базовом уровне позволяет автоматизировать создание перегрузок функций.

> См. [простой пример](../../en/05a_programming_fundamentals/headers/template/example_1).

Рассмотрим следующий пример:

```cpp
int sum(std::span<int> arr)
{
    int result = 0;
    for (size_t i = 0; i < arr.size(); i++)
        result += arr[i];
    return result;
}

// Перегружаем функцию, что означает определение другой функции с
// различными типами параметров (или их количеством).
float sum(std::span<float> arr)
{
    float result = 0;
    for (size_t i = 0; i < arr.size(); i++)
        result += arr[i];
    return result;
}

int main()
{
    std::array<int, 3> arrInt = { 1, 2, 3 };
    // Вызывает `sum` с параметром `std::span<int>`.
    // Неявное преобразование в `std::span<int>`
    int resultInt = sum(arrInt);

    std::array<float, 3> arrFloat = { 1.0f, 2.0f, 3.0f };
    // Вызывает `sum` с параметром `std::span<float>`.
    float resultFloat = sum(arrFloat);

    return 0;
}
```

`template` позволяет записать функцию всего один раз, для любого типа.
Следующая шаблонная функция будет работать не только для `float` и `int`,
но и для любого другого типа, имеющего конструктор по умолчанию и перегрузку оператора `+=`.

```cpp
template<typename T>
T sum(std::span<T> arr)
{
    T result{};
    for (size_t i = 0; i < arr.size(); i++)
        result += arr[i];
    return result;
}

int main()
{
    std::array<int, 3> arrInt = { 1, 2, 3 };
    // Мы должны вручную преобразовать в `std::span<int>`.
    std::span<int> spanInt = arrInt;
    int resultInt = sum(spanInt);
    // Понимается, что `T` должен быть `int` из типа переменной,
    // передаваемой в функцию. Это эквивалентно:
    // resultInt = sum<int>(spanInt);

    std::array<float, 3> arrFloat = { 1.0f, 2.0f, 3.0f };
    std::span<float> spanFloat = arrFloat;
    float resultFloat = sum(spanFloat);
    // эквивалентно
    // resultFloat = sum<float>(spanFloat);

    return 0;
}
```

Определения шаблонных функций немного магические, когда они находятся в заголовочном файле.
Даже если они используются из нескольких компиляционных единиц, линкер достаточно умён,
чтобы автоматически удалять дублирующиеся определения, созданные из этих функций.
Если бы, например, вы вызвали `sum<int>` из двух разных компиляционных единиц,
будет (обычно) только одно определение `sum` для типа `int`, несмотря на то, что обе компиляционные единицы создали свои собственные копии.
Таким образом, шаблонные функции обычно работают как статические функции, и дубликаты автоматически удаляются.

> Технически гарантии об этом отсутствуют.

> См. [пример этого](../../en/05a_programming_fundamentals/headers/template/example_2).




## `template` для типов 

Точно так же вы можете использовать `template` для типов (структур/классов).
Если у вас есть только поля в типе, это не вызывает дополнительных проблем.

> См. [пример 3](../../en/05a_programming_fundamentals/headers/template/example_3).

Это работает, даже если методы определены на месте в вашем типе.

> См. [пример 4](../../en/05a_programming_fundamentals/headers/template/example_4).


## Явное инстанцирование шаблона

Проблемы с шаблонами возникают, когда вы хотите только
*объявить* метод / функцию в заголовочном файле, а определить её в отдельном файле реализации.
В этом случае определение никогда не создается.
Вы должны убедиться, что создано явное определение.
Это можно сделать в файле, который определяет шаблон, *явно инстанциируя шаблон*.

Вы также можете импортировать файл с определением шаблона (`f.cpp`),
и явно инстанциировать его в другом файле.

> См. [пример 5](../../en/05a_programming_fundamentals/headers/template/example_5).

Для типов это работает аналогичным образом.
Методы, только объявленные, но не определенные, в определении шаблона требуют
явного инстанцирования шаблона для определения.

> См. [пример 6](../../en/05a_programming_fundamentals/headers/template/example_6)


## Шаблонные методы в шаблонных классах

В этой ситуации вам просто нужно применить механизм шаблона несколько раз.
В остальном это работает так же, как и в предыдущих примерах.


## Передача в шаблонные параметры не только типов

Вы можете передавать, например, числа в качестве параметров шаблона.
Вы уже использовали это ранее с `std::array<Type, Size>`.
Вот пример:

```cpp
template<size_t N> // вы указываете тип вместо `typename`
std::array<int, N> createArray()
{
    return {};
}

int main()
{
    std:array result = createArray<10>();
    return 0;
}
```

Это может быть подразумевается автоматически:

```cpp
template<size_t N>
void doStuff(std::array<int, N>& arr)
{
    // ...
}

int main()
{
    std::array arr = { 1, 2, 3 };
    doStuff(arr); // вызывает `doStuff<3>`
}
```
