# Абстракция и Инкапсуляция

## Файлы реализации (cpp)

Давайте уточним некоторые моменты, связанные с файлами реализации (файлами `cpp`).
Файлы `cpp` обычно содержат *определения функций и/или глобальных переменных*.
Они могут предоставлять эти функции для использования в других единицах компиляции (в других `cpp` файлах),
но также могут определять `static` функции и глобальные переменные,
которые могут использоваться в качестве вспомогательных внутри предоставленных функций, то есть для реализации логики предоставленных функций.

Что, по вашему мнению, произойдет, если `cpp` файл будет включен в компиляцию дважды?
Предположим, что мы скомпилировали два файла `main.cpp` и `f.cpp` с командой `zig c++ main.cpp f.cpp`, где файлы имеют следующее содержание:

`main.cpp`:

```cpp
include "f.cpp"

int main()
{
    f(1);
    return 0;
}
```

`f.cpp`:

```cpp
void f(int a)
{
}
```

Это вызовет ошибку связывания (linker error),
потому что функция `f` была определена дважды:
один раз в `main.cpp` (из-за включения содержимого `f.cpp`),
и второй раз в `f.cpp` (потому что мы также компилируем этот файл).

Это по факту означает, что *каждый файл реализации можно компилировать не более одного раза*.

## Общие объявления

Что делать, если мы хотим использовать одну и ту же функцию `f` в нескольких разных файлах?
Просто объявите ее во всех этих файлах, а затем свяжите их с реализацией.
> См. [пример 1](../../en/05a_programming_fundamentals/headers/example_1)

Проблема заключается в том, что теперь, если мы захотим изменить, например, тип параметра `f`
с `int` на `float`, нам придется:
- Изменить файл реализации,
- Изменить объявление `f` в `main.cpp`,
- Изменить объявление `f` в `other_file.cpp`.

И если у нас было бы больше файлов, нам пришлось бы делать это во всех них.

Чтобы избежать необходимости изменять объявление в каждом файле, 
люди обычно выносят объявление в отдельный файл и подключают его в файлах, где оно нужно с помощью директивы `#include`.
Файлы, содержащие такие объявления, называются заголовочными файлами (header files).
Конечно, определение по-прежнему должно быть изменено отдельно.
> См. [пример 2](../../en/05a_programming_fundamentals/headers/example_2)

Если определение функции очевидно и небольшое, как, например, возврат какой-то константы, 
обычно это *определение* размещается непосредственно в заголовочном файле.
Теперь, если бы мы сделали это, у нас возникла бы та же проблема, что и в [предыдущем абзаце](#Файлы-реализации-(cpp)).
Вспомните модификатор `inline`, который делает так, что функция не участвует в связывании и не появляется в конечном исполняемом файле.
Для этой цели идеально подходит `inline`.
Фактически, если все функции можно сделать встроенными (inline), 
нам даже не потребуется файл реализации.
> См. [пример 3](../../en/05a_programming_fundamentals/headers/example_3)

Другой способ избежать ошибок связывания заключается в том, чтобы сделать все функции `статическими`.
Это обычно не рекомендуется, потому что исполняемый файл будет включать их определения столько раз, сколько будет импортирован заголовочный файл.

## Интерфейс

*Модуль* может быть определен как пара файлов: заголовочного и реализации.
Здесь видно, что заголовочный файл, содержащий объявления, эффективно задает *публичный интерфейс модуля*, 
в то время как файл реализации задает *реализацию* интерфейса.

*Абстракция* означает, что вы взаимодействуете с модулем только через его публичный интерфейс.
*Инкапсуляция* означает, что вы можете взаимодействовать с модулем как с целым, 
не имея необходимости понимать, как он реализован и какие данные он использует под капотом.

Вопреки общему мнению, ООП не изобрело ни одного из этих принципов.
Вы можете использовать эти принципы без использования классов.
ООП просто добавляет более детализированную инкапсуляцию на уровне *класса*, 
в виде системы доступности (публичные - приватные члены), и более 
детализированную абстракцию на уровне класса через виртуальные методы (описанные позже?).

Итак, ООП позволяет использовать эти два концепта как на уровне *модуля, так и на уровне класса*,
в то время как обычное процедурное программирование позволяет это *только на уровне модуля*.

## Избегание дублирования объявлений

> TODO: этот пример как бы немного "кривой", потому что предполагается, что несколько объявлений не допускаются.

Предположим, у нас есть код, похожий на следующий:

```cpp
void f(int a);
void f(int a);
void f(int a)
{
    std::cout << a;
}
```

Может быть нежелательно иметь несколько объявлений одной и той же функции.
Теперь предположим ситуацию, когда `main.cpp` включает в себя `a.h` и `b.h`,
а `b.h` также включает `a.h`.
Это означает, что `a.h` был включен дважды.
Если `a.h` объявлял какие-либо функции, наша программа будет включать эти объявления несколько раз.

Это можно избежать с помощью директивы `#pragma once`, которая указывает препроцессору
включать файл только один раз.
Если добавить эту директиву в `a.h`, он будет включен только в `main.cpp`,
а `b.h` пропустит его импорт.
Теперь `b.h` все равно увидит объявления из `a.h`,
потому что он расположен после того, как `a.h` уже был включен в `main.cpp`.

У нас есть очень похожая ситуация в [примере с `inline`](../../en/05a_programming_fundamentals/headers/example_3).
Если вы удалите `#pragma once` из `f.h`, то код не скомпилируется.

## Круговые включения (circular includes)

Их не допускают, потому что файлы всегда включаются последовательно.

## Приватные поля

Как я уже упоминал ранее, типичное процедурное программирование не позволяет
инкапсуляцию на уровне класса (структуры), а только на уровне модуля.
Это означает, что *данные в структурах, которые интерфейс ожидает, что пользователи передадут, могут быть изменены пользователем*.

Пример: предположим, у нас есть тип, представляющий динамически выделяемый буфер фиксированного размера.
Код может выглядеть примерно так:

```cpp
struct DynamicBuffer
{
    int* firstItemPointer;
    size_t length;
}

DynamicBuffer createBuffer(size_t length)
{
    int* pointer = new int[length];
    return {pointer, length};
}

void setItem(DynamicBuffer* buffer, size_t index, int value)
{
    assert(index < buffer->length);
    buffer->firstItemPointer[index] = value;
}

void destroyBuffer(DynamicBuffer* buffer)
{
    delete[] buffer->firstItemPointer;
};
```

Поскольку нет инкапсуляции данных на уровне класса (структуры),
следующий код скомпилируется, но вызовет ошибку во время выполнения.

```cpp
int main()
{
    DynamicBuffer buffer = createBuffer(10);
    buffer.firstItemPointer = 0; // ничто не мешает нам сделать это.
    setItem(&buffer, 0, 5); // ошибка выполнения: access violation
    return 0;
}
```

Конечно, здесь явно видно, что так делать неправильно,
потому что это нарушает внутреннее состояние буфера,
но компилятор все равно разрешит это без проблем.
Идея с доступностью данных заключается в возможности явно запретить это.

```cpp
class DynamicBuffer
{
    // Приватные данные
    int* _firstElementPointer;
    size_t _length;

public:
    // Мы все равно хотим *читать* эти данные,
    // но не *перезаписывать* их напрямую.
    // Поэтому мы можем определить *свойства* для этого.
    // Свойства - это методы, возвращающие или устанавливающие значения полей.
    // Обратите внимание, что я назвал поля с символом подчеркивания, чтобы избежать
    // столкновений имен со свойствами.
    int* firstElementPointer()
    {
        return this->_firstElementPointer;
    }

    size_t length()
    {
        return this->_length;
    }

    DynamicBuffer(size_t length) : _length(length)
    {
        this->_firstElementPointer = new int[length];
    }

    ~DynamicBuffer()
    {
        delete[] this->_firstElementPointer;
    }

    void setItem(size_t index, int value)
    {
        assert(index < this->_length);
        this->_firstElementPointer[index] = value;
    }
};
```

```cpp
int main()
{
    DynamicBuffer buffer{10};
    buffer._firstElementPointer = 0; // не компилируется
    int* firstElement = buffer.firstElementPointer(); // все равно можно *читать* значение
    return 0;
}
```

Но это также не позволяет определять дополнительные операции,
которых нет в классе `DynamicBuffer` и которые должны работать с его закрытым состоянием.
Поэтому следующий код в версии ООП не будет работать:

```cpp
int resize(DynamicBuffer& buffer, size_t newSize)
{
    if (buffer.length() < newSize)
    {
        buffer._length = newSize;
    }
    else
    {
        int* newBufferPointer = new int[newSize];
        for (size_t i = 0; i < buffer.length(); i++)
            newBufferPointer[i] = buffer.firstElementPointer()[i];
        delete[] buffer.firstElementPointer();
        buffer._firstElementPointer = newBufferPointer;
    }
}
```

Но эквивалентная процедурная версия будет работать без проблем.

> Возможно это можно обойти с помощью функций `friend`, но обычно такое решение не ожидается.

## Приватные члены в заголовочном файле

Должно быть довольно очевидно, почему поля должны находиться в заголовочном файле.
Это потому, что для определения размера класса требуется знание этих полей,
и вы должны знать размер класса, потому что вы
*управляете памятью, где будет храниться объект*.

Однако приватные *методы* помещаются в заголовочный файл только для того, чтобы можно было обойти
проблему инкапсуляции: нельзя определить статические функции в файле реализации, имея при этом доступ к приватным полям класса, поэтому вы вынуждены делать
их известными пользователю в объявлении (в заголовочном файле).

`buffer.h` содержит объявление класса (конструкторы и прочее опущено):

```cpp
class DynamicArray
{
    int* pointer;
    size_t count;
    size_t capacity;

public:
    void addItem(int item);

private:
    void ensureCapacity(size_t newMinimumSize);
};
```

`buffer.cpp` содержит определения:

```cpp
void DynamicArray::addItem(int item)
{
    this->ensureCapacity(this->count + 1);
    this->pointer[this->count] = item;
    this->count++;
}

void DynamicArray::ensureCapacity(size_t newMinimumSize)
{
    if (this->capacity >= newMinimumSize)
        return;

    int* oldMemory = this->pointer;
    size_t newSize = std::max(newMinimumSize, this->capacity * 2);
    int* newMemory = new int[newSize];
    for (size_t i = 0; i < this->count; i++)
        newMemory[i] = oldMemory[i];
    this->pointer = newMemory;
    delete[] oldMemory;
}
```

Однако это противоречит идее того, что заголовочный файл
*должен содержать только публичный интерфейс, обеспечивая инкапсуляцию на уровне модуля*.
Идеально было бы, чтобы приватная функция *не существовала в заголовочном файле*,
поскольку она используется только внутри модуля и является деталью реализации.
Нет никакой причины, почему она должна оставаться в заголовке.

Если бы мы попытались просто сделать ее `static` и использовать ее в файле реализации, то:

`buffer.h`:

```cpp
class DynamicArray
{
    int* pointer;
    size_t count;
    size_t capacity;

public:
    void addItem(int item);

    // Нет приватных методов...
};
```

`buffer.cpp`:

```cpp
void DynamicArray::addItem(int item)
{
    ensureCapacity(this, this->count + 1);
}

// статическая функция, поэтому видна и используется только внутри данной едице компиляции.
static void ensureCapacity(DynamicArray* self, size_t newMinimumSize)
{
    // Не удается получить доступ к self->capacity, потому что это приватное поле.
    if (self->capacity >= newMinimumSize)
        return;

    // ...
}
```

Это, конечно, не будет работать из-за правил доступности.

Вы можете обойти это, используя факт, что
*типы, для которых вы не выделяете память или не определяете размер, не обязаны объявлять свои поля*,
в сочетании с тем, что *типы можно использовать как пространства имен* 
и *имеют доступ к приватным членам содержащего типа*.
Подробное объяснение можно найти [здесь](https://stackoverflow.com/questions/28334485/do-c-private-functions-really-need-to-be-in-the-header-file).

Итак, вы можете достичь желаемого поведения статической функции следующим образом:

```cpp
class DynamicArray
{
    // ... поля
public:
    void addItem(int item);

private:
    // Это называется *forward declaration*.
    struct Impl;
};
```

```cpp
// Делаем структуру статической, и все методы становятся статическими (internal linkage).
static struct DynamicArray::Impl
{
    // Не требуется экземпляр.
    // `static` здесь не означает внутреннюю связь,
    // это означает отсутствие неявного параметра `this`.
    static void ensureCapacity(DynamicArray* self, size_t newMaximumSize)
    {
        // Теперь это работает, потому что фактически находимся внутри DynamicArray.
        if (self->capacity >= newMaximumSize)
            return;
        
        // ...
    }
}

void DynamicArray::addItem(int item)
{
    DynamicArray::Impl::ensureCapacity(this, this->count + 1);
    // или так
    // Impl::ensureCapacity(this, this->count + 1);
    // потому что технически уже находимся в области видимости DynamicArray.

    this->pointer[this->count] = item;
    this->count++;
}
```

