
# Пространства имен

Мы уже знакомы со скоупами типов, которые включают в себя концепцию пространства имен.
Однако, если вам нужен примитив, который предоставляет только концепцию пространства имен,
вы можете использовать `namespace`.

## Базовое использование

Пространство имен по сути означает скоуп,
в котором могут находиться функции, переменные, типы и другие пространства имен,
и может использоваться для избежания конфликтов имен.

Я уже использовал пространство имен `std` в своих примерах.
`std` - это пространство имен, которое создано стандартной библиотекой.
Однако, мы можем с легкостью можем создать свое, новое пространство имен.

```cpp
#include <iostream>

// Определяем пространство имен с именем Demo.
namespace Demo
{
    // Размещаем функцию внутри Demo.
    void f()
    {
        std::cout << "Hello from Demo::f" << std::endl;
    }
}

int main()
{
    // Мы можем использовать оператор разрешения области видимости для доступа к функции.
    // Это аналогично использованию `.` для доступа к полям структуры.
    Demo::f();
    return 0;
}
```

Заметьте, как это практически то же самое, что и статическая функция в объявлении типа.
Это потому, что объявления типов функционируют как пространства имен.

```cpp
#include <iostream>

struct Demo
{
    static void f()
    {
        std::cout << "Hello from Demo::f" << std::endl;
    }
};

int main()
{
    Demo::f();
    return 0;
}
```

Вы можете вкладывать пространства имен в другие пространства имен.

```cpp
namespace Demo
{
    namespace Demo1
    {
        void f()
        {
        }
    }
}

int main()
{
    Demo::Demo1::f();
    return 0;
}
```

Пространства имен могут использоваться, когда у вас есть различные реализации функции
с тем же именем, которые вы хотите различать:

```cpp
namespace Impl1
{
    void f()
    {
        std::cout << "Hello";
    }
}

namespace Impl2
{
    // Несмотря на то, что у нее то же имя, это не вызовет ошибку связывания.
    void f()
    {
        std::cout << "World";
    }
}

int main()
{
    Impl1::f(); // Привет
    Impl2::f(); // Мир
    return 0;
}
```

Вы можете определять пространства имен несколько раз, в разных местах,
и они будут ссылаться на тот же "объект".

```cpp
namespace Demo
{
    void f()
    {
    }
}

namespace Dima
{
    void g()
    {
    }
}

// Ссылается на то же пространство имен, что и Demo выше.
namespace Demo
{
    // Это пространство имен не то же самое, что и Dima выше.
    // Это пространство имен действительно называется Demo::Dima.
    namespace Dima
    {
        // Полностью допустимо, нет ошибки времени компиляции
        void g()
        {
        }
    }

    // Тоже допустимо, нет ошибки времени компиляции.
    void g()
    {
    }

    // Дублированное определение, ошибка времени компиляции.
    // У нас уже есть `f()` выше.
    void f()
    {
    }
}
```

Это означает, что определение пространства имен `std` в вашем коде абсолютно допустимо.
Это даже требуется для некоторых вещей, таких как определение хэш-функции для типа.

```cpp
namespace std
{
    void f(){}
}

int main()
{
    std::f();
    return 0;
}
```

Обратите внимание, что `main` должна находиться вне какого бы то ни было пространства имен,
чтобы выполнять особую роль точки входа.


## Пространства имен позволяют использовать символы из того же пространства имен без квалификации

```cpp
namespace Demo
{
    void f()
    {
    }

    void g()
    {
        // Мы можем использовать `f` без квалификации.
        f();
        // Мы могли бы использовать `Demo::f`, если бы хотели.
        Demo::f();
    }
}
```

Это похоже на тот факт, что не обязательно дописывать `this->`,
когда обращаетесь к полям или методам внутри тела метода.

Кстати, то же самое относится и к областям видимости,
созданным ключевыми словами `struct` или `class`.

Еще одна штука: вложенные пространства имен могут видеть символы,
определенные во внешних пространствах имен.
Это аналогично скоупах в функциях, разница в том, что вам *разрешается*
определять функции с тем же прототипом в различных скоупах.

```cpp
namespace Outer
{
    void f()
    {
    }

    void g()
    {
    }

    namespace Inner
    {
        // Повторное определение `g` во вложенном пространстве имен разрешено.
        void g()
        {
            // Вызывает `Outer::f()`
            f();
        }
    }
}
```

## Упрощение с оператором `::`

Вы не обязаны вкладывать каждое отдельное пространство имен.
Вы можете использовать `::` в определении пространства имен.
Следующий код:

```cpp
namespace Outer
{
    namespace Inner
    {
        void f()
        {
        }
    }
}
```

Эквивалентен следующему:

```cpp
namespace Outer::Inner
{
    void f()
    {
    }
}
```

## Глобальный скоуп

Глобальная скоуп находится вне пространств имен.
У него нет имени.
Его можно использовать для разрешения неоднозначности имен
в некоторых редких ситуациях.

```cpp
namespace Demo
{
    void f()
    {
        std::cout << "Outer";
    }

    namespace Dima
    {
        namespace Demo
        {
            void f()
            {
                std::cout << "Inner";
            }
        }

        void g()
        {
            // Мы хотим вызвать `Demo::f` из глобального скоупа.
            // Однако просто вызов `Demo::f` вызовет `f` из внутреннего `Demo`.
            Demo::f(); // Inner

            // Чтобы вызвать внешний `Demo::f`,
            // надо разрешить это имя относительно глобального скоупа.
            ::Demo::f(); // Outer

            // Внутренний вызов можно записать так:
            ::Demo::Dima::Demo::f(); // Inner
        }
    }
}
```

## `using namespace`

`using namespace` -- четкая фича. 
Ее можно использовать для включения всех элементов пространства имен в текущий скоуп.
Под "включением" я имею в виду видимость всех элементов пространства имен без квалификации.
Самое замечательное заключается в том, что его можно использовать в *любом* скоупе,
будь то скоупы функций, вложенные обычне скоупы, пространства имен или скоупы типов.

```cpp
#include <iostream>

int main()
{
    {
        // Делаем все элементы std видимыми здесь без квалификации.
        using namespace std;

        cout << "Hello" << endl;
    }

    {
        // Но не здесь.
        cout << "World" << endl; // ошибка при компиляции
    }
}
```

`using namespace` довольно опасен, потому что он может привести к выбору функции,
отличной от вашей, при разрешении перегрузки,
то есть компилятор может вызвать стандартную функцию с тем же именем, что и ваша,
что лучше соответствует ее параметрам.

Я покажу вам это на более мирном примере, чтобы вы поняли идею.

```cpp
#include <iostream>

namespace Demo
{
    void f(int a)
    {
        std::cout << "Demo::f -- " << a << std::endl;
    }
}

// Мы как ни в чем не бывало определяем вторую функцию,
// которая принимает float вместо int,
// ожидая, что вызовется эта, не зная о существовании другой в Demo.
void f(float a)
{
    std::cout << "Happy life" << std::endl;
}

int main()
{
    using namespace Demo;
    // Угадайте, какая функция будет вызвана здесь?
    f(5); 
    return 0;
}
```

`using namespace std` чрезвычайно опасен из-за этого,
так как внутри `std::` находится **море** хлама,
который *очень вероятно* имеет те же имена, что и некоторые из ваших символов.
Вы можете потратить бесчисленные мучительные часы, пытаясь
понять, почему ваша функция не делает то, что ей предписано,
все, чтобы заметить после, что вы все это время тестировали вообще не ту функцию.

`using namespace` *нельзя* применять к типам.

```cpp
#include <iostream>

struct T
{
    int value;
    static void f()
    {
        std::cout << "T::f" << std::endl;
    }
};

int main()
{
    // Не компилируется
    using namespace T;
    f();
    return 0;
}
```


## Разрешение коллизий имен

Если вы включили два пространства имен, в которых есть одинаковое объявление функции,
вы не сможете вызвать функцию без квалификации.

```cpp
namespace A
{
    void f()
    {
        std::cout << "A";
    }
}
namespace B
{
    void f()
    {
        std::cout << "B";
    }
}

int main()
{
    using namespace A;
    using namespace B;

    // Компилятор: "Чел, какую мне вызвать? A::f или B::f?"
    f();

    // Вы должны разрешить неоднозначность, квалифицировав имена.
    A::f(); // A
    B::f(); // B
}
```

Аналогичная ситуация, где происходит коллизия имен между функцией из глобального скоупа
и функцией из использованного пространства имен, может быть разрешена аналогичным образом:

```cpp
namespace A
{
    void f()
    {
        std::cout << "Hello";
    }
}
void f()
{
    std::cout << "World";
}

int main()
{
    using namespace A;

    f(); // бессмысленно!
    A::f(); // Hello
    ::f(); // World

    return 0;
}
```


## `using` для псевдонимов имен

Еще одним очень полезным способом использования `using`
является предоставление типу другого имени.
Это в значительной степени эквивалентно `typedef`, но `using` немного более интуитивен,
поэтому рекомендуется использовать `using` вместо `typedef`.

> `typedef` не работает с шаблонами, `using` - да.


```cpp
namespace Long::Namespace::Name
{
    struct Outer
    {
        struct Inner
        {
            struct Target
            {
                int x;
            };
        };
    };
}
int main()
{
    using T = Long::Namespace::Name::Outer::Inner::Target;
    // то же самое, что и
    // typedef Long::Namespace::Name::Outer::Inner::Target T;

    T t{15};
    std::cout << t.x; // 15

    return 0;
}
```

```cpp
enum class Color
{
    Red = 'r',
    Green = 'g',
    Blue = 'b',
};

int main()
{
    using C = Color;
    C color = C::Red;

    switch (color)
    {
        case C::Red:
            std::cout << "Red";
            break;
        case C::Green:
            std::cout << "Green";
            break;
        case C::Blue:
            std::cout << "Blue";
            break;
    }

    return 0;
}
```

Вы можете использовать синтаксис `namespace X =` для того же самого с пространствами имен.

```cpp
namespace Hello::World::Long::Namespace::Very::Long
{
    void func()
    {
    }
}

int main()
{
    namespace NS = Hello::World::Long::Namespace::Very::Long;
    NS::func();
}
```
