# Полиморфизм

*Полиморфизм* означает, что одно имя функции может ссылаться на разные функции 
в зависимости от некоторого контекста.
Это одна из самых важных концепций программирования,
которая позволяет достичь некоторых мощных техник.

## Статический полиморфизм (перегрузка функций)

Я уже отчасти затронул эту идею в разделе о `template`.
Это относится к объявлению нескольких функций с одним и тем же именем,
но разным количеством параметров или типами параметров.

```cpp
void f(int a)
{
    std::cout << "int";
}

void f(float a)
{
    std::cout << "float";
}

int main()
{
    f(5); // int
    f(5.0f); // float
    return 0;
}
```

Здесь нет ничего сверхъестественного.
Основная идея, которую нужно понять, заключается в том,
что одно и то же имя `f` ссылается на несколько функций,
и какая именно функция вызывается,
определяется контекстом -- типом аргумента.

Обратите внимание, что в отличие от C++, в C нет перегрузки функций.
В C для реализации того же функционала вам пришлось бы дать функциям разные имена.
Обычно дописывают тип аргумента (каким-нибудь образом).

```cpp
void f_int(int a)
{
    std::cout << "int";
}

void f_float(float a)
{
    std::cout << "float";
}

int main()
{
    f_int(5); // int
    f_float(5.0f); // float
    return 0;
}
```

В этом случае, синтаксис вызова становится излишне явным,
что перегрузка функций стремится устранить.
Если у программы уже есть информация о типе,
на основе которой она может решить, какую функцию вызвать,
зачем повторять это каждый раз, когда вы хотите вызвать функцию?
В этом идея перегрузок.


## Указатели на функции

Идея в вызове функции по ее адресу, сохраненному в переменной-указателе.

Вы можете использовать это для реализации примитивной формы паттерна стратегии.
Стратегия, менее можщый паттерн, чем паттер итератора,
в плане работы с коллекциями, но он тоже может быть использован.
Вы также можете объединить их вместе, чтобы создать абстракцию над циклами.

См. [пример](../../en/05a_programming_fundamentals/polymorphism/strategy_func_pointer.cpp).

Вы можете использовать эту идею для присвоения поведения вещам.
Представьте, что подключаете определенную функцию к вызову при нажатии кнопки.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/button_func_pointer_example.cpp).

Конечно, можно было бы добиться этого с помощью `switch`.
Но что, если основная функция не должна знать о всех возможных функциях?
Как в [следующем примере](../../en/05a_programming_fundamentals/polymorphism/button_func_pointer_decentralized.cpp).
Это легко может произойти, если вы фактические функции находяться в каком-то другом модуле
как `static`, в то время как интерфейс модуля объявляет только функцию,
которая добавит эти внутренние функции в список.
Вы никогда не смогли бы добиться чего-то подобного с помощью `switch`,
без добавления всех внутренних функций в интерфейс модуля.

```cpp
// main.cpp
include "math_functions.h"
// ...
addMathFuncs(functionList);
```

```cpp
// math_functions.h
void addMathFuncs(std::vector<ButtonFunc>& functionList);
```

```cpp
// math_functions.c
static void add()
{
    // ...
}

static void subtract()
{
    // ...
}

void addMathFuncs(std::vector<ButtonFunc>& functionList)
{
    functionList.push_back(add);
    functionList.push_back(subtract);
}
```

## Передача закрытого состояния в функцию

При использовании указателей на функции возникает ограничение: 
нельзя передавать данные внутрь функции.
Если вам нужна функция, которая добавляет 5 к каждому числу в массиве, всё в порядке.
Однако, если вам нужна функция, которая добавляет N к каждому числу в массиве,
вы попросту не сможете передать N параметром.

```cpp
void add5(int& a)
{
    a += 5;
}

void addN(int& a, int n)
{
    a += n;
}

// ...

// Ок
forEachItem(list, add5);

// Невозможно
int increment = 5;
forEachItem(list, addN(???, increment));
```

Конечно, можно частично решить эту проблему, используя глобальные переменные,
но так делать не рекомендую.
Это делает программу менее гибкой и порождает беспорядок.
Если `forEachItem` принимает только указатели на функции, у вас нет выбора.
Но если вы можете изменить `forEachItem`, то есть другие варианты.

Желательно, чтобы пользователь мог передавать *собственный контекст* в функцию,
то есть дополнительные данные, необходимые для выполнения её задачи.
Довольно простым решением будет добавление параметра-шаблона
для типа контекста и передача его вместе с указателем на функцию.

См. [пример](../../en/05a_programming_fundamentals/polymorphism/func_with_context.cpp).
В нем есть несколько проблем, таких как сложность создания перегрузки для `const`
без дублирования всего кода, но об этом можете не беспокоиться.
Другая проблема заключается в том, что различные функции могут требовать различные типы
контекста.
Таким образом, полиморфизм в данном случае, по сути,
статичен, но зависит от типа контекста, а не функции.


## `void*` в качестве типа контекста (type erasure)

Особенностью `void*` является то, что его можно использовать для хранения указателя 
на что угодно, что позволяет передавать с его помощью контекст любого типа.
Единственная проблема заключается в том, что вам придется удостовериться,
что вы передаете правильное значение и закастить его обратно в ожидаемый тип
в функции на принимающем конце, так что это довольно хрупкое решение.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/func_with_context_void.cpp).

Также, поскольку некоторый контекст может быть по размеру не больше указателя,
мы можем хранить его непосредственно, вместо указатель.
Мы можем сделать это, передавая `uintptr_t` и затем кастя его в ожидаемый тип,
который может быть как указателем, так и значением.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/pointer_value_union_small_example.cpp).


## Шаблонное состояние и функция в одном (функторы)

Этот подход представляет собой еще один способ 
статического полиморфизма с передачей контекста.
Идея заключается в том, что вы можете объединить контекст и функцию в один тип,
сделав функцию, которую вы хотите вызвать, членом этого типа.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/functor_custom_name.cpp).

Чтобы можно было надежно вызывать метод из шаблонного определения,
вам нужно выбрать конкретное имя для этой функции, и использовать его для всех функторов.
В C++ для этого был выбран *оператор вызова `operator()`*,
потому что с его помощью вы теперь можете передавать указатели на функции как функторы.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/functor.cpp).

Обратите внимание, что для каждого нового типа, который вы передаете в `forEachItem`,
будет создана новая копия функции в итоговом исполняемом файле
(если не будет оптимизирована / объединена с существующим определением).
В большинстве случаев это не должно вызывать беспокойство,
но особенно большие функции могут увеличить размер вашего исполняемого файла
(делая его слишком большим),
из-за чего использование более динамического подхода иногда может быть более разумным.

Идея функторов часто используется функциями в,
например, модуле `algorithm` стандартной библиотеки,
который также работает с итераторами.


## Лямбда-функции

Лямбда-функции позволяют нам определять функции без указания имени (анонимные функции),
возможно, в пределах другой функции, и автоматически создавать тип функтора.

### Без контекста

Чтобы определить лямбда-функцию без контекста,
эквивалентную обычной свободной функции (функции в глобальном скоупе),
используется [следующий синтаксис](../../en/05a_programming_fundamentals/polymorphism/lambda_1_void.cpp).
Вы можете передавать её напрямую в качестве параметра другим функциям,
которые также принимают указатель на функцию.

### Закрытый контекст

Чтобы определить личный контекст функции, вы помещаете параметры
лямбда-функции в квадратные скобки (называемые *capture group* (группа захвата)).
*Копии* переменных, указанных в квадратных скобках, будут доступны в функции.
Под капотом компилятор создает тип функтора,
и эти переменные становятся приватными полями этого типа.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/lambda_2_context_copy.cpp).

> Обратите внимание, что `mutable` требуется, 
> если функция хочет изменить значение своего контекста.
> Он добавляет `const` к сгенерированному методу `operator()`, 
> следуя привычным правилам `const` для ссылок и значений.

Процесс копирования переменных называется *захватом* (capturing).

### Общий контекст

Также можно использовать захват по ссылке,
добавив символ `&` перед именем переменной в группе захвата.
Таким образом, вы можете обмениваться контекстом между несколькими лямбда-функциями.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/lambda_3_shared_context.cpp).

Можно смешивать типы захвата.

```cpp
int a = 1;
float b = 8;
auto func = [&a, b]() mutable {
    a += 5;
    b *= 10;
};

func();

assert(a == 6);
assert(b == 8); // `b` был скопирован по значению
```

И иметь несколько захватов одного типа:

```cpp
int a;
float b;
auto func = [&a, &b]() mutable {
    a += 5;
    b *= 10;
};
```

### Передача лямбд в шаблоны

Например, в [этом примере](../../en/05a_programming_fundamentals/polymorphism/functor.cpp),
вы можете передавать лямбды в функцию:
```cpp
// `a` здесь представляет собой ссылку.
forEachItem(values, [&a = values[0]](float& value){ value *= a; });

// или сохранять адрес (`a` здесь представляет собой указатель)
forEachItem(values, [a = &values[0]](float& value){ value *= *a; });
```

### Подвешенные ссылки

Будьте осторожны с захватом по ссылке, потому что можно легко получить dangling ссылки,
если вы попытаетесь вернуть функтор с захватом по ссылке на локальные переменные из функции.
Dangling ссылки -- ссылки на удаленную или недоступную память,
которая раньше являлась доступной, оставшиеся где-то среди значений переменных.

```cpp
auto createBadFunctor()
{
    int localVariable{5};
    return [&localVariable](){ return localVariable; };
}

int main()
{
    auto func = createBadFunctor();
    func(); // ссылается на удаленную память -- неопределенное поведение
    return 0;
}
```

### Захват всего

Вы можете захватить все видимые в текущей области видимости переменные по значению
с помощью `[=]` или по ссылке с помощью `[&]`.

```cpp
int a = 1;
int b = 2;
{
    auto func = [=]() mutable {
        a += 5;
        b *= 10;
    };
    func(); // a = 1, b = 2
}
{
    auto func = [&]() {
        a += 5;
        b *= 10;
    };
    func(); // a = 6, b = 20
}
```

Также можно использовать `&` или `=` для установки способа захвата по умолчанию,
а затем переписать его для конкретных переменных:

```cpp
int a = 1;
int b = 2;
// По умолчанию ссылка, но `a` должна быть скопирована.
auto func = [&, a]() mutable {
    a += 5;
    b *= 10;
};
func(); // a = 1, b = 20
```

Переменные будут захвачены только в том случае, если они используются в лямбда-функции.
Это иллюстрируется [здесь](../../en/05a_programming_fundamentals/polymorphism/lambda_4_functor_sizes.cpp).


## Небольшое вступление: типы функций

Это может быть сложно себе представить, но в этом языке объявления функций имеют типы.
Синтаксис аналогичен типам указателей на функции, но без `(*)`:

```cpp
using FuncType = void(int, int);
FuncType f; // объявление
void f(int a, int b); // эквивалентное объявление
void f(int a, int b) { } // определение
```

Также, подобно переменным, можно иметь ссылки на функции:

```cpp
using FuncRefType = void(&)(int, int);
void f(int a, int b) { }
FuncRefType g = f;
```

Или с использованием `decltype`:

```cpp
void f(int a, int b) {}
decltype(f)& g = f;
```


## `std::function`

`std::function` определяется документацией как *general-purpose polymorphic function wrapper*.
Идея `std::function` в том, что к переменной этого типа
можно присвоить любую функцию или функтор,
потенциально захватывая его контекст,
а затем вызывать её позже.

Это мощный тип, который по факту позволяет реализовать
динамический полиморфизм очень гибким образом,
что означает возможность его передачи в функции без наличия
у них параметра-шаблона для функтора.

Строго говоря, `std::function` является типом,
реализующим динамический полиморфизм, что подразумевает,
что это не приведет к раздутию кода, упомянутому ранее,
но приведет к некоторым временным затратам при вызове функции
(аналогично тому, в случае вызова функции через указатель на функцию, а не напрямую,
вызов функтора через `std::function` медленнее ее вызова напрямую, или функтором по шаблону).

См. [пример](../../en/05a_programming_fundamentals/polymorphism/std_function.cpp),
который иллюстрирует работу с `std::function`
с использованием до двух уровней косвенности (pointer indirection),
используя как лямбды, так и функторы,
и предоставляет пример того, как перемещать данные в лямбды.


## Передача нескольких функций (vtable, fat pointer)

Если вашей функции нужно вызывать более одной передаваемой функции,
вы можете использовать ваши существующие знания, чтобы решить эту задачу.
Возможная реализация:

```cpp
using IntroductionFunc = void(*)();
using SumFunc = int(*)(int a, int b);

struct Behavior
{
    IntroductionFunc introduceOneself;
    SumFunc answer;
};

void test(Behavior& behavior)
{
    behavior.introduceOneself();
    int answer = behavior.answer(5, 6);
    std::cout << answer << std::endl;
}

int main()
{
    Behavior dumbCat{
        [](){ std::cout << "Meow" << std::endl; },
        [](int a, int b){ return 0; },
    };
    Behavior smartDog{
        [](){ std::cout << "Woof" << std::endl; },
        [](int a, int b){ return a + b; },
    };
    test(dumbCat); // Meow, 0
    test(smartDog); // Woof, 11

    return 0;
}
```

Несложно представить себе аналогичную реализацию с `std::function`,
которая также позволяла бы захватывать некоторый контекст в каждой функции.

Что делать, если мы хотим, чтобы обе функции
использовали тот же контекст, и мы также хотим динамический полиморфизм
(нам нужно, чтобы функции были либо указателями на функции, либо `std::function`)?
Конечно, могли бы сохранять контекст по отдельности в каждой `std::function`,
но это довольно расточительно.
По итогу где-то хранилась бы память контекста,
но при этом нам пришлось бы хранить указатель на неё в каждой из функций.
Мы могли бы избежать хранения указателей, просто передавая контекст вручную.

Решение, которое позволяет достичь этого, - использование `void*` для контекста.
Конечно, это неуклюжно и опасно, но позволяет осуществить то, что нам нужно.
Мы просто передаем указатель на контекст вместе с указателем на структуру с функциями,
которая также называется *виртуальной таблицей* или *vtable*.
Причина использования указателя на vtable, а не самого vtable,
заключается просто в том, что мы хотим использовать однин и тот же vtable
для нескольких контекстов.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/fat_pointer.cpp).

> По сути, таким образом работает динамический полиморфизм в языке программирования Rust.


## Несколько виртуальных таблиц

Допустим, мы хотели бы иметь несколько виртуальных таблиц.
Допустим, мы хотим использовать одну виртуальную таблицу для приветствий
(методы типа `introduceSelf` при приветствии и `excuseSelf` при уходе),
и другую виртуальную таблицу для вычисления ответов на вопросы
(например, `computeSum` и `writeCppProgram`).

Конечно, мы могли бы сделать это, используя толстые указатели (как в примере выше),
но *виртуальное наследование* в C++ идет другим путем.
Вместо этого они *изменяют указатель*, смещая его на нужную таблицу методов,
а не к началу объекта,
и *хранят смещение к началу данных объекта в виртуальной таблице*,
чтобы иметь доступ к контексту.

См. [пример](../../en/05a_programming_fundamentals/polymorphism/multiple_vtables_cpp_approach.cpp).

Я заставляю вас полностью понять код, но если вы хотите разобраться в теме,
обязательно изучите код.
Вот еще [видео](https://youtu.be/QzJL-8WbpuU), которое мне предложили.

## Чисто абстрактные базовые классы и виртуальные функции

Идея таблицы методов, которую я описал и реализовал ранее,
доступна в качестве примитива в C++.

> Возможно, версия этого в С++ не на 100% совпадает с моей реализацией,
> но она использует очень похожие идеи.

Для определения структуры виртуальной таблицы вы можете определить 
*чисто абстрактный базовый класс* (pure virtual base class)
с *виртуальными* методами,
которым присваивается `0`, что означает "не реализовано".
Другое название для этого - *интерфейс*.

```cpp
class GreetingAbstractBase
{
public:
    virtual void introduceSelf() = 0;
    virtual void excuseSelf() = 0;
};
```

Затем вы можете *унаследоваться* от этого класса в классе с вашим контекстом
и *переопределить* методы.
Это инициализирует виртуальные таблицы и добавляет поле указателя
к каждой из них в вашем *производном* классе (том, который унаследован),
для каждого такого унаследованного базового класса.

```cpp
class Person : 
    public GreetingAbstractBase,
    public QuestionAbstractBase
{
    // ...

    void introduceSelf() override
    {
        // ...
    }

    // ...
}
```

Синтаксис преобразования и синтаксис вызова становятся гораздо проще
-- в конце концов, это языковой примитив.

```cpp
Person person;

Person* personPtr = &person;
GreetingAbstractBase* greetingPtr = personPtr;
QuestionAbstractBase* questionPtr = personPtr;

// Указатели смотрят на разную память.
assert(static_cast<uint8_t*>(greetingsPtr) - static_cast<uint8_t*>(questionPtr) != 0);

// Контекст настраивается и передается неявно.
greetingPtr->introduceSelf();
```

Подход менее гибок по сравнению с толстыми указателями, потому что
он объединяет на данные (контекст) с методами,
но удобен из-за более простого синтаксиса,
поэтому по итогу возможно по любому будете использовать именно его.

В общем случае предпочтительнее использовать `std::function` вместо интерфейсов,
когда вам нужен только один метод.
В противном случае интерфейсы - хороший выбор.
Но, конечно же, прежде чем это делать этот выбор, подумайте,
действительно ли вам нужен динамический полиморфизм.

See [an example](../../en/05a_programming_fundamentals/polymorphism/abstract_base_class.cpp).
