
# Перегрузка операторов (operator overloading)

## Перегрузка оператора присваивания

У нас всё ещё есть большая сложность, которая проявляется опасным образом при копировании в существующую переменную. Смотрите пример [здесь](#Как-легко-сломать-код-выше).

Мы можем исправить эту проблему, переопределив операцию, которую оператор присваивания совершает для нашего типа. Это называется *перегрузкой оператора присваивания*, "оператор присваивания" означает `=` в операции присваивания, а "перегрузка" означает определение функции, которая будет заменять поведение по умолчанию для нашего типа.

```cpp
class Example
{
    int* memory;

public:
    Example(int value)
    {
        this->memory = new int{value};
    }

    ~Example()
    {
        delete this->memory;
    }

    void operator=(const Example& other)
    {
        // Это поведение по умолчанию.
        // Как показано в предыдущем примере,
        // поведение по умолчанию легко может вызвать утечку памяти и повторные free.
        // this->memory = other.memory;

        // Вот то, что нам нужно.
        *this->memory = *other.memory;
    }
};

int main()
{
    Example example1{1};
    Example example2{2};

    // Этот вызов оператора присваивания.
    example2 = example1;

    // `operator=` - это просто имя этого метода,
    // вы также можете вызывать его как обычный метод:
    example2.operator=(example1);

    return 0;
}
```

## Другое решение: запрет на копирование

Вы можете сделать оператор, который определен и доступен к использованию по умолчанию, недоступным, *удалив* метод, отвечающий за этот оператор. Вы делаете это, присвоив ключевое слово `delete` этому методу, вместо предоставления его тела.

```cpp
class Example
{
    // ...

    // Это делает оператор = недоступным.
    void operator=(const Example& other) = delete;
}

int main()
{
    Example example1{1};
    Example example2{2};

    example1 = example2; // ошибка времени компиляции
    return 0;
}
```

Также есть способ явно указать, что мы хотим использовать "поведение по умолчанию" для некоторой функции. Это может быть полезно, если вы хотите вернуть параметрless конструктор, например, не писать тело метода, которое делает то же самое. Вы также можете использовать его для конструктора копирования.

Для этого вы должны назначить ключевое слово `default` этому методу.

> Пример вызовет ошибку во время выполнения и предоставлен для демонстрационных целей.

```cpp
class Example
{
    // ...

    // Разрешить поведение по умолчанию для конструктора без параметров.
    Example() = default;

    // Разрешить поведение по умолчанию для конструктора копирования.
    Example(const Example& other) = default;

    // Чтобы было, давайте явно укажем, что мы хотим,
    // чтобы присваивание имело свое поведение по умолчанию.
    // Тип возвращаемого значения должен быть `Example&` для этого, и объясню почему немного позже.
    Example& operator=(const Example& other) = default;
}

int main()
{
    // Наш пользовательский конструктор.
    Example example1{1};

    // Конструктор без параметров
    Example example2{};

    // Конструктор копирования
    Example example3{example1};

    // Оператор присваивания
    example2 = example1;

    return 0;
}
```

## Перегрузка математических операторов: пример использования `Vector`

Я реализовал структуру Vector с операциями сложения, вычитания и масштабирования.

Одна реализация - процедурная, а другая - с перегрузкой операторов. Смотрите примеры кода [здесь](../../en/05a_programming_fundamentals/vector/procedural.cpp) и [здесь](../../en/05a_programming_fundamentals/vector/operator.cpp).

## Возвращение значений или ссылок из мутирующих операторов

> Под "мутирующими операторами" я имею в виду операторы `=`, `+=`, `-=` и т.д.

Мы можем пойти еще дальше и реализовать операторы `+=` и `-=`. Вы можете выбрать любой тип возвращаемого значения, который вам кажется логичным, но обычно это `void`, `Vector` или `Vector&`. Смотрите [пример](../../en/05a_programming_fundamentals/vector/mutation.cpp).
Мы возвращаем ссылку, чтобы такое было разрешено (хотя это не обязательно):

```cpp
int main()
{
    Vector a{6, 9};
    Vector b{2, 3};
    Vector c{5, 6};

    // Мы можем сделать это в несколько шагов
    a = a + b;
    Vector result = a;
    result = result + c;

    // Или в один шаг
    Vector result = (a += b) + c;
    // Идея в том, что `a += b` возвращает либо значение `a`,
    // либо ссылку на `a`, которая будет результатом `a + b`,
    // то есть новым значением `a` после сложения.

    return 0;
}
```

## Еще один пример: вывод в консоль

Вы, возможно, помните, что C++ использует оператор `<<` (битовый сдвиг влево) для взаимодействия с выходным потоком. Это достигается с использованием `friend` функций, что позволяет им получать доступ к закрытым полям `Vector`.

> `friend` функции являются неявно статическими, то есть у них нет скрытого параметра `this`.

```cpp
#include <iostream>

struct Vector
{
    int x;
    int y;

    // Второй параметр может быть `Vector`, `Vector&` или `const Vector&`.
    // (Фактически вы можете сделать его чем угодно, но это бессмысленно).
    friend std::ostream& operator<<(std::ostream& outputStream, Vector vector)
    {
        outputStream << "(" << vector.x << ", " << vector.y << ")" << std::endl;
        return outputStream;
    }
};

int main()
{
    Vector v{1, 2};
    std::cout << v; // (1, 2)
    return 0;
}
```

Обратите внимание, как перегруженный оператор возвращает ссылку на объект выходного потока. Это позволяет вам использовать оператор `<<` снова сразу после первого. Это называется *fluent interface*; вы можете изучить это самостоятельно.

Например, такой код работает без проблем из-за того, что мы возвращаем ссылку на объект потока:

```cpp
int main()
{
    Vector v1{1, 2};
    Vector v2{5, 6};

    // Это:
    (std::cout << v1) << v2;

    // Эквивалентно этому (вычисляется слева направо):
    std::cout << v1 << v2;

    // Делает то же самое, на самом деле.
    std::cout << v1;
    std::cout << v2;

    return 0;
}
```

`friend` функции немного странны, когда речь идет о разделении объявления от определения:

```cpp
struct Vector
{
    // ...
    // Объявление
    friend std::ostream& operator<<(std::ostream& outputStream, Vector vector);
};

// Определение.
// Вам не нужен оператор разрешения области `::`.
// Фактически, его использование здесь недопустимо.
std::ostream& operator<<(std::ostream& outputStream, Vector vector)
{
    // ...
}
```

`friend` функции позволяют вам разместить логику, связанную с печатью вашего объекта, в вашем классе, а не в классе `std::ostream`. Это полезно, когда вы не можете или есть причина не изменять тип, используемый в качестве первого параметра, то есть вы не можете или не хотите добавить этот оператор как обычный оператор в исходный код класса первого параметра.

В данном случае, конечно, так как `std::ostream` является частью стандартной библиотеки, вы не можете изменить его исходный код. Но даже если бы это было возможно, вы могли бы хотеть, чтобы он имел общую функциональность для вывода текста, не обременяя его конкретной логикой печати вашего конкретного типа. Это позволяет вашему другому типу определить логику печати, основанную на основных операциях, предоставленных `std::ostream`, таких как вывод строк или `int`.

Эта идея тесно связана с инкапсуляцией и обычно называется *separation of concerns*. Следует отметить, что `std::ostream` перегружает оператор `<<` для некоторых основных типов, таких как `const char[N]`, `int`, `float` и т. д., поэтому вы можете использовать `<<` для вывода. И вы можете использовать его fluent образом, потому что он возвращает ссылку на тот же объект потока.
