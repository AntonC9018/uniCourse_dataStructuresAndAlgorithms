## Ссылки (\&)

Ссылка - это по сути указатель, адрес которого
не может быть изменен, и имеет упрощенный синтаксис.

Вы также можете считать его псевдонимом для переменной (адреса в памяти).

```cpp
int main()
{
    int a = 5;
    
    int* pointer = &a;
    int& reference = a;
    
    *pointer = 10; // a = 10
    reference = 15; // a = 15
    
    int b = 20;
    // Нельзя перенаправить `reference` на `b`.
    // Следующий код запишет значение `b` (20) в `a`.
    reference = b; // a = 20
    reference = 10; // a = 10
    
    return 0;
}
```

Ссылки можно передавать в функции.
Они скрытно передадутся как указатели.

```cpp
void foo(int& a)
{
    a = 10;
    a = a + 5;
}

int main()
{
    int a = 5;
    foo(a); // a = 15
    return 0;
}
```

Та же программа, но с использованием указателя:

```cpp
void foo(int* a)
{
    *a = 10;
    *a = *a + 5;
}

int main()
{
    int a = 5;
    foo(&a); // a = 15
    return 0;
}
```

Вы можете применить `&` к ссылке, чтобы получить указатель на переменную.

Ссылка - это более ограниченная версия указателя, отлично подходящая для аргументов функций.
Считается хорошей практикой использовать ссылки вместо указателей при передаче аргументов в функции.


## Методы

Рассмотрим функцию, которая принимает переменную структуры.

> Не беспокойтесь о том, как работает `std::string` пока,
> просто концептуально думайте о ней как о строке.

```cpp
#include <iostream>

struct Person
{
    int age;
    std::string name;
};

void printAge(Person* person)
{
    std::cout << person->age;
}

int main()
{
    Person person;
    person.age = 20;
    person.name = "Джон";
    
    printAge(&person);
    
    return 0;
}
```

### `static` методы

Мы можем преобразовать эту функцию в метод объекта, также называемый методом.
Давайте сначала сделаем его статическим методом, чтобы увидеть, как работает концепция *пространств имен* (namespace).

> Обратите внимание, что методы существуют только в C++ и не в C.

> *Член* означает что-то, объявленное в `struct` или `class`.
> Это может быть как метод, так и поле.

```cpp
#include <iostream>

struct Person
{
    int age;
    std::string name;
    
    // Ключевое слово `static` на самом деле не делает его статическим,
    // оно просто требует вызывать эту функцию с использованием оператора разрешения области видимости (::).
    static void printAge(Person* person)
    {
        std::cout << person->age;
    }
};

int main()
{
    Person person;
    person.age = 20;
    person.name = "John";
    
    // Вот как вызывать статический метод объекта.
    // `Person` здесь пространство имен, а `printAge` - метод.
    // Идея заключается в том, что мы способны ассоциировать операции,
    // выполняемые с объектом `Person`, с пространством имен `Person` этой структуры.
    Person::printAge(&person);
    
    return 0;
}
```

Вы можете разделить объявление от определения, так же, как и с обычными функциями.
Обратите внимание, что нет другого синтаксиса для этого, 
вам придется указать имя структуры в определении.

```cpp
struct Person
{
    int age;
    std::string name;
    
    static void printAge(Person* person);
};

// Можете считать `Person::printAge` именем этой функции.
static void Person::printAge(Person* person)
{
    std::cout << person->age;
}
```

### Экземпляры и объекты

*Экземпляр* (instance) означает память переменной какого-то типа.
Так что в следующем коде:

```cpp
Person person;
```

мы можем сказать, что `person` - это экземпляр типа `Person`.


*Объект* (object) означает значение экземпляра (копия того что содержится в памяти) какого-то типа.
Так что мы можем сказать, что `person` содержит объект типа `Person`.


### Не статические (instance) методы

Теперь давайте сделаем его методом объекта, который не является статическим.
Метод объекта без статического характера имеет более простой синтаксис вызова,
и автоматически передает указатель на экземпляр как первый скрытый параметр с именем `this`.

```cpp
struct Person
{
    int age;
    std::string name;
    
    // Метод объекта.
    void printAge()
    {
        // `this` - это указатель на экземпляр (`Person*`).
        std::cout << this->age;
    }
};

int main()
{
    Person person;
    person.age = 20;
    person.name = "John";
    
    // Вот как вызывать метод объекта.
    // Компилятор автоматически передает указатель на экземпляр как первый параметр.
    person.printAge();
    
    return 0;
}
```

Это позволяет нам объединить функциональность с типом данных
и получить семантику "объект.глагол".


> `this->` можно не указывать.

```cpp
struct Person
{
    // ...
    void printAge()
    {
        // `age` ссылается на `this->age`.
        std::cout << age;
    }
};
```
Вы можете разделить определение от объявления так же, как с методами объекта.


## Доступность (accessibility) и `class`

По умолчанию, все члены структуры являются `public`.
Это означает, что они могут быть доступны в экземпляре структуры.
Вы можете сделать их явно `private`, чтобы запретить доступ.

Сначала это может показаться абсолютно бесполезным. 
В чем смысл запрета доступа к некоторой памяти?
Одна из идей заключается в том, чтобы ограничить способы доступа
и изменения данных, чтобы стало очевидным, какой из них является правильным, используя методы.

Это не есть что-то уникальное для ООП, это возможно и на уровне модуля, путем объявления функции как `static`.
(видимые только внутри компиляционной единицы, в которой они были определены).
Однако *модификаторы доступности* являются исключительно ООП фичей.

```cpp
struct Person
{
private:
    int age;
    std::string name;

public:
    void setAge(int age)
    {
        this->age = age;
    }

    void printAge()
    {
        std::cout << this->age;
    }

    void printName()
    {
        std::cout << this->name;
    }
};

int main()
{
    Person person;
    person.age = 15; // ошибка компиляции: невозможно получить доступ к закрытому полю.
    person.name = "John"; // та же ошибка

    person.setAge(15); // компилируется
    person.printAge(); // компилируется
    person.printName(); // компилируется

    return 0;
}
```

Вы можете сделать некоторые поля `private`, а другие - `public`.

```cpp
struct Person
{
private:
    int age;

public:
    std::string name;
}

int main()
{
    Person person;
    person.age = 10; // ошибка компиляции: невозможно получить доступ к закрытому полю.
    person.name = "John"; // работает
    return 0;
}
```


### `class`

`class` эквивалентен `struct`, единственное различие
заключается в том, что у него есть неявное `private:` в начале.
Таким образом, все члены по умолчанию являются публичными в `struct`, но приватными в `class`.

> `class` - это ключевое слово, которое обычно используется в контексте ООП.
> Считается хорошим тоном использовать `class` вместо `struct`, если вы объявляете методы,
> которые инкапсулируют (предоставляют конкретные способы доступа) данные (поля).

```cpp
struct Person
{
private:
    int age;
    std::string name;
}

// эквивалентно

class Person
{
    int age;
    std::string name;
}

// и наоборот ...

class Person
{
public:
    int age;
    std::string name;
}

// эквивалентно

struct Person
{
    int age;
    std::string name;
}
```

## Области видимости (scope)

В C++ области видимости выполняют две функции:
- Они служат для того, чтобы переменные не были видны за их пределами;
- Они используются для очистки памяти ("ресурсов") объектов.
  Это можно сделать с помощью деструкторов.

Можно сказать, что области видимости позволяют вам контролировать время жизни объектов.

### Области видимости для ограничения видимости

Области видимости создаются с использованием `{ ... }`.

```cpp
int main()
{
    int a = 1;

    {
        int b = 2;
        a = 5; // разрешено, `a` видна во внешней области видимости
        b = 10; // разрешено, `b` видна в текущей области видимости
    }

    b = 10; // не разрешено, `b` не видна, потому что ее область видимости завершилась 
            // (фигурная скобка была закрыта).

    a = 15; // все еще разрешено, потому что она видна в текущей области видимости

    return 0;
}
```

Функции должны определять область видимости для своего тела.


Вы можете переопределять переменные с тем же именем, если они находятся в разных областях видимости.
Не гарантируется, будут ли они указывать на одну и ту же память.

```cpp
int main()
{
    int a = 5;

    // Повторное объявление переменной в той же области видимости не разрешено.
    // int a;

    {
        // Повторное объявление здесь также не разрешено.
        // int a;

        int b = 10;
    }

    {
        // Это разрешено, потому что области видимости не взаимодействуют.
        int b = 20;

        {
            // Это было бы запрещено.
            // int b = 30;
        }
    }

    return 0;
}
```

Область видимости внутри другой области видимости называется *вложенной областью видимости*.
Вы можете *вкладывать* области видимости неограниченное количество раз.

> В целом, помещение одних вещей внутри других вещей того же вида называется *вложением* (nesting).

Существует также концепция глобальной области видимости,
которая представляет собой область видимости, находящуюся вне любой функции.


### Области видимости для очистки ресурсов

Концептуально переменная, объявленная в области видимости, уничтожается в конце области видимости.
Для простых типов, таких как `int`, это в буквальном смысле ничего не означает.
Для сложного типа, такого как `std::string`, это означает
возвращение памяти, выделенной для массива символов, C++ рантайму.


### Деструктор (destructor)

Вы можете определить свою собственную логику, которая будет вызываться при уничтожении вашего объекта с помощью *деструктора*.
Деструктор - это специальная `void` функция, которая автоматически вызывается в этом контексте.
Вы также можете вызывать его вручную.

Давайте просто покажем, как это работает.

```cpp
#include <iostream>

struct Demo
{
    int i;

    // Это деструктор
    ~Demo()
    {
        std::cout << "Destroying demo " << this->i << std::endl;
    }
};

int main()
{
    Demo demo1{1};
    Demo demo2{2};
    std::cout << "Demos created" << std::endl;

    return 0;

    // Компилятор неявно добавляет следующее:
    // `demo2.~Demo();`
    // `demo1.~Demo();`
}
```

Что выводит:

```
Demos created
Destroying demo 2
Destroying demo 1
```

> Вы можете разделять объявление деструктора и его определение
> так же, как и с обычными методами.

Обратите внимание, что деструктор будет вызван только в этом контексте.
Если вы перезначите переменную, он не будет вызван для объекта, уже находящегося в этой памяти.

```cpp
int main()
{
    Demo demo1{1};
    Demo demo2{2};
    demo2 = demo1; // Это копирует байты объекта, но не вызывает деструктор `demo2`.

    return 0;

    // `demo2.~Demo()` выполняется, выводя "Destroying demo 1"
    // `demo1.~Demo()` выполняется, выводя "Destroying demo 1"
}
```

> Чтобы убедиться, что один и тот же объект не удаляется более одного раза
> в этой ситуации, нам придется перегрузить оператор присваивания.


### Неявные деструкторы (implicit destructors)

Предположим, у вас есть структура с полем, тип которого имеет деструктор.

```cpp
#include <iostream>

struct Test
{
    ~Test()
    {
        std::cout << "Test destroyed" << std::endl;
    }
};

struct Person
{
    Test test;
};

int main()
{
    Person person;
    person.test = {};
    return 0;

    // Компилятор автоматически вызывает деструктор для каждого поля.
    // `person.test.~Test();`

    // Он также удалит временный объект, используемый для присваивания,
    // но это объясняется более подробно позже.
}
```

## Конструкторы (Constructors)

Конструкторы - это специальные `void` функции, используемые для инициализации объектов.
Конструкторы не могут быть вызваны в каком бы то ни было другом контексте.

Конструкторы были созданы для инициализации приватных данных (полей) в ООП.
Конструкторы могут быть более сложными, но, как правило, не рекомендуется делать их сложными.

### Конструкторы, используемые для инициализации новых объектов

> Если они начинают выходить из-под контроля в плане сложности,
> вы можете перейти к использованию фабричных функций.

Например, давайте определим конструктор без параметров (конструктор по умолчанию),
который выводит информацию на консоль.

```cpp
#include <iostream>

class Demo
{
    int memory;

public:
    Demo()
    {
        // memory будет не инициализирована на этом этапе (содержать мусор).
        std::cout << "Created " << this->memory << std::endl;
        this->memory = 5;
    }

    ~Demo()
    {
        // memory равна 5 на этом этапе.
        std::cout << "Destroyed " << this->memory << std::endl;
    }
};

int main()
{
    {
        // Это фактически вызывает конструктор без параметров.
        // Дизайнеры C++ решили, что объекты никогда не должны оставаться неинициализированными.
        Demo demo;

        // Компилятор неявно добавил:
        // demo.~Demo();
    }

    {
        // Явно вызывает конструктор без параметров.
        Demo demo{};

        // Эквивалентный синтаксис:
        // Demo demo = Demo();

        // Компилятор неявно добавил:
        // demo.~Demo();
    }

    return 0;
}
```

Практическим использованием может быть, например, выделение памяти и очистка ее в деструкторе.
Мы можем сделать это, используя операторы `new` и `delete`.

```cpp
#include <iostream>
#include <assert.h>

class Buffer
{
// private:
    size_t length;
    int* firstElement;

public:
    Buffer(size_t elementCount) 
        // Вписывает `elementCount` в `length` напрямую, до того, как наш код будет запущен.
        // Это называется инициализатором членов.
        : length(elementCount) //, anotherField(8)
    {
        // `firstElement` содержит мусор здесь.

        // Нам нужно выделить память, которая не будет читаемой в инициализаторе.
        // Поэтому я решил написать это в теле конструктора.
        this->firstElement = new int[elementCount];

        // Элементы изначально не инициализированы.
    }

    ~Buffer()
    {
        delete[] firstElement;
    }

    int& elementAt(size_t index)
    {
        assert(index < this->length);
        return firstElement[index];
    }
};

int main()
{
    Buffer buffer{5};

    // Печатает мусор.
    std::cout << buffer.elementAt(0) << std::endl;

    // Do some stuff with the buffer.
    // Выполняем некоторые действия с буфером.
    int& secondElement = buffer.elementAt(1);
    secondElement = 10;

    return 0;

    // Компилятор неявно добавил следующее:
    // buffer.~Buffer();
}
```

### Как легко сломать код выше

Все равно очень легко сломать код выше и получить утечку памяти или повторные удаления памяти:

```cpp
int main()
{
    Buffer buffer1{10};
    Buffer buffer2{20};
    // Это делает копирование по полям.
    buffer2 = buffer1;
    return 0;

    // buffer длиной 20 никогда не освобождается
    // buffer длиной 10 удаляется дважды (ошибка во время выполнения)
}
```

### Конструкторы копирования (copy constructor)

Вы можете определить конструктор, который принимает ссылку на объект,
который будет вызван при копировании.
Это включает в себя обычные определения с использованием `{ }` или определения с немедленным присваиванием.

```cpp
#include <iostream>

class Demo
{
    int id;

public:
    // Необходим конструктор с параметрами, чтобы вообще создать объект.
    Demo(int idParameter) : id(idParameter) { }

    // Demo(const Demo& other)
    Demo(Demo& other) : id(other.id)
    {
        std::cout << "Copying " << other.id << std::endl;
    }
};

int main()
{
    Demo a{1};

    // Вызывает конструктор копирования.
    Demo b{a};

    // Также вызывает конструктор копирования.
    Demo c = a;

    // Это НЕ вызывает конструктор копирования.
    // Он просто копирует поля.
    b = c; 
}
```

### Перемещение объекта (move semantics)

Перемещение объекта в другой объект позволяет одному объекту украсть ресурсы другого.
Это часто используется при создании объектов
или записи значений в поля, чтобы избежать вызова конструктора копирования.

Рассмотрим следующий пример, который создает 2 копии `std::string`:

```cpp
struct Person
{
    std::string name;
};

int main()
{
    // Вызывает конструктор `std::string`, который копирует символы в динамически выделенный буфер.
    std::string name = "John Brown";

    Person person;

    // Выделяет копию `name`, выделяя другой буфер и копируя символы.
    // Затем он записывает эту копию в `person.name`.
    person.name = name;

    return 0;

    // The compiler implicitly adds the following:
    // Компилятор неявно добавляет следующее:
    // `person.name~string();` (из неявного деструктора Person, который удаляет все поля)
    // `name.~string();`
}
```

Итак, мы перемещаем `name` в `person.name`, а не копируем его.
В данном случае это означает, по сути, копирование объекта строки в `person.name`,
а затем его очистку из переменной `name`, чтобы она больше не ссылается на буфер.
Таким образом, она становится непригодной к использованию после этого вызова.

```cpp
#include <iostream>

struct Person
{
    std::string name;
};

int main()
{
    std::string name = "John Brown";
    Person person;

    std::cout << name << std::endl; // John Brown
    std::cout << person.name << std::endl; // 

    person.name = std::move(name);

    std::cout << name << std::endl; // 
    std::cout << person.name << std::endl; // John Brown

    return 0;
}
```

### Конструкторы перемещения (move constructors)

В общем случае вы можете определить конструкторы, принимающие *rvalue-ссылки* (\&\&, rvalue-reference).
Это означает ссылка, из которой нужно красть ресурсы.

> Не зацикливайтесь на деталях, я объясню, что такое rvalue-ссылки позже.

> Вы можете использовать rvalue-ссылки как обычные параметры тоже.

```cpp
#include <iostream>

class Demo
{
    int* memoryPointer;

    int getValue()
    {
        if (memoryPointer == nullptr)
            return 0;
        return *memoryPointer;
    }

public:
    Demo(int value)
    {
        // Выделяет int на куче (просто для демонстрации, я знаю, что это бессмысленно),
        // и сохраняет указатель на него в `memoryPointer`.
        this->memoryPointer = new int{value};
    }

    ~Demo()
    {
        std::cout << "Destructor called for " << this->getValue() << std::endl;
        // Освобождает память (удаление nullptr разрешено).
        delete this->memoryPointer;
    }

    // Конструктор перемещения
    Demo(Demo&& other)
    {
        std::cout 
            << "Move constructor called for "
            << other.getValue()
            << std::endl;

        // Крадем указатель из другого объекта.
        this->memoryPointer = other.memoryPointer;

        // Очищаем указатель из другого объекта.
        // `nullptr` то же самое, что и `0`, он просто обнуляет его.
        other.memoryPointer = nullptr;
    }
};

int main()
{
    Demo demo1{1};
    Demo demo2{2};

    // Это вызывает конструктор перемещения.
    Demo demo3 = std::move(demo1);

    return 0;

    // Компилятор неявно добавляет следующее:
    // demo3.~Demo(); (очищает память с 1)
    // demo2.~Demo(); (очищает память с 2)
    // demo1.~Demo(); (ничего не делает)
}
```

### Оптимизация возврата значения (RVO, Return Value Optimization)

Если вы возвращаете объект из функции, его деструктор не будет вызван.
Фактически, конструктор перемещения тоже не будет вызван.
Он просто напрямую записывает результат в память переменной, объявленной для результата.

### Оптимизация возвращаемого значения (Return Value Optimization, RVO)

Если вы возвращаете объект из функции, его деструктор не будет вызван.
Фактически, конструктор перемещения (move constructor) также не будет вызван.
Результат будет напрямую записан в память переменной, объявленной для результата.

> Я не описал, как фактически работает возвращение объектов из функций,
> но это потому, что сам не знаю точных механизмов.
>
> Он может быть возвращен в одном или нескольких регистрах, а затем скопирован в переменную на стеке,
> или функция может использовать скрытый "выходной" адрес, куда будет записан результат.
> Я не знаю, в какой ситуации компилятор использует ту или иную реализацию,
> и есть ли более умные способы сделать это.
>
> Если вы знаете или хотите узнать больше, я был бы признателен, если бы вы сделали запрос на изменение (Pull Request) с кратким объяснением,
> или предоставили ссылки на ресурсы.

```cpp
Demo test()
{
    Demo demo1{1};
    Demo demo2{2};
    return demo1;

    // `demo2.~Demo();` вставлен компилятором, как обычно.
    // Вызов деструктора для `demo1` НЕ вставляется здесь.
}

int main()
{
    // Компилятор может реализовать это, передавая `test` скрытый указатель на локальную переменную `demo`,
    // и предоставив эту память локальной переменной `demo1` внутри `test`,
    // таким образом, память `demo1` фактически не хранится в стековом кадре `test`.
    // Вы можете представлять себе, что `demo1` является ссылкой на `demo`.
    // Обратите внимание, что это не обязательно то, что будет делать компилятор,
    // это только один из способов реализации этого поведения.
    Demo demo = test();
    return 0;

    // `demo.~Demo();` вставлен компилятором, как обычно.
}
```

RVO - это то почему *не следует перемещать объекты из функций*.

```cpp
Demo test()
{
    Demo demo{1};
    // НЕ Делайте это, это приведет к дополнительному копированию.
    // Это вызовет конструктор перемещения в выходной памяти,
    // а также вызовет деструктор локальной переменной `demo` в конце функции.
    return std::move(demo);
}
```

## Перегрузка операторов (operator overloading)

### Перегрузка оператора присваивания

У нас всё ещё есть большая сложность, которая проявляется опасным образом при копировании в существующую переменную. Смотрите пример [здесь](#Как-легко-сломать-код-выше).

Мы можем исправить эту проблему, переопределив операцию, которую оператор присваивания совершает для нашего типа. Это называется *перегрузкой оператора присваивания*, "оператор присваивания" означает `=` в операции присваивания, а "перегрузка" означает определение функции, которая будет заменять поведение по умолчанию для нашего типа.

```cpp
class Example
{
    int* memory;

public:
    Example(int value)
    {
        this->memory = new int{value};
    }

    ~Example()
    {
        delete this->memory;
    }

    void operator=(const Example& other)
    {
        // Это поведение по умолчанию.
        // Как показано в предыдущем примере,
        // поведение по умолчанию легко может вызвать утечку памяти и повторные free.
        // this->memory = other.memory;

        // Вот то, что нам нужно.
        *this->memory = *other.memory;
    }
};

int main()
{
    Example example1{1};
    Example example2{2};

    // Этот вызов оператора присваивания.
    example2 = example1;

    // `operator=` - это просто имя этого метода,
    // вы также можете вызывать его как обычный метод:
    example2.operator=(example1);

    return 0;
}
```

### Другое решение: запрет на копирование

Вы можете сделать оператор, который определен и доступен к использованию по умолчанию, недоступным, *удалив* метод, отвечающий за этот оператор. Вы делаете это, присвоив ключевое слово `delete` этому методу, вместо предоставления его тела.

```cpp
class Example
{
    // ...

    // Это делает оператор = недоступным.
    void operator=(const Example& other) = delete;
}

int main()
{
    Example example1{1};
    Example example2{2};

    example1 = example2; // ошибка времени компиляции
    return 0;
}
```

Также есть способ явно указать, что мы хотим использовать "поведение по умолчанию" для некоторой функции. Это может быть полезно, если вы хотите вернуть параметрless конструктор, например, не писать тело метода, которое делает то же самое. Вы также можете использовать его для конструктора копирования.

Для этого вы должны назначить ключевое слово `default` этому методу.

> Пример вызовет ошибку во время выполнения и предоставлен для демонстрационных целей.

```cpp
class Example
{
    // ...

    // Разрешить поведение по умолчанию для конструктора без параметров.
    Example() = default;

    // Разрешить поведение по умолчанию для конструктора копирования.
    Example(const Example& other) = default;

    // Чтобы было, давайте явно укажем, что мы хотим,
    // чтобы присваивание имело свое поведение по умолчанию.
    // Тип возвращаемого значения должен быть `Example&` для этого, и объясню почему немного позже.
    Example& operator=(const Example& other) = default;
}

int main()
{
    // Наш пользовательский конструктор.
    Example example1{1};

    // Конструктор без параметров
    Example example2{};

    // Конструктор копирования
    Example example3{example1};

    // Оператор присваивания
    example2 = example1;

    return 0;
}
```

### Перегрузка математических операторов: пример использования `Vector`

Я реализовал структуру Vector с операциями сложения, вычитания и масштабирования.

Одна реализация - процедурная, а другая - с перегрузкой операторов. Смотрите примеры кода [здесь](../../en/05a_programming_fundamentals/vector/procedural.cpp) и [здесь](../../en/05a_programming_fundamentals/vector/operator.cpp).

### Возвращение значений или ссылок из мутирующих операторов

> Под "мутирующими операторами" я имею в виду операторы `=`, `+=`, `-=` и т.д.

Мы можем пойти еще дальше и реализовать операторы `+=` и `-=`. Вы можете выбрать любой тип возвращаемого значения, который вам кажется логичным, но обычно это `void`, `Vector` или `Vector&`. Смотрите [пример](../../en/05a_programming_fundamentals/vector/mutation.cpp).
Мы возвращаем ссылку, чтобы такое было разрешено (хотя это не обязательно):

```cpp
int main()
{
    Vector a{6, 9};
    Vector b{2, 3};
    Vector c{5, 6};

    // Мы можем сделать это в несколько шагов
    a = a + b;
    Vector result = a;
    result = result + c;

    // Или в один шаг
    Vector result = (a += b) + c;
    // Идея в том, что `a += b` возвращает либо значение `a`,
    // либо ссылку на `a`, которая будет результатом `a + b`,
    // то есть новым значением `a` после сложения.

    return 0;
}
```

### Еще один пример: вывод в консоль

Вы, возможно, помните, что C++ использует оператор `<<` (битовый сдвиг влево) для взаимодействия с выходным потоком. Это достигается с использованием `friend` функций, что позволяет им получать доступ к закрытым полям `Vector`.

> `friend` функции являются неявно статическими, то есть у них нет скрытого параметра `this`.

```cpp
#include <iostream>

struct Vector
{
    int x;
    int y;

    // Второй параметр может быть `Vector`, `Vector&` или `const Vector&`.
    // (Фактически вы можете сделать его чем угодно, но это бессмысленно).
    friend std::ostream& operator<<(std::ostream& outputStream, Vector vector)
    {
        outputStream << "(" << vector.x << ", " << vector.y << ")" << std::endl;
        return outputStream;
    }
};

int main()
{
    Vector v{1, 2};
    std::cout << v; // (1, 2)
    return 0;
}
```

Обратите внимание, как перегруженный оператор возвращает ссылку на объект выходного потока. Это позволяет вам использовать оператор `<<` снова сразу после первого. Это называется *fluent interface*; вы можете изучить это самостоятельно.

Например, такой код работает без проблем из-за того, что мы возвращаем ссылку на объект потока:

```cpp
int main()
{
    Vector v1{1, 2};
    Vector v2{5, 6};

    // Это:
    (std::cout << v1) << v2;

    // Эквивалентно этому (вычисляется слева направо):
    std::cout << v1 << v2;

    // Делает то же самое, на самом деле.
    std::cout << v1;
    std::cout << v2;

    return 0;
}
```

`friend` функции немного странны, когда речь идет о разделении объявления от определения:

```cpp
struct Vector
{
    // ...
    // Объявление
    friend std::ostream& operator<<(std::ostream& outputStream, Vector vector);
};

// Определение.
// Вам не нужен оператор разрешения области `::`.
// Фактически, его использование здесь недопустимо.
std::ostream& operator<<(std::ostream& outputStream, Vector vector)
{
    // ...
}
```

`friend` функции позволяют вам разместить логику, связанную с печатью вашего объекта, в вашем классе, а не в классе `std::ostream`. Это полезно, когда вы не можете или есть причина не изменять тип, используемый в качестве первого параметра, то есть вы не можете или не хотите добавить этот оператор как обычный оператор в исходный код класса первого параметра.

В данном случае, конечно, так как `std::ostream` является частью стандартной библиотеки, вы не можете изменить его исходный код. Но даже если бы это было возможно, вы могли бы хотеть, чтобы он имел общую функциональность для вывода текста, не обременяя его конкретной логикой печати вашего конкретного типа. Это позволяет вашему другому типу определить логику печати, основанную на основных операциях, предоставленных `std::ostream`, таких как вывод строк или `int`.

Эта идея тесно связана с инкапсуляцией и обычно называется *separation of concerns*. Следует отметить, что `std::ostream` перегружает оператор `<<` для некоторых основных типов, таких как `const char[N]`, `int`, `float` и т. д., поэтому вы можете использовать `<<` для вывода. И вы можете использовать его fluent образом, потому что он возвращает ссылку на тот же объект потока.

## Абстракция и Инкапсуляция

### Файлы реализации (cpp)

Давайте уточним некоторые моменты, связанные с файлами реализации (файлами `cpp`).
Файлы `cpp` обычно содержат *определения функций и/или глобальных переменных*.
Они могут предоставлять эти функции для использования в других единицах компиляции (в других `cpp` файлах),
но также могут определять `static` функции и глобальные переменные,
которые могут использоваться в качестве вспомогательных внутри предоставленных функций, то есть для реализации логики предоставленных функций.

Что, по вашему мнению, произойдет, если `cpp` файл будет включен в компиляцию дважды?
Предположим, что мы скомпилировали два файла `main.cpp` и `f.cpp` с командой `zig c++ main.cpp f.cpp`, где файлы имеют следующее содержание:

`main.cpp`:

```cpp
#include "f.cpp"

int main()
{
    f(1);
    return 0;
}
```

`f.cpp`:

```cpp
void f(int a)
{
}
```

Это вызовет ошибку связывания (linker error),
потому что функция `f` была определена дважды:
один раз в `main.cpp` (из-за включения содержимого `f.cpp`),
и второй раз в `f.cpp` (потому что мы также компилируем этот файл).

Это по факту означает, что *каждый файл реализации можно компилировать не более одного раза*.

### Общие объявления

Что делать, если мы хотим использовать одну и ту же функцию `f` в нескольких разных файлах?
Просто объявите ее во всех этих файлах, а затем свяжите их с реализацией.
> См. [пример 1](../../en/05a_programming_fundamentals/headers/example_1)

Проблема заключается в том, что теперь, если мы захотим изменить, например, тип параметра `f`
с `int` на `float`, нам придется:
- Изменить файл реализации,
- Изменить объявление `f` в `main.cpp`,
- Изменить объявление `f` в `other_file.cpp`.

И если у нас было бы больше файлов, нам пришлось бы делать это во всех них.

Чтобы избежать необходимости изменять объявление в каждом файле, 
люди обычно выносят объявление в отдельный файл и подключают его в файлах, где оно нужно с помощью директивы `#include`.
Файлы, содержащие такие объявления, называются заголовочными файлами (header files).
Конечно, определение по-прежнему должно быть изменено отдельно.
> См. [пример 2](../../en/05a_programming_fundamentals/headers/example_2)

Если определение функции очевидно и небольшое, как, например, возврат какой-то константы, 
обычно это *определение* размещается непосредственно в заголовочном файле.
Теперь, если бы мы сделали это, у нас возникла бы та же проблема, что и в [предыдущем абзаце](#Файлы-реализации-(cpp)).
Вспомните модификатор `inline`, который делает так, что функция не участвует в связывании и не появляется в конечном исполняемом файле.
Для этой цели идеально подходит `inline`.
Фактически, если все функции можно сделать встроенными (inline), 
нам даже не потребуется файл реализации.
> См. [пример 3](../../en/05a_programming_fundamentals/headers/example_3)

Другой способ избежать ошибок связывания заключается в том, чтобы сделать все функции `статическими`.
Это обычно не рекомендуется, потому что исполняемый файл будет включать их определения столько раз, сколько будет импортирован заголовочный файл.

### Интерфейс

*Модуль* может быть определен как пара файлов: заголовочного и реализации.
Здесь видно, что заголовочный файл, содержащий объявления, эффективно задает *публичный интерфейс модуля*, 
в то время как файл реализации задает *реализацию* интерфейса.

*Абстракция* означает, что вы взаимодействуете с модулем только через его публичный интерфейс.
*Инкапсуляция* означает, что вы можете взаимодействовать с модулем как с целым, 
не имея необходимости понимать, как он реализован и какие данные он использует под капотом.

Вопреки общему мнению, ООП не изобрело ни одного из этих принципов.
Вы можете использовать эти принципы без использования классов.
ООП просто добавляет более детализированную инкапсуляцию на уровне *класса*, 
в виде системы доступности (публичные - приватные члены), и более 
детализированную абстракцию на уровне класса через виртуальные методы (описанные позже?).

Итак, ООП позволяет использовать эти два концепта как на уровне *модуля, так и на уровне класса*,
в то время как обычное процедурное программирование позволяет это *только на уровне модуля*.

### Избегание дублирования объявлений

> TODO: этот пример как бы немного "кривой", потому что предполагается, что несколько объявлений не допускаются.

Предположим, у нас есть код, похожий на следующий:

```cpp
void f(int a);
void f(int a);
void f(int a)
{
    std::cout << a;
}
```

Может быть нежелательно иметь несколько объявлений одной и той же функции.
Теперь предположим ситуацию, когда `main.cpp` включает в себя `a.h` и `b.h`,
а `b.h` также включает `a.h`.
Это означает, что `a.h` был включен дважды.
Если `a.h` объявлял какие-либо функции, наша программа будет включать эти объявления несколько раз.

Это можно избежать с помощью директивы `#pragma once`, которая указывает препроцессору
включать файл только один раз.
Если добавить эту директиву в `a.h`, он будет включен только в `main.cpp`,
а `b.h` пропустит его импорт.
Теперь `b.h` все равно увидит объявления из `a.h`,
потому что он расположен после того, как `a.h` уже был включен в `main.cpp`.

У нас есть очень похожая ситуация в [примере с `inline`](../../en/05a_programming_fundamentals/headers/example_3).
Если вы удалите `#pragma once` из `f.h`, то код не скомпилируется.

### Круговые включения (circular includes)

Их не допускают, потому что файлы всегда включаются последовательно.

### Приватные поля

Как я уже упоминал ранее, типичное процедурное программирование не позволяет
инкапсуляцию на уровне класса (структуры), а только на уровне модуля.
Это означает, что *данные в структурах, которые интерфейс ожидает, что пользователи передадут, могут быть изменены пользователем*.

Пример: предположим, у нас есть тип, представляющий динамически выделяемый буфер фиксированного размера.
Код может выглядеть примерно так:

```cpp
struct DynamicBuffer
{
    int* firstItemPointer;
    size_t length;
}

DynamicBuffer createBuffer(size_t length)
{
    int* pointer = new int[length];
    return {pointer, length};
}

void setItem(DynamicBuffer* buffer, size_t index, int value)
{
    assert(index < buffer->length);
    buffer->firstItemPointer[index] = value;
}

void destroyBuffer(DynamicBuffer* buffer)
{
    delete[] buffer->firstItemPointer;
};
```

Поскольку нет инкапсуляции данных на уровне класса (структуры),
следующий код скомпилируется, но вызовет ошибку во время выполнения.

```cpp
int main()
{
    DynamicBuffer buffer = createBuffer(10);
    buffer.firstItemPointer = 0; // ничто не мешает нам сделать это.
    setItem(&buffer, 0, 5); // ошибка выполнения: access violation
    return 0;
}
```

Конечно, здесь явно видно, что так делать неправильно,
потому что это нарушает внутреннее состояние буфера,
но компилятор все равно разрешит это без проблем.
Идея с доступностью данных заключается в возможности явно запретить это.

```cpp
class DynamicBuffer
{
    // Приватные данные
    int* _firstElementPointer;
    size_t _length;

public:
    // Мы все равно хотим *читать* эти данные,
    // но не *перезаписывать* их напрямую.
    // Поэтому мы можем определить *свойства* для этого.
    // Свойства - это методы, возвращающие или устанавливающие значения полей.
    // Обратите внимание, что я назвал поля с символом подчеркивания, чтобы избежать
    // столкновений имен со свойствами.
    int* firstElementPointer()
    {
        return this->_firstElementPointer;
    }

    size_t length()
    {
        return this->_length;
    }

    DynamicBuffer(size_t length) : _length(length)
    {
        this->_firstElementPointer = new int[length];
    }

    ~DynamicBuffer()
    {
        delete[] this->_firstElementPointer;
    }

    void setItem(size_t index, int value)
    {
        assert(index < this->_length);
        this->_firstElementPointer[index] = value;
    }
};
```

```cpp
int main()
{
    DynamicBuffer buffer{10};
    buffer._firstElementPointer = 0; // не компилируется
    int* firstElement = buffer.firstElementPointer(); // все равно можно *читать* значение
    return 0;
}
```

Но это также не позволяет определять дополнительные операции,
которых нет в классе `DynamicBuffer` и которые должны работать с его закрытым состоянием.
Поэтому следующий код в версии ООП не будет работать:

```cpp
int resize(DynamicBuffer& buffer, size_t newSize)
{
    if (buffer.length() < newSize)
    {
        buffer._length = newSize;
    }
    else
    {
        int* newBufferPointer = new int[newSize];
        for (size_t i = 0; i < buffer.length(); i++)
            newBufferPointer[i] = buffer.firstElementPointer()[i];
        delete[] buffer.firstElementPointer();
        buffer._firstElementPointer = newBufferPointer;
    }
}
```

Но эквивалентная процедурная версия будет работать без проблем.

> Возможно это можно обойти с помощью функций `friend`, но обычно такое решение не ожидается.

### Приватные члены в заголовочном файле

Должно быть довольно очевидно, почему поля должны находиться в заголовочном файле.
Это потому, что для определения размера класса требуется знание этих полей,
и вы должны знать размер класса, потому что вы
*управляете памятью, где будет храниться объект*.

Однако приватные *методы* помещаются в заголовочный файл только для того, чтобы можно было обойти
проблему инкапсуляции: нельзя определить статические функции в файле реализации, имея при этом доступ к приватным полям класса, поэтому вы вынуждены делать
их известными пользователю в объявлении (в заголовочном файле).

`buffer.h` содержит объявление класса (конструкторы и прочее опущено):

```cpp
class DynamicArray
{
    int* pointer;
    size_t count;
    size_t capacity;

public:
    void addItem(int item);

private:
    void ensureCapacity(size_t newMinimumSize);
};
```

`buffer.cpp` содержит определения:

```cpp
void DynamicArray::addItem(int item)
{
    this->ensureCapacity(this->count + 1);
    this->pointer[this->count] = item;
    this->count++;
}

void DynamicArray::ensureCapacity(size_t newMinimumSize)
{
    if (this->capacity >= newMinimumSize)
        return;

    int* oldMemory = this->pointer;
    size_t newSize = std::max(newMinimumSize, this->capacity * 2);
    int* newMemory = new int[newSize];
    for (size_t i = 0; i < this->count; i++)
        newMemory[i] = oldMemory[i];
    this->pointer = newMemory;
    delete[] oldMemory;
}
```

Однако это противоречит идее того, что заголовочный файл
*должен содержать только публичный интерфейс, обеспечивая инкапсуляцию на уровне модуля*.
Идеально было бы, чтобы приватная функция *не существовала в заголовочном файле*,
поскольку она используется только внутри модуля и является деталью реализации.
Нет никакой причины, почему она должна оставаться в заголовке.

Если бы мы попытались просто сделать ее `static` и использовать ее в файле реализации, то:

`buffer.h`:

```cpp
class DynamicArray
{
    int* pointer;
    size_t count;
    size_t capacity;

public:
    void addItem(int item);

    // Нет приватных методов...
};
```

`buffer.cpp`:

```cpp
void DynamicArray::addItem(int item)
{
    ensureCapacity(this, this->count + 1);
}

// статическая функция, поэтому видна и используется только внутри данной едице компиляции.
static void ensureCapacity(DynamicArray* self, size_t newMinimumSize)
{
    // Не удается получить доступ к self->capacity, потому что это приватное поле.
    if (self->capacity >= newMinimumSize)
        return;

    // ...
}
```

Это, конечно, не будет работать из-за правил доступности.

Вы можете обойти это, используя факт, что
*типы, для которых вы не выделяете память или не определяете размер, не обязаны объявлять свои поля*,
в сочетании с тем, что *типы можно использовать как пространства имен* 
и *имеют доступ к приватным членам содержащего типа*.
Подробное объяснение можно найти [здесь](https://stackoverflow.com/questions/28334485/do-c-private-functions-really-need-to-be-in-the-header-file).

Итак, вы можете достичь желаемого поведения статической функции следующим образом:

```cpp
class DynamicArray
{
    // ... поля
public:
    void addItem(int item);

private:
    // Это называется *forward declaration*.
    struct Impl;
};
```

```cpp
// Делаем структуру статической, и все методы становятся статическими (internal linkage).
static struct DynamicArray::Impl
{
    // Не требуется экземпляр.
    // `static` здесь не означает внутреннюю связь,
    // это означает отсутствие неявного параметра `this`.
    static void ensureCapacity(DynamicArray* self, size_t newMaximumSize)
    {
        // Теперь это работает, потому что фактически находимся внутри DynamicArray.
        if (self->capacity >= newMaximumSize)
            return;
        
        // ...
    }
}

void DynamicArray::addItem(int item)
{
    DynamicArray::Impl::ensureCapacity(this, this->count + 1);
    // или так
    // Impl::ensureCapacity(this, this->count + 1);
    // потому что технически уже находимся в области видимости DynamicArray.

    this->pointer[this->count] = item;
    this->count++;
}
```

## `template`

`template` - это базовый примитив языка C++, который, вместе с механизмом перегрузки функций, позволяет реализовывать *статическую полиморфность*.

### Основное использование `template`

`template` на базовом уровне позволяет автоматизировать создание перегрузок функций.

> См. [простой пример](../../en/05a_programming_fundamentals/headers/template/example_1).

Рассмотрим следующий пример:

```cpp
int sum(std::span<int> arr)
{
    int result = 0;
    for (size_t i = 0; i < arr.size(); i++)
        result += arr[i];
    return result;
}

// Перегружаем функцию, что означает определение другой функции с
// различными типами параметров (или их количеством).
float sum(std::span<float> arr)
{
    float result = 0;
    for (size_t i = 0; i < arr.size(); i++)
        result += arr[i];
    return result;
}

int main()
{
    std::array<int, 3> arrInt = { 1, 2, 3 };
    // Вызывает `sum` с параметром `std::span<int>`.
    // Неявное преобразование в `std::span<int>`
    int resultInt = sum(arrInt);

    std::array<float, 3> arrFloat = { 1.0f, 2.0f, 3.0f };
    // Вызывает `sum` с параметром `std::span<float>`.
    float resultFloat = sum(arrFloat);

    return 0;
}
```

`template` позволяет записать функцию всего один раз, для любого типа.
Следующая шаблонная функция будет работать не только для `float` и `int`,
но и для любого другого типа, имеющего конструктор по умолчанию и перегрузку оператора `+=`.

```cpp
template<typename T>
T sum(std::span<T> arr)
{
    T result{};
    for (size_t i = 0; i < arr.size(); i++)
        result += arr[i];
    return result;
}

int main()
{
    std::array<int, 3> arrInt = { 1, 2, 3 };
    // Мы должны вручную преобразовать в `std::span<int>`.
    std::span<int> spanInt = arrInt;
    int resultInt = sum(spanInt);
    // Понимается, что `T` должен быть `int` из типа переменной,
    // передаваемой в функцию. Это эквивалентно:
    // resultInt = sum<int>(spanInt);

    std::array<float, 3> arrFloat = { 1.0f, 2.0f, 3.0f };
    std::span<float> spanFloat = arrFloat;
    float resultFloat = sum(spanFloat);
    // эквивалентно
    // resultFloat = sum<float>(spanFloat);

    return 0;
}
```

Определения шаблонных функций немного магические, когда они находятся в заголовочном файле.
Даже если они используются из нескольких компиляционных единиц, линкер достаточно умён,
чтобы автоматически удалять дублирующиеся определения, созданные из этих функций.
Если бы, например, вы вызвали `sum<int>` из двух разных компиляционных единиц,
будет (обычно) только одно определение `sum` для типа `int`, несмотря на то, что обе компиляционные единицы создали свои собственные копии.
Таким образом, шаблонные функции обычно работают как статические функции, и дубликаты автоматически удаляются.

> Технически гарантии об этом отсутствуют.

> См. [пример этого](../../en/05a_programming_fundamentals/headers/template/example_2).




### `template` для типов 

Точно так же вы можете использовать `template` для типов (структур/классов).
Если у вас есть только поля в типе, это не вызывает дополнительных проблем.

> См. [пример 3](../../en/05a_programming_fundamentals/headers/template/example_3).

Это работает, даже если методы определены на месте в вашем типе.

> См. [пример 4](../../en/05a_programming_fundamentals/headers/template/example_4).


### Явное инстанцирование шаблона

Проблемы с шаблонами возникают, когда вы хотите только
*объявить* метод / функцию в заголовочном файле, а определить её в отдельном файле реализации.
В этом случае определение никогда не создается.
Вы должны убедиться, что создано явное определение.
Это можно сделать в файле, который определяет шаблон, *явно инстанциируя шаблон*.

Вы также можете импортировать файл с определением шаблона (`f.cpp`),
и явно инстанциировать его в другом файле.

> См. [пример 5](../../en/05a_programming_fundamentals/headers/template/example_5).

Для типов это работает аналогичным образом.
Методы, только объявленные, но не определенные, в определении шаблона требуют
явного инстанцирования шаблона для определения.

> См. [пример 6](../../en/05a_programming_fundamentals/headers/template/example_6)


### Шаблонные методы в шаблонных классах

В этой ситуации вам просто нужно применить механизм шаблона несколько раз.
В остальном это работает так же, как и в предыдущих примерах.


### Передача в шаблонные параметры не только типов

Вы можете передавать, например, числа в качестве параметров шаблона.
Вы уже использовали это ранее с `std::array<Type, Size>`.
Вот пример:

```cpp
template<size_t N> // вы указываете тип вместо `typename`
std::array<int, N> createArray()
{
    return {};
}

int main()
{
    std:array result = createArray<10>();
    return 0;
}
```

Это может быть подразумевается автоматически:

```cpp
template<size_t N>
void doStuff(std::array<int, N>& arr)
{
    // ...
}

int main()
{
    std::array arr = { 1, 2, 3 };
    doStuff(arr); // вызывает `doStuff<3>`
}
```

## `const`

`const` означает, что значение чего-то не может быть изменено.

### Базовое использование

Можно применить `const` к переменным, чтобы запретить изменять их значение.

```cpp
const int a = 5;
a = 10; // ошибка компиляции
```

Это применимо к любым типам, включая пользовательские типы.

```cpp
struct T
{
    int value;
};

// ...

const T a{5};
a.value = 10; // не разрешено, потому что a.value является частью памяти переменной `a`.
a = { 50 }; // также нельзя изменить всю память.
```

`const` также можно применять к параметрам.
Это означает, что функции запрещено изменять значение параметра.
Как есть оно довольно бесполезно для копий, оно очень полезно для ссылок и указателей.
Например, предположим, у нас есть тип `Demo`:

```cpp
struct Demo
{
    int value;
    int expensiveToCopy[1000];
};

void stuff(const Demo& demo)
{
    int value = demo.value; // чтение разрешено.
    demo.value = 5; // запись не разрешена.
    demo = { 6 }; // также не разрешено.
}
```

### `const` с указателями

Обычно `const` применяется только на один уровень глубины для указателей.
Например, `const int*` или `int const*` означает, 
что *память, на которую указывает переменная* не может быть изменена,
но сам указатель может,
и `int* const` означает, что *сам адрес указателя* не может быть изменен,
но память, на которую он указывает, может.
Аналогично, `const int* const` означает, что ни тот, ни другой не может быть изменен.

Для указателей с несколькими уровнями вложенности необходимо указать `const` для каждого уровня.

```cpp
void func(
    int* p, // изменяемый адрес, изменяемый объект
    const int* p1, // изменяемый адрес, неизменяемый объект
    int* const p2, // неизменяемый адрес, изменяемый объект
    const int* const p3 // неизменяемый адрес, неизменяемый объект
)
{
    int local = 8;

    *p = 10;
    p = &local;

    // *p1 = 10;
    p1 = &local;

    *p2 = 10;
    // p2 = &local;

    // *p3 = 10;
    // p3 = &local;
}
```

Для указателей на объекты с указателями, `const` применяется только на первом уровне.
Он не будет применен к памяти вложенного указателя.

```cpp
struct Demo
{
    int someValue;
    int* pointer;
};

void func(const Demo* demo)
{
    int local = 8;
    // demo->someValue = 10;
    // demo->pointer = &local;
    *demo->pointer = 10; // это разрешено.
}
```

### `const` vs `constexpr`

Значение переменной `const`, использованной 
с известными на этапе компиляции константами примитивного типа,
может использоваться в контексте компиляции.
Например, его можно использовать в качестве размера
статического массива или в качестве параметра шаблона.

```cpp
#include <array>
static inline const size_t arrayLength = 10;

int arr[arrayLength];
std::array<int, arrayLength> arr2;
```

Это не сработает, если использовать структуру, например:
```cpp
#include <array>
struct Test
{
    size_t value;
};

// Это будет доступно только во время выполнения,
// потому что это не примитивный тип.
static inline const Test arrayLength = { 10 };

int arr[arrayLength.value]; // не разрешено
std::array<int, arrayLength.value>; // не разрешено
```

Но этого можно достичь, изменив `const` на `constexpr` в этом примере.
`constexpr` делает его константой времени компиляции.

`constexpr` также можно использовать с функциями, чтобы указать
компилятору, что они могут быть выполнены во время компиляции.
`constexpr` функции могут вызывать только другие `constexpr` функции.
Это еще одна кроличья нора, поэтому я остановлюсь здесь.

### `const` методы

`const` можно применить к методу, что применит его к указателю `this*`.
Синтаксис выглядит так:

```cpp
class Demo
{
    int state;

private:
    int readState() const
    {
        return this->state;
    }
};

// Что означает по сути:
int readState(const Demo* const this)
{
    return this->state;
}
```

### `const_cast`

Это может быть полезно, когда вы знаете, что операция не изменит объект,
несмотря на то что функция не объявлена как `const`.
Хорошим примером является, например, функция, предоставляющая доступ
к элементу массива по заданному индексу.

```cpp
struct Buffer
{
    int* elements;
    size_t length;
};

int& getRefAtIndex(Buffer& buff, size_t index)
{
    return buff.elements[index];
}

// Необходимо реализовать тот же метод для const Buffer.
// Результат должен быть const, потому что мы хотим, чтобы const
// был транзитивно применялся к элементам в буфера.
const int& getRefAtIndex(const Buffer& buff, size_t index)
{
    // Обратите внимание, как нам нужно предоставить точно такую же реализацию.
    return buff.elements[index];
}

int main()
{
    Buffer buff{new int[5], 5};
    const Buffer buffConst{new int[5], 5};

    // Вызывает не const перегрузку
    getRefAtIndex(buff, 0);

    // Вызывает const перегрузку
    getRefAtIndex(buffConst, 0);

    return 0;
}
```

Чтобы не пришлось реализовывать ту же самую функцию второй раз,
мы можем перенаправить вызов в первой функции ее `const` версию.
Это означает, что мы должны преобразовать параметр в `const`,
а затем преобразовать результат обратно в не `const`.
Очевидно, это будет допустимой реализацией,
поскольку `const` здесь влияет только на тип возвращаемого значения.
Мы знаем, что ни одна из функций по факту не изменит состояние объекта.

```cpp
int& getRefAtIndex(Buffer& buff, size_t index)
{
    // сначала конвертируем в const
    const Buffer& constBuff = buff;
    // теперь вызовем const функцию
    const int& element = getRefAtIndex(constBuff, index);
    // теперь уберем `const`
    return const_cast<int&>(element);
}
```

### Хорошие практики

Считается хорошей практикой и ведет к более надежному коду
следовать принципам корректности `const`, что означает,
что следует всегда применять `const` везде, где это уместно.


## Умные указатели (smart pointers)

Если вы понимаете RAII, вам также будет легко понять и умные указатели.

### `std::unique_ptr`

`std::unique_ptr` - это шаблонный тип, представляющий динамически выделенную память, следующий принципу RAII.

### `std::shared_ptr`

## Итераторы

*Итератор* - мощный шаблон программирования, который позволяет 
абстрагировать логику итерации по коллекции элементов.

### Пример шаблона итератора

Представьте, что у вас есть древовидный граф, и вы хотите выполнить
[обход в глубину (depth-first traversal)](../../en/05a_programming_fundamentals/iterator/graph_1.cpp), выводя все значения.

Код, конечно, довольно простой, но что, 
если нам нужно было вычислить сумму значений из всех нодов?
Пришлось бы продублировать функцию обхода и изменить логику внутри на суммирование:

```cpp
int sumDFS(const Node* node)
{
    int result = node->value;
    for (size_t i = 0; i < node->children.size(); i++)
        result += sumDFS(node->children[i]);
    return result;
}
```

Можно представить, как это может стать проблематичным, если логика обхода более сложная,
чем просто рекурсивное прохождение по дочерним нодам.

Один из способов решения этой проблемы - использовать паттерн стратегии, или visitor,
т.е. передачу функции для выполнения при посещении нода.
Как сделать что-то подобное, будет описано позже в теме про полиморфизм.

Здесь мы обсудим паттерн итератора, который является другим решением этой проблемы,
при том более гибким.
Он позволяет приостанавливать обход, продолжив его позже, а также выбрать
операцию выполняемую над элементами и доступ к любым вашим переменным.

Идея следующая: будем хранить текущее состояние итерации в объекте,
по факту представляя, как будет выглядеть стек в определенные момент рекурсивного выполнения,
определим функции для перемещения итератора к следующему элементу
(и, возможно, дополнительные функции, например, для перехода к предыдущему элементу).
Нам также понадобится способ дать сигнал о том, что итерация завершена.
Смотрите [код](../../en/05a_programming_fundamentals/iterator/graph_manual_iterator.cpp).

> Рекомендую выполнить программу с дебаггером,
> чтобы понять, как работает программа.

Конечно, код вышел сложнее, особенно в том плане, что
приходится имитировать стек вручную (это не всегда необходимо в итераторах).
Как правило, код итератора всегда сложнее, чем прямая итерация,
но добавленная гибкость + устранение дублирования кода часто того стоят.

### Итераторы в C++

У C++ есть "стандартный способ" создания итераторов, который необходим для некоторых
шаблонных функций в стандартной библиотеке:

- Тип итератора перегружает оператор `++` (с логикой метода `advance` из моего примера).
  Он также по желанию перегружает операторы `--`, чтобы вернуться к предыдущему элементу.

- Тип итератора перегружает оператор `*` (с логикой метода `value` из моего примера). 
  Оператор `*` -- то есть оператор разыменования указателя.
  Если возможно, пусть возвращать ссылку, вместо копии.

- У итератора есть специальное состояние, означающее конец итерации.
  В моем случае я определил метод `empty`, но мы могли бы представить это "пустое" состояние
  как два пустых вектора.
  Затем проверка на пустоту (конец итерации) осуществляется путем сравнением итератора 
  с этим специальным значением.

- Типы, которые определяют один способ итерации, могут определять методы `begin` и `end`,
  которые возвращают состояние итератора первого элемента и специальное состояние пустоты соответственно.

Смотрите [тот же пример, что и раньше, но с использованием стандартного подхода](../../en/05a_programming_fundamentals/iterator/graph_standard.cpp).

Этот дизайн мотивирован стремлением имитировать интерфейс указателей.
`++p` перемещает указатель на один элемент, `*p` считывает значение по адресу,
и `p == start+count` проверяет, достигли ли мы конца массива, например.

### Преимущества стандартного подхода

Если вы выполнили итератор по С++-овски, вы автоматом получаете классный
синтаксис range итерации.
Если ваш тип имеет методы `begin` и `end`, вы можете использовать его в foreach версии цикла `for`.
Смотрите [пример](../../en/05a_programming_fundamentals/iterator/graph_range_for.cpp).

Этот синтаксис работает для большинства стандартных типов контейнеров,
потому что они выполняют паттерн следуя этому походу,
определяя методы `begin` и `end`, а также тип итератора с операциями,
описанными выше.

Вам не обязательно определять еще один тип. 
Если имеет смысл выполнять только один вид итерации для вашей структуры данных,
или какой-то вид итерации явно должен быть дефолтным,
вы можете определить методы `begin` и `end` для вашего типа контейнера напрямую.
Это имеет смысл, для, например, `DynamicArray`, но, наверное, не для графа.

## Строки

*Строки* - это массивы символов.

### ASCII

Как представить символ в памяти (т.е. как число)?
Для этого изобрели *кодировки*. 
Самая простая кодировка - 7-битная кодировка, называемая ASCII.
Символы и их значения можете глянуть, например, [здесь](https://www.asciitable.com/).

Обратите внимание, что любой символ из ASCII можно представить 7 битами,
поэтому в байте можно хранить не более одного символа.
Конечно, старший (high) бит всегда равен 0, 
чтобы значение байта было эквивалентно значению из таблицы ASCII.

Тип, представляющий один символ ASCII, - это `char`.
`char` - это 8-битный тип, который может быть как со знаком, 
так и без, в зависимости от компилятора.

```cpp
#include <iostream>

int main()
{
    char character = 65; // 65 - код A в таблице ASCII
    std::cout << character; // выводит A
}
```

Также можно использовать *литералы символов*, чтобы компилятор сам находил
число в таблице ASCII за вас.

```cpp
char character = 'A';
// Эквивалентно:
char character = 65;
```

Можно выполнять арифметические операции с символами, например,
увеличивать их или добавлять к ним смещение.
Теперь внимательно посмотрите на заглавные латинские буквы в таблице ASCII.
Они идут подряд.
Это означает, что мы можем вывести весь алфавит, используя цикл.

```cpp
char startCharacter = 'A';
char endCharacter = 'Z';
for (char ch = startCharacter; ch <= endCharacter; ch++)
    std::cout << ch;
```

То же самое относится и к маленьким буквам.
Например, можно вычислить смещение между началом заглавных букв и началом маленьких букв,
чтобы преобразовывать буквы из верхнего регистра в нижний.

> Рекомендую использовать дебаггер для лучшего понимания идеи.

```cpp
char offset = 'a' - 'A';
for (char ch = 'A'; ch <= 'Z'; ch++)
{
    char result = ch + offset;
    std::cout << result;
}

// Или наоборот

char offset = 'A' - 'a';
for (char ch = 'a'; ch <= 'z'; ch++)
{
    char result = ch + offset;
    std::cout << result;
}
```

### Unicode

Unicode относится к стандартизированному набору кодировок,
которые можно использовать для кодирования любого символа.
Самой популярной из них является UTF-8.

Все обычные символы ASCII представлены в UTF-8 без изменений.
Проблема заключается в том, что у нас нет больше места в байте для представления других символов,
кроме одного неиспользуемого бита ASCII.
Идея заключается в том, что ты можем использовать этот бит, чтобы указать,
что символ закодирован в нескольких байтах.

Например, символ `ș` можно записать двумя байтами,
например, как `C8 99` в шестнадцатеричной системе.
UTF-8 использует старшие биты для указания количества байт, в которых закодирован символ.
- Первый бит, когда равен `1`, означает, что *текущий символ содержится в нескольких байтах*.
- Второй бит после `1`, когда равен `0`, означает, что *текущий байт не является первым байтом
  символа*; в противном случае он является.
- Количество `1` перед `0`, следующих за первой `1`, включая первую `1`,
  указывает *количество байт символа*.

Идея заключается в том, что любой байт содержит контекст, то есть знает,
является ли он самостоятельным байтом ASCII (первый бит равен 0),
первым байтом последовательности (паттерн 11),
или одним из других байтов в последовательности (паттерн 10).

В таблице ниже показан этот паттерн:

| Количество байт  | Байт 1   | Байт 2   | Байт 3   | Байт 4   |
|------------------|----------|----------|----------|----------|
| 1 (просто ASCII) | 0....... | N/A      | N/A      | N/A      |
| 2                | 110..... | 10...... | N/A      | N/A      |
| 3                | 1110.... | 10...... | 10...... | N/A      |
| 4                | 11110... | 10...... | 10...... | 10...... |

4 байта - это максимум.
Если символ кодируется более чем 4 байтами (это случай для большинства emoji),
его называют кластером графем (grapheme cluster).
Он тогда представлен несколькими символами UTF-8.

> Различная терминология может вызвать путаницу, поэтому термин "символ" в
> UTF-8 фактически бессмысленен.
> Лучше обращаться к символу (одной вещи, которая появляется в тексте)
> как *текстовому элементу*, например, чтобы избежать путаницы.
> Различные источники / реализации выбирают различную терминологию.

> Символ, который помещается в 4 байта, иногда называют *руна*.

Существуют также UTF-16 и UTF-32, у которых минимальное количество байт для
символа увеличено до 2 и 4 соответственно, и они используют похожие идеи для кодирования.

### C-строки

*C-строка* - это последовательность символов, заканчивающаяся *нулевым завершителем*,
т.е. числом 0.
В C (не C++!) строки обычно хранятся массивом или как указатель,
без хранения длины строки (количества символов).
Программа предполагает, что где бы строка ни заканчивалась, в конце будет байт 0.
Таким образом она находит конец строки или ее длину.

```cpp
#include <iostream>
#include <array>

int main()
{
    std::array<char, 6> arr{ 
        'H',
        'e',
        'l',
        'l',
        'o',
        '\0', // то же самое, что и просто 0
    }; 

    // `std::cout` обрабатывает `char*` особым образом.
    // Он предполагает, что это C-строка, и печатает ее таким образом.
    std::cout << &arr[0]; // Hello
    return 0;
}
```

И если вы напишете 0 в середине строки,
он выводет только до этого "нового конца".

```cpp
std::array<char, 6> arr{ 
    'H',
    '\0',
    'l',
    'l',
    'o',
    '\0',
}; 
std::cout << &arr[0]; // H
```

Можно использовать строковый литерал вместо перечисления каждого байта:

```cpp
std::array<char, 6> arr = "Hello";
```

Строковые литералы также могут быть присвоены указателю.
Это поместит их в статическую память,
и на некоторых платформах память будет неизменяемой
(запись в нее вызовет крашнет программу).
Вы не должны записывать в память, на которую указывают такие указатели.

```cpp
const char* str = "Hello";
```

### `std::string_view`

Очень часто вам нужно знать длину строки
или сослаться только на часть всей строки,
поэтому полезно хранить длину вместе с указателем.

В этом отношении `std::string_view` работает так же, как `const std::span<char>`.
Он хранит указатель на строку вместе с длиной.
Единственное отличие в том, что у него есть некоторые методы, которые полезны для строк,
и выходные потоки (например, `std::cout`) печатают его как строку.

> Для справки: оператор `<<` не перегружен для `std::span` для потоков,
> что означает, что вы не можете сделать `std::cout << span;`, это просто не скомпилируется.

Также есть различие в конструкторах, в том смысле, что `std::string_view`
не может быть неявно создан из `std::array`.
Однако, он может быть создан из `const char*`,
что заставит его пройтись по всех строке,
пока не найдет нулевой байт, чтобы определить длину.

```cpp
#include <iostream>
#include <array>
#include <string>

int main()
{
    std::array<char, 6> arr = "Hello";
    std::string_view str{&arr[0]};
    std::cout << str.size(); // 5
    std::cout << str; // Hello
    return 0;
}
```

Как и с `std::span`, вы можете передать ему длину в конструкторе:

```cpp
std::array<char, 6> arr = "Hello";
std::string_view str{&arr[0], 2};
std::cout << str; // He
```

### `std::string`

`std::string` - это RAII тип, который позволяет выделять строку в heap.

```cpp
#include <string>
#include <iostream>

int main()
{ 
    // Создание из литерала.
    // Обратите внимание, что строка копируется в буфер, выделенный в heap,
    // из статической памяти, где хранится литерал.
    // Локальная переменная хранит указатель на буфер и длину.
    std::string string1{"Hello world!!"};

    // Конструктор на основе указателя + длина
    // обратите внимание, что он копирует строку в новый буфер, выделенный в heap.
    std::string string2{&string1[0], 10};

    // Это НЕ создает новый буфер.
    // Он указывает на буфер string2.
    std::string_view view{string2};

    std::cout << string1; // Hello world!!
    std::cout << string2; // Hello worl
    std::cout << view; // Hello worl

    return 0;

    // Добавлено неявно:
    // string2.~string()
    // string1.~string()
}
```

#### `std::string` можно изменять

```cpp
std::string string1{"Hello world!!"};
string1[0] = 'L';
std::cout << string1; // Lello world!!
```

Он также поддерживает удобные операторы конкатенации:

```cpp
std::string string1{"Hello"};
string1 += " world"; // Выделит новый буфер по необходимости.
std::cout << string1; // Hello world
```

Также, для коротких строк, динамическая память не выделится.
Если строка достаточно короткая, она будет храниться внутри самого объекта 
(обычно до 23 байт, не требуя выделения памяти).
Это называется *оптимизация малых строк* (small string optimization).


#### `std::string` в C++ - это динамический массив

`std::string` по сути работает как `std::vector<char>`, потому что ее буфер, capacity и
длина разделены, что позволяет вам потенциально добавлять символы в конец
без выделения памяти при каждом добавлении.

В C#, например, строки являются неизменными,
что означает, что каждый раз, когда вы пытаетесь добавить
символ в конец, создасться новая строка, в нее будет скопирована старая строка и
затем будет добавлен новый символ в конец.
Это неэффективно, но строки C# побеждают в том плане, что они неизменны,
что имеет свои преимущества.


#### `const std::string&` параметр -- это глупо

**Не используйте `const std::string&` в качестве типа параметра.**

Если `const` означает, что вы не сможете его изменить, зачем заставлять
пользователя предоставлять строку как `std::string`?
Есть много других способов представления строки, ее можно хранить в любом
линейном блоке памяти.

Лучшим вариантом является замена этого на `std::string_view`, который предназначен
для использования в этом контексте. 
Это гораздо более гибко, потому что вы можете создавать его без выделения динамической памяти
из любой пары указатель + длина.


#### `std::string` завершается нулем

Буфер символов любого `std::string` всегда завершен нулем,
что гарантируется стандартом C++.
Для получения указателя на буфер, вы можете использовать метод `c_str()`.


## Пространства имен

Мы уже знакомы со скоупами типов, которые включают в себя концепцию пространства имен.
Однако, если вам нужен примитив, который предоставляет только концепцию пространства имен,
вы можете использовать `namespace`.

### Базовое использование

Пространство имен по сути означает скоуп,
в которой могут находиться функции, переменные, типы и другие пространства имен,
и может использоваться для избежания конфликтов имен.

Я уже использовал пространство имен `std` в своих примерах.
`std` - это пространство имен, которое создано стандартной библиотекой.
Однако, мы можем с легкостью можем создать свое, новое пространство имен.

```cpp
#include <iostream>

// Определяем пространство имен с именем Demo.
namespace Demo
{
    // Размещаем функцию внутри Demo.
    void f()
    {
        std::cout << "Hello from Demo::f" << std::endl;
    }
}

int main()
{
    // Мы можем использовать оператор разрешения области видимости для доступа к функции.
    // Это аналогично использованию `.` для доступа к полям структуры.
    Demo::f();
    return 0;
}
```

Заметьте, как это практически то же самое, что и статическая функция в объявлении типа.
Это потому, что объявления типов функционируют как пространства имен.

```cpp
#include <iostream>

struct Demo
{
    static void f()
    {
        std::cout << "Hello from Demo::f" << std::endl;
    }
};

int main()
{
    Demo::f();
    return 0;
}
```

Вы можете вкладывать пространства имен в другие пространства имен.

```cpp
namespace Demo
{
    namespace Demo1
    {
        void f()
        {
        }
    }
}

int main()
{
    Demo::Demo1::f();
    return 0;
}
```

Пространства имен могут использоваться, когда у вас есть различные реализации функции
с тем же именем, которые вы хотите различать:

```cpp
namespace Impl1
{
    void f()
    {
        std::cout << "Hello";
    }
}

namespace Impl2
{
    // Несмотря на то, что у нее то же имя, это не вызовет ошибку связывания.
    void f()
    {
        std::cout << "World";
    }
}

int main()
{
    Impl1::f(); // Привет
    Impl2::f(); // Мир
    return 0;
}
```

Вы можете определять пространства имен несколько раз, в разных местах,
и они будут ссылаться на тот же "объект".

```cpp
namespace Demo
{
    void f()
    {
    }
}

namespace Dima
{
    void g()
    {
    }
}

// Ссылается на то же пространство имен, что и Demo выше.
namespace Demo
{
    // Это пространство имен не то же самое, что и Dima выше.
    // Это пространство имен действительно называется Demo::Dima.
    namespace Dima
    {
        // Полностью допустимо, нет ошибки времени компиляции
        void g()
        {
        }
    }

    // Тоже допустимо, нет ошибки времени компиляции.
    void g()
    {
    }

    // Дублированное определение, ошибка времени компиляции.
    // У нас уже есть `f()` выше.
    void f()
    {
    }
}
```

Это означает, что определение пространства имен `std` в вашем коде абсолютно допустимо.
Это даже требуется для некоторых вещей, таких как определение хэш-функции для типа.

```cpp
namespace std
{
    void f(){}
}

int main()
{
    std::f();
    return 0;
}
```

Обратите внимание, что `main` должна находиться вне какого бы то ни было пространства имен,
чтобы выполнять особую роль точки входа.


### Пространства имен позволяют использовать символы из того же пространства имен без квалификации

```cpp
namespace Demo
{
    void f()
    {
    }

    void g()
    {
        // Мы можем использовать `f` без квалификации.
        f();
        // Мы могли бы использовать `Demo::f`, если бы хотели.
        Demo::f();
    }
}
```

Это похоже на тот факт, что не обязательно дописывать `this->`,
когда обращаетесь к полям или методам внутри тела метода.

Кстати, то же самое относится и к областям видимости,
созданным ключевыми словами `struct` или `class`.

Еще одна штука: вложенные пространства имен могут видеть символы,
определенные во внешних пространствах имен.
Это аналогично скоупах в функциях, разница в том, что вам *разрешается*
определять функции с тем же прототипом в различных скоупах.

```cpp
namespace Outer
{
    void f()
    {
    }

    void g()
    {
    }

    namespace Inner
    {
        // Повторное определение `g` во вложенном пространстве имен разрешено.
        void g()
        {
            // Вызывает `Outer::f()`
            f();
        }
    }
}
```

### Упрощение с оператором `::`

Вы не обязаны вкладывать каждое отдельное пространство имен.
Вы можете использовать `::` в определении пространства имен.
Следующий код:

```cpp
namespace Outer
{
    namespace Inner
    {
        void f()
        {
        }
    }
}
```

Эквивалентен следующему:

```cpp
namespace Outer::Inner
{
    void f()
    {
    }
}
```

### Глобальный скоуп

Глобальная скоуп находится вне пространств имен.
У него нет имени.
Его можно использовать для разрешения неоднозначности имен
в некоторых редких ситуациях.

```cpp
namespace Demo
{
    void f()
    {
        std::cout << "Outer";
    }

    namespace Dima
    {
        namespace Demo
        {
            void f()
            {
                std::cout << "Inner";
            }
        }

        void g()
        {
            // Мы хотим вызвать `Demo::f` из глобального скоупа.
            // Однако просто вызов `Demo::f` вызовет `f` из внутреннего `Demo`.
            Demo::f(); // Inner

            // Чтобы вызвать внешний `Demo::f`,
            // надо разрешить это имя относительно глобального скоупа.
            ::Demo::f(); // Outer

            // Внутренний вызов можно записать так:
            ::Demo::Dima::Demo::f(); // Inner
        }
    }
}
```

### `using namespace`

`using namespace` -- четкая фича. 
Ее можно использовать для включения всех элементов пространства имен в текущий скоуп.
Под "включением" я имею в виду видимость всех элементов пространства имен без квалификации.
Самое замечательное заключается в том, что его можно использовать в *любом* скоупе,
будь то скоупы функций, вложенные обычне скоупы, пространства имен или скоупы типов.

```cpp
#include <iostream>

int main()
{
    {
        // Делаем все элементы std видимыми здесь без квалификации.
        using namespace std;

        cout << "Hello" << endl;
    }

    {
        // Но не здесь.
        cout << "World" << endl; // ошибка при компиляции
    }
}
```

`using namespace` довольно опасен, потому что он может привести к выбору функции,
отличной от вашей, при разрешении перегрузки,
то есть компилятор может вызвать стандартную функцию с тем же именем, что и ваша,
что лучше соответствует ее параметрам.

Я покажу вам это на более мирном примере, чтобы вы поняли идею.

```cpp
#include <iostream>

namespace Demo
{
    void f(int a)
    {
        std::cout << "Demo::f -- " << a << std::endl;
    }
}

// Мы как ни в чем не бывало определяем вторую функцию,
// которая принимает float вместо int,
// ожидая, что вызовется эта, не зная о существовании другой в Demo.
void f(float a)
{
    std::cout << "Happy life" << std::endl;
}

int main()
{
    using namespace Demo;
    // Угадайте, какая функция будет вызвана здесь?
    f(5); 
    return 0;
}
```

`using namespace std` чрезвычайно опасен из-за этого,
так как внутри `std::` находится **море** хлама,
который *очень вероятно* имеет те же имена, что и некоторые из ваших символов.
Вы можете потратить бесчисленные мучительные часы, пытаясь
понять, почему ваша функция не делает то, что ей предписано,
все, чтобы заметить после, что вы все это время тестировали вообще не ту функцию.

`using namespace` *нельзя* применять к типам.

```cpp
#include <iostream>

struct T
{
    int value;
    static void f()
    {
        std::cout << "T::f" << std::endl;
    }
};

int main()
{
    // Не компилируется
    using namespace T;
    f();
    return 0;
}
```


### Разрешение коллизий имен

Если вы включили два пространства имен, в которых есть одинаковое объявление функции,
вы не сможете вызвать функцию без квалификации.

```cpp
namespace A
{
    void f()
    {
        std::cout << "A";
    }
}
namespace B
{
    void f()
    {
        std::cout << "B";
    }
}

int main()
{
    using namespace A;
    using namespace B;

    // Компилятор: "Чел, какую мне вызвать? A::f или B::f?"
    f();

    // Вы должны разрешить неоднозначность, квалифицировав имена.
    A::f(); // A
    B::f(); // B
}
```

Аналогичная ситуация, где происходит коллизия имен между функцией из глобального скоупа
и функцией из использованного пространства имен, может быть разрешена аналогичным образом:

```cpp
namespace A
{
    void f()
    {
        std::cout << "Hello";
    }
}
void f()
{
    std::cout << "World";
}

int main()
{
    using namespace A;

    f(); // бессмысленно!
    A::f(); // Hello
    ::f(); // World

    return 0;
}
```


### `using` для псевдонимов имен

Еще одним очень полезным способом использования `using`
является предоставление типу другого имени.
Это в значительной степени эквивалентно `typedef`, но `using` немного более интуитивен,
поэтому рекомендуется использовать `using` вместо `typedef`.

> `typedef` не работает с шаблонами, `using` - да.


```cpp
namespace Long::Namespace::Name
{
    struct Outer
    {
        struct Inner
        {
            struct Target
            {
                int x;
            };
        };
    };
}
int main()
{
    using T = Long::Namespace::Name::Outer::Inner::Target;
    // то же самое, что и
    // typedef Long::Namespace::Name::Outer::Inner::Target T;

    T t{15};
    std::cout << t.x; // 15

    return 0;
}
```

```cpp
enum class Color
{
    Red = 'r',
    Green = 'g',
    Blue = 'b',
};

int main()
{
    using C = Color;
    C color = C::Red;

    switch (color)
    {
        case C::Red:
            std::cout << "Red";
            break;
        case C::Green:
            std::cout << "Green";
            break;
        case C::Blue:
            std::cout << "Blue";
            break;
    }

    return 0;
}
```

Вы можете использовать синтаксис `namespace X =` для того же самого с пространствами имен.

```cpp
namespace Hello::World::Long::Namespace::Very::Long
{
    void func()
    {
    }
}

int main()
{
    namespace NS = Hello::World::Long::Namespace::Very::Long;
    NS::func();
}
```


## `enum` и `enum class`

`enum` позволяет определять именованные константы, доступные во времени компиляции,
используя упрощенный синтаксис.

### Концепция перечисления

`enum` означает *перечисление*, что означает исчерпывающий список возможных вещей.
Представьте, что хотите представить цвета светофора -- как бы вы это сделали?
Самый простой подход - определить константу для каждого возможного цвета:
одна для красного, одна для желтого и одна для зеленого.

```cpp
static inline const int RED = 0;
static inline const int YELLOW = 1;
static inline const int GREEN = 2;
```

`static inline` присутствуют, чтобы линкера не обращал на них внимания
при ликнинге файлов и чтобы они не попадали в конечный исполняемый файл.
Каждый файл, который хочет использовать эти константы, 
может просто импортировать файл, который их определяет,
не переживая о дублировании определений.

И вы могли бы использовать это [так](../../en/05a_programming_fundamentals/enums/global_const_list.cpp).

Это в точности то, что делает `enum`.
Он просто упрощает то, как определяются константы.

```cpp
enum TrafficLightColors
{
    RED = 0,
    YELLOW = 1,
    GREEN = 2,
};
```

Более того, указание значений становится необязательным.
Они автоматически инкрементируются компилятором, если их не задать вручную.
Так что, если вы не пишете их, как здесь:

```cpp
enum TrafficLightColors
{
    RED,
    YELLOW,
    GREEN,
};
```

Это по сути эквивалентно следующему:

```cpp
enum TrafficLightColors
{
    RED = 0,
    YELLOW = RED + 1,
    GREEN = YELLOW + 1,
};
```

И если бы вы сделали:

```cpp
enum TrafficLightColors
{
    RED,
    YELLOW = 55,
    GREEN,
};
```

Это было бы эквивалентно:

```cpp
enum TrafficLightColors
{
    RED = 0,
    YELLOW = 55,
    GREEN = YELLOW + 1, // 56
};
```

### `enum class`

Было бы хорошей идеей иметь способ обеспечения того, что тип
целого числа, передаваемого в какую-то функцию, является одним из перечисленных значений.
Вы можете сделать это с помощью `struct`. См. [пример](../../en/05a_programming_fundamentals/enums/namespaced_enum.cpp).

Это по сути то, чего вам позволяет добиться `enum class`, но с
гораздо более простым синтаксисом.
См. [пример](../../en/05a_programming_fundamentals/enums/enum_class.cpp).

> Единственное важное отличие заключается в том, что в нашей реализации `struct`,
> вы не обязаны определять константы в пределах пространства имен,
> но с `enum class` они всегда определены в пределах пространства имен.
> Это означает, что вы можете вытащить все константы в текущий скоуп с помощью `using`,
> но вы не можете сделать то же самое с `enum class`.

### Базовый тип

`enum` не ограничивается только int - вы можете использовать любой другой тип для представления значений.
Например, вы можете использовать байт, если максимальное значение меньше 256.
Для этого нужно указать базовый тип после имени перечисления.

```cpp
#include <stdint.h>

enum TrafficLightColor
    : uint8_t // базовый тип, 8-битное беззнаковое целое
{
    RED = 0,
    YELLOW = 1,
    GREEN = 2,
};
```

Кроме того, вы можете фактически записать недопустимое значение в переменную типа перечисления,
т.е. записать значение, которое не является одной из констант.
Обычно вы этого не ожидаете в коде, поэтому, когда вы натыкаетесь на такое значение,
вполне разумно использовать `assert(false)`, чтобы сразу крашнуть программу.

```cpp
enum class TrafficLightColor
    // : int // неявно int
{
    RED = 0,
    YELLOW = 1,
    GREEN = 2,
};

int main()
{
    // Создание недопустимого цвета разрешено.
    TrafficLightColor color = static_cast<TrafficLightColor>(5);
    return 0;
}
```

## `auto` и `decltype`

Раздел о полиморфизме отчасти требует использования `auto` 
при обсуждении лямбда-выражений, поэтому решил объяснить это здесь.

### `decltype`

`decltype` - это оператор, который возвращает тип выражения:

```cpp
struct T { float x; };

int main()
{
    int a{1};
    decltype(a) b{2}; // int b{2};
    b += a;

    T t{1.0f};
    decltype(t) t1{2.0f}; // T t1{2.0f};
    decltype(t.x) x{3.0f}; // float x{3.0f};
    decltype(T::x) x1{4.0f}; // float x1{4.0f};
    return 0;
}
```

Его нельзя использовать в момент объявления.

```cpp
decltype(a) a = 5; // не компилируется
decltype(5) a = 5; // ок
```

Выражение может быть более сложным:

```cpp
#include <cmath>
decltype(std::max(5, 6) - static_cast<float>(5)) a = 5.0f; // float a = 5.0f;
```

### `auto`

`auto` - это ключевое слово, которое позволяет компилятору
*вывести* или *предположить* тип переменной из типа выражения, которое вы присваиваете ей.

`auto x = y;` эквивалентно `decltype(y) x = y;`.

```cpp
int a1 = 5;
auto a2 = 5; // int a2{5};
```

Его также можно использовать как тип возвращаемого значения функций.
В следующем примере компилятор выводит, что тип возвращаемого значения `f` -- это `int`:

```cpp
auto f()
{
    return 5;
}
```

На всякий случай упомяну, что переменные, объявленные с типом `auto`,
по-прежнему имеют статический тип, если это до сих пор не стало очевидно.
Вы не можете присвоить им переменную другого типа.

```cpp
auto a = 5;
a = 6; // ок
a = "Hello"; // не компилируется
```


## Полиморфизм

*Полиморфизм* означает, что одно имя функции может ссылаться на разные функции 
в зависимости от некоторого контекста.
Это одна из самых важных концепций программирования,
которая позволяет достичь некоторых мощных техник.

### Статический полиморфизм (перегрузка функций)

Я уже отчасти затронул эту идею в разделе о `template`.
Это относится к объявлению нескольких функций с одним и тем же именем,
но разным количеством параметров или типами параметров.

```cpp
void f(int a)
{
    std::cout << "int";
}

void f(float a)
{
    std::cout << "float";
}

int main()
{
    f(5); // int
    f(5.0f); // float
    return 0;
}
```

Здесь нет ничего сверхъестественного.
Основная идея, которую нужно понять, заключается в том,
что одно и то же имя `f` ссылается на несколько функций,
и какая именно функция вызывается,
определяется контекстом -- типом аргумента.

Обратите внимание, что в отличие от C++, в C нет перегрузки функций.
В C для реализации того же функционала вам пришлось бы дать функциям разные имена.
Обычно дописывают тип аргумента (каким-нибудь образом).

```cpp
void f_int(int a)
{
    std::cout << "int";
}

void f_float(float a)
{
    std::cout << "float";
}

int main()
{
    f_int(5); // int
    f_float(5.0f); // float
    return 0;
}
```

В этом случае, синтаксис вызова становится излишне явным,
что перегрузка функций стремится устранить.
Если у программы уже есть информация о типе,
на основе которой она может решить, какую функцию вызвать,
зачем повторять это каждый раз, когда вы хотите вызвать функцию?
В этом идея перегрузок.


### Указатели на функции

Идея в вызове функции по ее адресу, сохраненному в переменной-указателе.

Вы можете использовать это для реализации примитивной формы паттерна стратегии.
Стратегия, менее можщый паттерн, чем паттер итератора,
в плане работы с коллекциями, но он тоже может быть использован.
Вы также можете объединить их вместе, чтобы создать абстракцию над циклами.

См. [пример](../../en/05a_programming_fundamentals/polymorphism/strategy_func_pointer.cpp).

Вы можете использовать эту идею для присвоения поведения вещам.
Представьте, что подключаете определенную функцию к вызову при нажатии кнопки.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/button_func_pointer_example.cpp).

Конечно, можно было бы добиться этого с помощью `switch`.
Но что, если основная функция не должна знать о всех возможных функциях?
Как в [следующем примере](../../en/05a_programming_fundamentals/polymorphism/button_func_pointer_decentralized.cpp).
Это легко может произойти, если вы фактические функции находяться в каком-то другом модуле
как `static`, в то время как интерфейс модуля объявляет только функцию,
которая добавит эти внутренние функции в список.
Вы никогда не смогли бы добиться чего-то подобного с помощью `switch`,
без добавления всех внутренних функций в интерфейс модуля.

```cpp
// main.cpp
#include "math_functions.h"
// ...
addMathFuncs(functionList);
```

```cpp
// math_functions.h
void addMathFuncs(std::vector<ButtonFunc>& functionList);
```

```cpp
// math_functions.c
static void add()
{
    // ...
}

static void subtract()
{
    // ...
}

void addMathFuncs(std::vector<ButtonFunc>& functionList)
{
    functionList.push_back(add);
    functionList.push_back(subtract);
}
```

### Передача закрытого состояния в функцию

При использовании указателей на функции возникает ограничение: 
нельзя передавать данные внутрь функции.
Если вам нужна функция, которая добавляет 5 к каждому числу в массиве, всё в порядке.
Однако, если вам нужна функция, которая добавляет N к каждому числу в массиве,
вы попросту не сможете передать N параметром.

```cpp
void add5(int& a)
{
    a += 5;
}

void addN(int& a, int n)
{
    a += n;
}

// ...

// Ок
forEachItem(list, add5);

// Невозможно
int increment = 5;
forEachItem(list, addN(???, increment));
```

Конечно, можно частично решить эту проблему, используя глобальные переменные,
но так делать не рекомендую.
Это делает программу менее гибкой и порождает беспорядок.
Если `forEachItem` принимает только указатели на функции, у вас нет выбора.
Но если вы можете изменить `forEachItem`, то есть другие варианты.

Желательно, чтобы пользователь мог передавать *собственный контекст* в функцию,
то есть дополнительные данные, необходимые для выполнения её задачи.
Довольно простым решением будет добавление параметра-шаблона
для типа контекста и передача его вместе с указателем на функцию.

См. [пример](../../en/05a_programming_fundamentals/polymorphism/func_with_context.cpp).
В нем есть несколько проблем, таких как сложность создания перегрузки для `const`
без дублирования всего кода, но об этом можете не беспокоиться.
Другая проблема заключается в том, что различные функции могут требовать различные типы
контекста.
Таким образом, полиморфизм в данном случае, по сути,
статичен, но зависит от типа контекста, а не функции.


### `void*` в качестве типа контекста (type erasure)

Особенностью `void*` является то, что его можно использовать для хранения указателя 
на что угодно, что позволяет передавать с его помощью контекст любого типа.
Единственная проблема заключается в том, что вам придется удостовериться,
что вы передаете правильное значение и закастить его обратно в ожидаемый тип
в функции на принимающем конце, так что это довольно хрупкое решение.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/func_with_context_void.cpp).

Также, поскольку некоторый контекст может быть по размеру не больше указателя,
мы можем хранить его непосредственно, вместо указатель.
Мы можем сделать это, передавая `uintptr_t` и затем кастя его в ожидаемый тип,
который может быть как указателем, так и значением.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/pointer_value_union_small_example.cpp).


### Шаблонное состояние и функция в одном (функторы)

Этот подход представляет собой еще один способ 
статического полиморфизма с передачей контекста.
Идея заключается в том, что вы можете объединить контекст и функцию в один тип,
сделав функцию, которую вы хотите вызвать, членом этого типа.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/functor_custom_name.cpp).

Чтобы можно было надежно вызывать метод из шаблонного определения,
вам нужно выбрать конкретное имя для этой функции, и использовать его для всех функторов.
В C++ для этого был выбран *оператор вызова `operator()`*,
потому что с его помощью вы теперь можете передавать указатели на функции как функторы.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/functor.cpp).

Обратите внимание, что для каждого нового типа, который вы передаете в `forEachItem`,
будет создана новая копия функции в итоговом исполняемом файле
(если не будет оптимизирована / объединена с существующим определением).
В большинстве случаев это не должно вызывать беспокойство,
но особенно большие функции могут увеличить размер вашего исполняемого файла
(делая его слишком большим),
из-за чего использование более динамического подхода иногда может быть более разумным.

Идея функторов часто используется функциями в,
например, модуле `algorithm` стандартной библиотеки,
который также работает с итераторами.


### Лямбда-функции

Лямбда-функции позволяют нам определять функции без указания имени (анонимные функции),
возможно, в пределах другой функции, и автоматически создавать тип функтора.

#### Без контекста

Чтобы определить лямбда-функцию без контекста,
эквивалентную обычной свободной функции (функции в глобальном скоупе),
используется [следующий синтаксис](../../en/05a_programming_fundamentals/polymorphism/lambda_1_void.cpp).
Вы можете передавать её напрямую в качестве параметра другим функциям,
которые также принимают указатель на функцию.

#### Закрытый контекст

Чтобы определить личный контекст функции, вы помещаете параметры
лямбда-функции в квадратные скобки (называемые *capture group* (группа захвата)).
*Копии* переменных, указанных в квадратных скобках, будут доступны в функции.
Под капотом компилятор создает тип функтора,
и эти переменные становятся приватными полями этого типа.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/lambda_2_context_copy.cpp).

> Обратите внимание, что `mutable` требуется, 
> если функция хочет изменить значение своего контекста.
> Он добавляет `const` к сгенерированному методу `operator()`, 
> следуя привычным правилам `const` для ссылок и значений.

Процесс копирования переменных называется *захватом* (capturing).

#### Общий контекст

Также можно использовать захват по ссылке,
добавив символ `&` перед именем переменной в группе захвата.
Таким образом, вы можете обмениваться контекстом между несколькими лямбда-функциями.
См. [пример](../../en/05a_programming_fundamentals/polymorphism/lambda_3_shared_context.cpp).

Можно смешивать типы захвата.

```cpp
int a = 1;
float b = 8;
auto func = [&a, b]() mutable {
    a += 5;
    b *= 10;
};

func();

assert(a == 6);
assert(b == 8); // `b` был скопирован по значению
```

И иметь несколько захватов одного типа:

```cpp
int a;
float b;
auto func = [&a, &b]() mutable {
    a += 5;
    b *= 10;
};
```

#### Передача лямбд в шаблоны

Например, в [этом примере](../../en/05a_programming_fundamentals/polymorphism/functor.cpp),
вы можете передавать лямбды в функцию:
```cpp
// `a` здесь представляет собой ссылку.
forEachItem(values, [&a = values[0]](float& value){ value *= a; });

// или сохранять адрес (`a` здесь представляет собой указатель)
forEachItem(values, [a = &values[0]](float& value){ value *= *a; });
```

#### Подвешенные ссылки

Будьте осторожны с захватом по ссылке, потому что можно легко получить dangling ссылки,
если вы попытаетесь вернуть функтор с захватом по ссылке на локальные переменные из функции.
Dangling ссылки -- ссылки на удаленную или недоступную память,
которая раньше являлась доступной, оставшиеся где-то среди значений переменных.

```cpp
auto createBadFunctor()
{
    int localVariable{5};
    return [&localVariable](){ return localVariable; };
}

int main()
{
    auto func = createBadFunctor();
    func(); // ссылается на удаленную память -- неопределенное поведение
    return 0;
}
```

#### Захват всего

Вы можете захватить все видимые в текущей области видимости переменные по значению
с помощью `[=]` или по ссылке с помощью `[&]`.

```cpp
int a = 1;
int b = 2;
{
    auto func = [=]() mutable {
        a += 5;
        b *= 10;
    };
    func(); // a = 1, b = 2
}
{
    auto func = [&]() {
        a += 5;
        b *= 10;
    };
    func(); // a = 6, b = 20
}
```

Также можно использовать `&` или `=` для установки способа захвата по умолчанию,
а затем переписать его для конкретных переменных:

```cpp
int a = 1;
int b = 2;
// По умолчанию ссылка, но `a` должна быть скопирована.
auto func = [&, a]() mutable {
    a += 5;
    b *= 10;
};
func(); // a = 1, b = 20
```

Переменные будут захвачены только в том случае, если они используются в лямбда-функции.
Это иллюстрируется [здесь](../../en/05a_programming_fundamentals/polymorphism/lambda_4_functor_sizes.cpp).


### Небольшое вступление: типы функций

Это может быть сложно себе представить, но в этом языке объявления функций имеют типы.
Синтаксис аналогичен типам указателей на функции, но без `(*)`:

```cpp
using FuncType = void(int, int);
FuncType f; // объявление
void f(int a, int b); // эквивалентное объявление
void f(int a, int b) { } // определение
```

Также, подобно переменным, можно иметь ссылки на функции:

```cpp
using FuncRefType = void(&)(int, int);
void f(int a, int b) { }
FuncRefType g = f;
```

Или с использованием `decltype`:

```cpp
void f(int a, int b) {}
decltype(f)& g = f;
```


### `std::function`

`std::function` определяется документацией как *general-purpose polymorphic function wrapper*.
Идея `std::function` в том, что к переменной этого типа
можно присвоить любую функцию или функтор,
потенциально захватывая его контекст,
а затем вызывать её позже.

Это мощный тип, который по факту позволяет реализовать
динамический полиморфизм очень гибким образом,
что означает возможность его передачи в функции без наличия
у них параметра-шаблона для функтора.

Строго говоря, `std::function` является типом,
реализующим динамический полиморфизм, что подразумевает,
что это не приведет к раздутию кода, упомянутому ранее,
но приведет к некоторым временным затратам при вызове функции
(аналогично тому, в случае вызова функции через указатель на функцию, а не напрямую,
вызов функтора через `std::function` медленнее ее вызова напрямую, или функтором по шаблону).

См. [пример](../../en/05a_programming_fundamentals/polymorphism/std_function.cpp),
который иллюстрирует работу с `std::function`
с использованием до двух уровней косвенности (pointer indirection),
используя как лямбды, так и функторы,
и предоставляет пример того, как перемещать данные в лямбды.


### Передача нескольких функций (vtable, fat pointer)

Если вашей функции нужно вызывать более одной передаваемой функции,
вы можете использовать ваши существующие знания, чтобы решить эту задачу.
Возможная реализация:

```cpp
using IntroductionFunc = void(*)();
using SumFunc = int(*)(int a, int b);

struct Behavior
{
    IntroductionFunc introduceOneself;
    SumFunc answer;
};

void test(Behavior& behavior)
{
    behavior.introduceOneself();
    int answer = behavior.answer(5, 6);
    std::cout << answer << std::endl;
}

int main()
{
    Behavior dumbCat{
        [](){ std::cout << "Meow" << std::endl; },
        [](int a, int b){ return 0; },
    };
    Behavior smartDog{
        [](){ std::cout << "Woof" << std::endl; },
        [](int a, int b){ return a + b; },
    };
    test(dumbCat); // Meow, 0
    test(smartDog); // Woof, 11

    return 0;
}
```

Несложно представить себе аналогичную реализацию с `std::function`,
которая также позволяла бы захватывать некоторый контекст в каждой функции.

Что делать, если мы хотим, чтобы обе функции
использовали тот же контекст, и мы также хотим динамический полиморфизм
(нам нужно, чтобы функции были либо указателями на функции, либо `std::function`)?
Конечно, могли бы сохранять контекст по отдельности в каждой `std::function`,
но это довольно расточительно.
По итогу где-то хранилась бы память контекста,
но при этом нам пришлось бы хранить указатель на неё в каждой из функций.
Мы могли бы избежать хранения указателей, просто передавая контекст вручную.

Решение, которое позволяет достичь этого, - использование `void*` для контекста.
Конечно, это неуклюжно и опасно, но позволяет осуществить то, что нам нужно.
Мы просто передаем указатель на контекст вместе с указателем на структуру с функциями,
которая также называется *виртуальной таблицей* или *vtable*.
Причина использования указателя на vtable, а не самого vtable,
заключается просто в том, что мы хотим использовать однин и тот же vtable
для нескольких контекстов.
См. [пример](./polymorphism/fat_pointer.cpp).

> По сути, таким образом работает динамический полиморфизм в языке программирования Rust.


### Несколько виртуальных таблиц

Допустим, мы хотели бы иметь несколько виртуальных таблиц.
Допустим, мы хотим использовать одну виртуальную таблицу для приветствий
(методы типа `introduceSelf` при приветствии и `excuseSelf` при уходе),
и другую виртуальную таблицу для вычисления ответов на вопросы
(например, `computeSum` и `writeCppProgram`).

Конечно, мы могли бы сделать это, используя толстые указатели (как в примере выше),
но *виртуальное наследование* в C++ идет другим путем.
Вместо этого они *изменяют указатель*, смещая его на нужную таблицу методов,
а не к началу объекта,
и *хранят смещение к началу данных объекта в виртуальной таблице*,
чтобы иметь доступ к контексту.

См. [пример](../../en/05a_programming_fundamentals/polymorphism/multiple_vtables_cpp_approach.cpp).

Я заставляю вас полностью понять код, но если вы хотите разобраться в теме,
обязательно изучите код.
Вот еще [видео](https://youtu.be/QzJL-8WbpuU), которое мне предложили.

### Чисто абстрактные базовые классы и виртуальные функции

Идея таблицы методов, которую я описал и реализовал ранее,
доступна в качестве примитива в C++.

> Возможно, версия этого в С++ не на 100% совпадает с моей реализацией,
> но она использует очень похожие идеи.

Для определения структуры виртуальной таблицы вы можете определить 
*чисто абстрактный базовый класс* (pure virtual base class)
с *виртуальными* методами,
которым присваивается `0`, что означает "не реализовано".
Другое название для этого - *интерфейс*.

```cpp
class GreetingAbstractBase
{
public:
    virtual void introduceSelf() = 0;
    virtual void excuseSelf() = 0;
};
```

Затем вы можете *унаследоваться* от этого класса в классе с вашим контекстом
и *переопределить* методы.
Это инициализирует виртуальные таблицы и добавляет поле указателя
к каждой из них в вашем *производном* классе (том, который унаследован),
для каждого такого унаследованного базового класса.

```cpp
class Person : 
    public GreetingAbstractBase,
    public QuestionAbstractBase
{
    // ...

    void introduceSelf() override
    {
        // ...
    }

    // ...
}
```

Синтаксис преобразования и синтаксис вызова становятся гораздо проще
-- в конце концов, это языковой примитив.

```cpp
Person person;

Person* personPtr = &person;
GreetingAbstractBase* greetingPtr = personPtr;
QuestionAbstractBase* questionPtr = personPtr;

// Указатели смотрят на разную память.
assert(static_cast<uint8_t*>(greetingsPtr) - static_cast<uint8_t*>(questionPtr) != 0);

// Контекст настраивается и передается неявно.
greetingPtr->introduceSelf();
```

Подход менее гибок по сравнению с толстыми указателями, потому что
он объединяет на данные (контекст) с методами,
но удобен из-за более простого синтаксиса,
поэтому по итогу возможно по любому будете использовать именно его.

В общем случае предпочтительнее использовать `std::function` вместо интерфейсов,
когда вам нужен только один метод.
В противном случае интерфейсы - хороший выбор.
Но, конечно же, прежде чем это делать этот выбор, подумайте,
действительно ли вам нужен динамический полиморфизм.

See [an example](../../en/05a_programming_fundamentals/polymorphism/abstract_base_class.cpp).
