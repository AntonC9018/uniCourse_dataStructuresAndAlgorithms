## `const`

`const` означает, что значение чего-то не может быть изменено.

### Базовое использование

Можно применить `const` к переменным, чтобы запретить изменять их значение.

```cpp
const int a = 5;
a = 10; // ошибка компиляции
```

Это применимо к любым типам, включая пользовательские типы.

```cpp
struct T
{
    int value;
};

// ...

const T a{5};
a.value = 10; // не разрешено, потому что a.value является частью памяти переменной `a`.
a = { 50 }; // также нельзя изменить всю память.
```

`const` также можно применять к параметрам.
Это означает, что функции запрещено изменять значение параметра.
Как есть оно довольно бесполезно для копий, оно очень полезно для ссылок и указателей.
Например, предположим, у нас есть тип `Demo`:

```cpp
struct Demo
{
    int value;
    int expensiveToCopy[1000];
};

void stuff(const Demo& demo)
{
    int value = demo.value; // чтение разрешено.
    demo.value = 5; // запись не разрешена.
    demo = { 6 }; // также не разрешено.
}
```

### `const` с указателями

Обычно `const` применяется только на один уровень глубины для указателей.
Например, `const int*` или `int const*` означает, 
что *память, на которую указывает переменная* не может быть изменена,
но сам указатель может,
и `int* const` означает, что *сам адрес указателя* не может быть изменен,
но память, на которую он указывает, может.
Аналогично, `const int* const` означает, что ни тот, ни другой не может быть изменен.

Для указателей с несколькими уровнями вложенности необходимо указать `const` для каждого уровня.

```cpp
void func(
    int* p, // изменяемый адрес, изменяемый объект
    const int* p1, // изменяемый адрес, неизменяемый объект
    int* const p2, // неизменяемый адрес, изменяемый объект
    const int* const p3 // неизменяемый адрес, неизменяемый объект
)
{
    int local = 8;

    *p = 10;
    p = &local;

    // *p1 = 10;
    p1 = &local;

    *p2 = 10;
    // p2 = &local;

    // *p3 = 10;
    // p3 = &local;
}
```

Для указателей на объекты с указателями, `const` применяется только на первом уровне.
Он не будет применен к памяти вложенного указателя.

```cpp
struct Demo
{
    int someValue;
    int* pointer;
};

void func(const Demo* demo)
{
    int local = 8;
    // demo->someValue = 10;
    // demo->pointer = &local;
    *demo->pointer = 10; // это разрешено.
}
```

### `const` vs `constexpr`

Значение переменной `const`, использованной 
с известными на этапе компиляции константами примитивного типа,
может использоваться в контексте компиляции.
Например, его можно использовать в качестве размера
статического массива или в качестве параметра шаблона.

```cpp
#include <array>
static inline const size_t arrayLength = 10;

int arr[arrayLength];
std::array<int, arrayLength> arr2;
```

Это не сработает, если использовать структуру, например:
```cpp
#include <array>
struct Test
{
    size_t value;
};

// Это будет доступно только во время выполнения,
// потому что это не примитивный тип.
static inline const Test arrayLength = { 10 };

int arr[arrayLength.value]; // не разрешено
std::array<int, arrayLength.value>; // не разрешено
```

Но этого можно достичь, изменив `const` на `constexpr` в этом примере.
`constexpr` делает его константой времени компиляции.

`constexpr` также можно использовать с функциями, чтобы указать
компилятору, что они могут быть выполнены во время компиляции.
`constexpr` функции могут вызывать только другие `constexpr` функции.
Это еще одна кроличья нора, поэтому я остановлюсь здесь.

### `const` методы

`const` можно применить к методу, что применит его к указателю `this*`.
Синтаксис выглядит так:

```cpp
class Demo
{
    int state;

private:
    int readState() const
    {
        return this->state;
    }
};

// Что означает по сути:
int readState(const Demo* const this)
{
    return this->state;
}
```

### `const_cast`

Это может быть полезно, когда вы знаете, что операция не изменит объект,
несмотря на то что функция не объявлена как `const`.
Хорошим примером является, например, функция, предоставляющая доступ
к элементу массива по заданному индексу.

```cpp
struct Buffer
{
    int* elements;
    size_t length;
};

int& getRefAtIndex(Buffer& buff, size_t index)
{
    return buff.elements[index];
}

// Необходимо реализовать тот же метод для const Buffer.
// Результат должен быть const, потому что мы хотим, чтобы const
// был транзитивно применялся к элементам в буфера.
const int& getRefAtIndex(const Buffer& buff, size_t index)
{
    // Обратите внимание, как нам нужно предоставить точно такую же реализацию.
    return buff.elements[index];
}

int main()
{
    Buffer buff{new int[5], 5};
    const Buffer buffConst{new int[5], 5};

    // Вызывает не const перегрузку
    getRefAtIndex(buff, 0);

    // Вызывает const перегрузку
    getRefAtIndex(buffConst, 0);

    return 0;
}
```

Чтобы не пришлось реализовывать ту же самую функцию второй раз,
мы можем перенаправить вызов в первой функции ее `const` версию.
Это означает, что мы должны преобразовать параметр в `const`,
а затем преобразовать результат обратно в не `const`.
Очевидно, это будет допустимой реализацией,
поскольку `const` здесь влияет только на тип возвращаемого значения.
Мы знаем, что ни одна из функций по факту не изменит состояние объекта.

```cpp
int& getRefAtIndex(Buffer& buff, size_t index)
{
    // сначала конвертируем в const
    const Buffer& constBuff = buff;
    // теперь вызовем const функцию
    const int& element = getRefAtIndex(constBuff, index);
    // теперь уберем `const`
    return const_cast<int&>(element);
}
```

### Хорошие практики

Считается хорошей практикой и ведет к более надежному коду
следовать принципам корректности `const`, что означает,
что следует всегда применять `const` везде, где это уместно.


## Умные указатели (smart pointers)

Если вы понимаете RAII, вам также будет легко понять и умные указатели.

### `std::unique_ptr`

`std::unique_ptr` - это шаблонный тип, представляющий динамически выделенную память, следующий принципу RAII.

### `std::shared_ptr`



## `auto` и `decltype`

Раздел о полиморфизме отчасти требует использования `auto` 
при обсуждении лямбда-выражений, поэтому решил объяснить это здесь.

### `decltype`

`decltype` - это оператор, который возвращает тип выражения:

```cpp
struct T { float x; };

int main()
{
    int a{1};
    decltype(a) b{2}; // int b{2};
    b += a;

    T t{1.0f};
    decltype(t) t1{2.0f}; // T t1{2.0f};
    decltype(t.x) x{3.0f}; // float x{3.0f};
    decltype(T::x) x1{4.0f}; // float x1{4.0f};
    return 0;
}
```

Его нельзя использовать в момент объявления.

```cpp
decltype(a) a = 5; // не компилируется
decltype(5) a = 5; // ок
```

Выражение может быть более сложным:

```cpp
#include <cmath>
decltype(std::max(5, 6) - static_cast<float>(5)) a = 5.0f; // float a = 5.0f;
```

### `auto`

`auto` - это ключевое слово, которое позволяет компилятору
*вывести* или *предположить* тип переменной из типа выражения, которое вы присваиваете ей.

`auto x = y;` эквивалентно `decltype(y) x = y;`.

```cpp
int a1 = 5;
auto a2 = 5; // int a2{5};
```

Его также можно использовать как тип возвращаемого значения функций.
В следующем примере компилятор выводит, что тип возвращаемого значения `f` -- это `int`:

```cpp
auto f()
{
    return 5;
}
```

На всякий случай упомяну, что переменные, объявленные с типом `auto`,
по-прежнему имеют статический тип, если это до сих пор не стало очевидно.
Вы не можете присвоить им переменную другого типа.

```cpp
auto a = 5;
a = 6; // ок
a = "Hello"; // не компилируется
```


