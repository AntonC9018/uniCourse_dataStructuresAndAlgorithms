
# Области видимости (scope)

В C++ области видимости выполняют две функции:
- Они служат для того, чтобы переменные не были видны за их пределами;
- Они используются для очистки памяти ("ресурсов") объектов.
  Это можно сделать с помощью деструкторов.

Можно сказать, что области видимости позволяют вам контролировать время жизни объектов.

## Области видимости для ограничения видимости

Области видимости создаются с использованием `{ ... }`.

```cpp
int main()
{
    int a = 1;

    {
        int b = 2;
        a = 5; // разрешено, `a` видна во внешней области видимости
        b = 10; // разрешено, `b` видна в текущей области видимости
    }

    b = 10; // не разрешено, `b` не видна, потому что ее область видимости завершилась 
            // (фигурная скобка была закрыта).

    a = 15; // все еще разрешено, потому что она видна в текущей области видимости

    return 0;
}
```

Функции должны определять область видимости для своего тела.


Вы можете переопределять переменные с тем же именем, если они находятся в разных областях видимости.
Не гарантируется, будут ли они указывать на одну и ту же память.

```cpp
int main()
{
    int a = 5;

    // Повторное объявление переменной в той же области видимости не разрешено.
    // int a;

    {
        // Повторное объявление здесь также не разрешено.
        // int a;

        int b = 10;
    }

    {
        // Это разрешено, потому что области видимости не взаимодействуют.
        int b = 20;

        {
            // Это было бы запрещено.
            // int b = 30;
        }
    }

    return 0;
}
```

Область видимости внутри другой области видимости называется *вложенной областью видимости*.
Вы можете *вкладывать* области видимости неограниченное количество раз.

> В целом, помещение одних вещей внутри других вещей того же вида называется *вложением* (nesting).

Существует также концепция глобальной области видимости,
которая представляет собой область видимости, находящуюся вне любой функции.


## Области видимости для очистки ресурсов

Концептуально переменная, объявленная в области видимости, уничтожается в конце области видимости.
Для простых типов, таких как `int`, это в буквальном смысле ничего не означает.
Для сложного типа, такого как `std::string`, это означает
возвращение памяти, выделенной для массива символов, C++ рантайму.


## Деструктор (destructor)

Вы можете определить свою собственную логику, которая будет вызываться при уничтожении вашего объекта с помощью *деструктора*.
Деструктор - это специальная `void` функция, которая автоматически вызывается в этом контексте.
Вы также можете вызывать его вручную.

Давайте просто покажем, как это работает.

```cpp
include <iostream>

struct Demo
{
    int i;

    // Это деструктор
    ~Demo()
    {
        std::cout << "Destroying demo " << this->i << std::endl;
    }
};

int main()
{
    Demo demo1{1};
    Demo demo2{2};
    std::cout << "Demos created" << std::endl;

    return 0;

    // Компилятор неявно добавляет следующее:
    // `demo2.~Demo();`
    // `demo1.~Demo();`
}
```

Что выводит:

```
Demos created
Destroying demo 2
Destroying demo 1
```

> Вы можете разделять объявление деструктора и его определение
> так же, как и с обычными методами.

Обратите внимание, что деструктор будет вызван только в этом контексте.
Если вы перезначите переменную, он не будет вызван для объекта, уже находящегося в этой памяти.

```cpp
int main()
{
    Demo demo1{1};
    Demo demo2{2};
    demo2 = demo1; // Это копирует байты объекта, но не вызывает деструктор `demo2`.

    return 0;

    // `demo2.~Demo()` выполняется, выводя "Destroying demo 1"
    // `demo1.~Demo()` выполняется, выводя "Destroying demo 1"
}
```

> Чтобы убедиться, что один и тот же объект не удаляется более одного раза
> в этой ситуации, нам придется перегрузить оператор присваивания.


## Неявные деструкторы (implicit destructors)

Предположим, у вас есть структура с полем, тип которого имеет деструктор.

```cpp
include <iostream>

struct Test
{
    ~Test()
    {
        std::cout << "Test destroyed" << std::endl;
    }
};

struct Person
{
    Test test;
};

int main()
{
    Person person;
    person.test = {};
    return 0;

    // Компилятор автоматически вызывает деструктор для каждого поля.
    // `person.test.~Test();`

    // Он также удалит временный объект, используемый для присваивания,
    // но это объясняется более подробно позже.
}
```

# Конструкторы (Constructors)

Конструкторы - это специальные `void` функции, используемые для инициализации объектов.
Конструкторы не могут быть вызваны в каком бы то ни было другом контексте.

Конструкторы были созданы для инициализации приватных данных (полей) в ООП.
Конструкторы могут быть более сложными, но, как правило, не рекомендуется делать их сложными.

## Конструкторы, используемые для инициализации новых объектов

> Если они начинают выходить из-под контроля в плане сложности,
> вы можете перейти к использованию фабричных функций.

Например, давайте определим конструктор без параметров (конструктор по умолчанию),
который выводит информацию на консоль.

```cpp
include <iostream>

class Demo
{
    int memory;

public:
    Demo()
    {
        // memory будет не инициализирована на этом этапе (содержать мусор).
        std::cout << "Created " << this->memory << std::endl;
        this->memory = 5;
    }

    ~Demo()
    {
        // memory равна 5 на этом этапе.
        std::cout << "Destroyed " << this->memory << std::endl;
    }
};

int main()
{
    {
        // Это фактически вызывает конструктор без параметров.
        // Дизайнеры C++ решили, что объекты никогда не должны оставаться неинициализированными.
        Demo demo;

        // Компилятор неявно добавил:
        // demo.~Demo();
    }

    {
        // Явно вызывает конструктор без параметров.
        Demo demo{};

        // Эквивалентный синтаксис:
        // Demo demo = Demo();

        // Компилятор неявно добавил:
        // demo.~Demo();
    }

    return 0;
}
```

Практическим использованием может быть, например, выделение памяти и очистка ее в деструкторе.
Мы можем сделать это, используя операторы `new` и `delete`.

```cpp
include <iostream>
include <assert.h>

class Buffer
{
// private:
    size_t length;
    int* firstElement;

public:
    Buffer(size_t elementCount) 
        // Вписывает `elementCount` в `length` напрямую, до того, как наш код будет запущен.
        // Это называется инициализатором членов.
        : length(elementCount) //, anotherField(8)
    {
        // `firstElement` содержит мусор здесь.

        // Нам нужно выделить память, которая не будет читаемой в инициализаторе.
        // Поэтому я решил написать это в теле конструктора.
        this->firstElement = new int[elementCount];

        // Элементы изначально не инициализированы.
    }

    ~Buffer()
    {
        delete[] firstElement;
    }

    int& elementAt(size_t index)
    {
        assert(index < this->length);
        return firstElement[index];
    }
};

int main()
{
    Buffer buffer{5};

    // Печатает мусор.
    std::cout << buffer.elementAt(0) << std::endl;

    // Do some stuff with the buffer.
    // Выполняем некоторые действия с буфером.
    int& secondElement = buffer.elementAt(1);
    secondElement = 10;

    return 0;

    // Компилятор неявно добавил следующее:
    // buffer.~Buffer();
}
```

## Как легко сломать код выше

Все равно очень легко сломать код выше и получить утечку памяти или повторные удаления памяти:

```cpp
int main()
{
    Buffer buffer1{10};
    Buffer buffer2{20};
    // Это делает копирование по полям.
    buffer2 = buffer1;
    return 0;

    // buffer длиной 20 никогда не освобождается
    // buffer длиной 10 удаляется дважды (ошибка во время выполнения)
}
```

## Конструкторы копирования (copy constructor)

Вы можете определить конструктор, который принимает ссылку на объект,
который будет вызван при копировании.
Это включает в себя обычные определения с использованием `{ }` или определения с немедленным присваиванием.

```cpp
include <iostream>

class Demo
{
    int id;

public:
    // Необходим конструктор с параметрами, чтобы вообще создать объект.
    Demo(int idParameter) : id(idParameter) { }

    // Demo(const Demo& other)
    Demo(Demo& other) : id(other.id)
    {
        std::cout << "Copying " << other.id << std::endl;
    }
};

int main()
{
    Demo a{1};

    // Вызывает конструктор копирования.
    Demo b{a};

    // Также вызывает конструктор копирования.
    Demo c = a;

    // Это НЕ вызывает конструктор копирования.
    // Он просто копирует поля.
    b = c; 
}
```

## Перемещение объекта (move semantics)

Перемещение объекта в другой объект позволяет одному объекту украсть ресурсы другого.
Это часто используется при создании объектов
или записи значений в поля, чтобы избежать вызова конструктора копирования.

Рассмотрим следующий пример, который создает 2 копии `std::string`:

```cpp
struct Person
{
    std::string name;
};

int main()
{
    // Вызывает конструктор `std::string`, который копирует символы в динамически выделенный буфер.
    std::string name = "John Brown";

    Person person;

    // Выделяет копию `name`, выделяя другой буфер и копируя символы.
    // Затем он записывает эту копию в `person.name`.
    person.name = name;

    return 0;

    // The compiler implicitly adds the following:
    // Компилятор неявно добавляет следующее:
    // `person.name~string();` (из неявного деструктора Person, который удаляет все поля)
    // `name.~string();`
}
```

Итак, мы перемещаем `name` в `person.name`, а не копируем его.
В данном случае это означает, по сути, копирование объекта строки в `person.name`,
а затем его очистку из переменной `name`, чтобы она больше не ссылается на буфер.
Таким образом, она становится непригодной к использованию после этого вызова.

```cpp
include <iostream>

struct Person
{
    std::string name;
};

int main()
{
    std::string name = "John Brown";
    Person person;

    std::cout << name << std::endl; // John Brown
    std::cout << person.name << std::endl; // 

    person.name = std::move(name);

    std::cout << name << std::endl; // 
    std::cout << person.name << std::endl; // John Brown

    return 0;
}
```

## Конструкторы перемещения (move constructors)

В общем случае вы можете определить конструкторы, принимающие *rvalue-ссылки* (\&\&, rvalue-reference).
Это означает ссылка, из которой нужно красть ресурсы.

> Не зацикливайтесь на деталях, я объясню, что такое rvalue-ссылки позже.

> Вы можете использовать rvalue-ссылки как обычные параметры тоже.

```cpp
include <iostream>

class Demo
{
    int* memoryPointer;

    int getValue()
    {
        if (memoryPointer == nullptr)
            return 0;
        return *memoryPointer;
    }

public:
    Demo(int value)
    {
        // Выделяет int на куче (просто для демонстрации, я знаю, что это бессмысленно),
        // и сохраняет указатель на него в `memoryPointer`.
        this->memoryPointer = new int{value};
    }

    ~Demo()
    {
        std::cout << "Destructor called for " << this->getValue() << std::endl;
        // Освобождает память (удаление nullptr разрешено).
        delete this->memoryPointer;
    }

    // Конструктор перемещения
    Demo(Demo&& other)
    {
        std::cout 
            << "Move constructor called for "
            << other.getValue()
            << std::endl;

        // Крадем указатель из другого объекта.
        this->memoryPointer = other.memoryPointer;

        // Очищаем указатель из другого объекта.
        // `nullptr` то же самое, что и `0`, он просто обнуляет его.
        other.memoryPointer = nullptr;
    }
};

int main()
{
    Demo demo1{1};
    Demo demo2{2};

    // Это вызывает конструктор перемещения.
    Demo demo3 = std::move(demo1);

    return 0;

    // Компилятор неявно добавляет следующее:
    // demo3.~Demo(); (очищает память с 1)
    // demo2.~Demo(); (очищает память с 2)
    // demo1.~Demo(); (ничего не делает)
}
```

## Оптимизация возврата значения (RVO, Return Value Optimization)

Если вы возвращаете объект из функции, его деструктор не будет вызван.
Фактически, конструктор перемещения тоже не будет вызван.
Он просто напрямую записывает результат в память переменной, объявленной для результата.

## Оптимизация возвращаемого значения (Return Value Optimization, RVO)

Если вы возвращаете объект из функции, его деструктор не будет вызван.
Фактически, конструктор перемещения (move constructor) также не будет вызван.
Результат будет напрямую записан в память переменной, объявленной для результата.

> Я не описал, как фактически работает возвращение объектов из функций,
> но это потому, что сам не знаю точных механизмов.
>
> Он может быть возвращен в одном или нескольких регистрах, а затем скопирован в переменную на стеке,
> или функция может использовать скрытый "выходной" адрес, куда будет записан результат.
> Я не знаю, в какой ситуации компилятор использует ту или иную реализацию,
> и есть ли более умные способы сделать это.
>
> Если вы знаете или хотите узнать больше, я был бы признателен, если бы вы сделали запрос на изменение (Pull Request) с кратким объяснением,
> или предоставили ссылки на ресурсы.

```cpp
Demo test()
{
    Demo demo1{1};
    Demo demo2{2};
    return demo1;

    // `demo2.~Demo();` вставлен компилятором, как обычно.
    // Вызов деструктора для `demo1` НЕ вставляется здесь.
}

int main()
{
    // Компилятор может реализовать это, передавая `test` скрытый указатель на локальную переменную `demo`,
    // и предоставив эту память локальной переменной `demo1` внутри `test`,
    // таким образом, память `demo1` фактически не хранится в стековом кадре `test`.
    // Вы можете представлять себе, что `demo1` является ссылкой на `demo`.
    // Обратите внимание, что это не обязательно то, что будет делать компилятор,
    // это только один из способов реализации этого поведения.
    Demo demo = test();
    return 0;

    // `demo.~Demo();` вставлен компилятором, как обычно.
}
```

RVO - это то почему *не следует перемещать объекты из функций*.

```cpp
Demo test()
{
    Demo demo{1};
    // НЕ Делайте это, это приведет к дополнительному копированию.
    // Это вызовет конструктор перемещения в выходной памяти,
    // а также вызовет деструктор локальной переменной `demo` в конце функции.
    return std::move(demo);
}
```

