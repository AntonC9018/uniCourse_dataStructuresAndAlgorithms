# `enum` и `enum class`

`enum` позволяет определять именованные константы, доступные во времени компиляции,
используя упрощенный синтаксис.

## Концепция перечисления

`enum` означает *перечисление*, что означает исчерпывающий список возможных вещей.
Представьте, что хотите представить цвета светофора -- как бы вы это сделали?
Самый простой подход - определить константу для каждого возможного цвета:
одна для красного, одна для желтого и одна для зеленого.

```cpp
static inline const int RED = 0;
static inline const int YELLOW = 1;
static inline const int GREEN = 2;
```

`static inline` присутствуют, чтобы линкера не обращал на них внимания
при ликнинге файлов и чтобы они не попадали в конечный исполняемый файл.
Каждый файл, который хочет использовать эти константы, 
может просто импортировать файл, который их определяет,
не переживая о дублировании определений.

И вы могли бы использовать это [так](../../en/05a_programming_fundamentals/enums/global_const_list.cpp).

Это в точности то, что делает `enum`.
Он просто упрощает то, как определяются константы.

```cpp
enum TrafficLightColors
{
    RED = 0,
    YELLOW = 1,
    GREEN = 2,
};
```

Более того, указание значений становится необязательным.
Они автоматически инкрементируются компилятором, если их не задать вручную.
Так что, если вы не пишете их, как здесь:

```cpp
enum TrafficLightColors
{
    RED,
    YELLOW,
    GREEN,
};
```

Это по сути эквивалентно следующему:

```cpp
enum TrafficLightColors
{
    RED = 0,
    YELLOW = RED + 1,
    GREEN = YELLOW + 1,
};
```

И если бы вы сделали:

```cpp
enum TrafficLightColors
{
    RED,
    YELLOW = 55,
    GREEN,
};
```

Это было бы эквивалентно:

```cpp
enum TrafficLightColors
{
    RED = 0,
    YELLOW = 55,
    GREEN = YELLOW + 1, // 56
};
```

## `enum class`

Было бы хорошей идеей иметь способ обеспечения того, что тип
целого числа, передаваемого в какую-то функцию, является одним из перечисленных значений.
Вы можете сделать это с помощью `struct`. См. [пример](../../en/05a_programming_fundamentals/enums/namespaced_enum.cpp).

Это по сути то, чего вам позволяет добиться `enum class`, но с
гораздо более простым синтаксисом.
См. [пример](../../en/05a_programming_fundamentals/enums/enum_class.cpp).

> Единственное важное отличие заключается в том, что в нашей реализации `struct`,
> вы не обязаны определять константы в пределах пространства имен,
> но с `enum class` они всегда определены в пределах пространства имен.
> Это означает, что вы можете вытащить все константы в текущий скоуп с помощью `using`,
> но вы не можете сделать то же самое с `enum class`.

## Базовый тип

`enum` не ограничивается только int - вы можете использовать любой другой тип для представления значений.
Например, вы можете использовать байт, если максимальное значение меньше 256.
Для этого нужно указать базовый тип после имени перечисления.

```cpp
#include <stdint.h>

enum TrafficLightColor
    : uint8_t // базовый тип, 8-битное беззнаковое целое
{
    RED = 0,
    YELLOW = 1,
    GREEN = 2,
};
```

Кроме того, вы можете фактически записать недопустимое значение в переменную типа перечисления,
т.е. записать значение, которое не является одной из констант.
Обычно вы этого не ожидаете в коде, поэтому, когда вы натыкаетесь на такое значение,
вполне разумно использовать `assert(false)`, чтобы сразу крашнуть программу.

```cpp
enum class TrafficLightColor
    // : int // неявно int
{
    RED = 0,
    YELLOW = 1,
    GREEN = 2,
};

int main()
{
    // Создание недопустимого цвета разрешено.
    TrafficLightColor color = static_cast<TrafficLightColor>(5);
    return 0;
}
```

