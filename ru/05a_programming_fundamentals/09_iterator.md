
# Итераторы

*Итератор* - мощный шаблон программирования, который позволяет 
абстрагировать логику итерации по коллекции элементов.

## Пример шаблона итератора

Представьте, что у вас есть древовидный граф, и вы хотите выполнить
[обход в глубину (depth-first traversal)](../../en/05a_programming_fundamentals/iterator/graph_1.cpp), выводя все значения.

Код, конечно, довольно простой, но что, 
если нам нужно было вычислить сумму значений из всех нодов?
Пришлось бы продублировать функцию обхода и изменить логику внутри на суммирование:

```cpp
int sumDFS(const Node* node)
{
    int result = node->value;
    for (size_t i = 0; i < node->children.size(); i++)
        result += sumDFS(node->children[i]);
    return result;
}
```

Можно представить, как это может стать проблематичным, если логика обхода более сложная,
чем просто рекурсивное прохождение по дочерним нодам.

Один из способов решения этой проблемы - использовать паттерн стратегии, или visitor,
т.е. передачу функции для выполнения при посещении нода.
Как сделать что-то подобное, будет описано позже в теме про полиморфизм.

Здесь мы обсудим паттерн итератора, который является другим решением этой проблемы,
при том более гибким.
Он позволяет приостанавливать обход, продолжив его позже, а также выбрать
операцию выполняемую над элементами и доступ к любым вашим переменным.

Идея следующая: будем хранить текущее состояние итерации в объекте,
по факту представляя, как будет выглядеть стек в определенные момент рекурсивного выполнения,
определим функции для перемещения итератора к следующему элементу
(и, возможно, дополнительные функции, например, для перехода к предыдущему элементу).
Нам также понадобится способ дать сигнал о том, что итерация завершена.
Смотрите [код](../../en/05a_programming_fundamentals/iterator/graph_manual_iterator.cpp).

> Рекомендую выполнить программу с дебаггером,
> чтобы понять, как работает программа.

Конечно, код вышел сложнее, особенно в том плане, что
приходится имитировать стек вручную (это не всегда необходимо в итераторах).
Как правило, код итератора всегда сложнее, чем прямая итерация,
но добавленная гибкость + устранение дублирования кода часто того стоят.

## Итераторы в C++

У C++ есть "стандартный способ" создания итераторов, который необходим для некоторых
шаблонных функций в стандартной библиотеке:

- Тип итератора перегружает оператор `++` (с логикой метода `advance` из моего примера).
  Он также по желанию перегружает операторы `--`, чтобы вернуться к предыдущему элементу.

- Тип итератора перегружает оператор `*` (с логикой метода `value` из моего примера). 
  Оператор `*` -- то есть оператор разыменования указателя.
  Если возможно, пусть возвращать ссылку, вместо копии.

- У итератора есть специальное состояние, означающее конец итерации.
  В моем случае я определил метод `empty`, но мы могли бы представить это "пустое" состояние
  как два пустых вектора.
  Затем проверка на пустоту (конец итерации) осуществляется путем сравнением итератора 
  с этим специальным значением.

- Типы, которые определяют один способ итерации, могут определять методы `begin` и `end`,
  которые возвращают состояние итератора первого элемента и специальное состояние пустоты соответственно.

Смотрите [тот же пример, что и раньше, но с использованием стандартного подхода](../../en/05a_programming_fundamentals/iterator/graph_standard.cpp).

Этот дизайн мотивирован стремлением имитировать интерфейс указателей.
`++p` перемещает указатель на один элемент, `*p` считывает значение по адресу,
и `p == start+count` проверяет, достигли ли мы конца массива, например.

## Преимущества стандартного подхода

Если вы выполнили итератор по С++-овски, вы автоматом получаете классный
синтаксис range итерации.
Если ваш тип имеет методы `begin` и `end`, вы можете использовать его в foreach версии цикла `for`.
Смотрите [пример](../../en/05a_programming_fundamentals/iterator/graph_range_for.cpp).

Этот синтаксис работает для большинства стандартных типов контейнеров,
потому что они выполняют паттерн следуя этому походу,
определяя методы `begin` и `end`, а также тип итератора с операциями,
описанными выше.

Вам не обязательно определять еще один тип. 
Если имеет смысл выполнять только один вид итерации для вашей структуры данных,
или какой-то вид итерации явно должен быть дефолтным,
вы можете определить методы `begin` и `end` для вашего типа контейнера напрямую.
Это имеет смысл, для, например, `DynamicArray`, но, наверное, не для графа.

